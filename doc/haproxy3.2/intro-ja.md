# HAProxy version 3.2.4 - Starter Guide

## LICENSE

```
本資料は、GPL v2ライセンスに基づき公開された 以下のドキュメントを簡易的に抜粋翻訳したもので、内容の正確性、網羅性は保証しない。
https://docs.haproxy.org/3.2/intro.html

Copyright (c) 2006 Willy Tarreau - w@1wt.eu

この翻訳物の配布もGPL v2に従う。
```

## 1. 利用可能なドキュメント

完全なHAProxyドキュメントは以下の文書に含まれている。時間を節約し、ニーズに最も適切な回答を得るために、関連するドキュメントを必ず参照すること。また、これらの文書に回答が含まれている質問をメーリングリストに送信することは避けること。

  - intro.txt（この文書）: ロードバランシングの基本、HAProxyという製品、その機能、できないこと、避けるべき既知の落とし穴、OS固有の制限、入手方法、進化の仕組み、既知の修正がすべて適用されていることを確認する方法、更新方法、補完と代替手段について説明している。

  - management.txt: haproxyの起動方法、実行時の管理方法、複数ノードでの管理方法、シームレスなアップグレードの進め方について説明している。

  - configuration.txt: リファレンスマニュアルは、すべての設定キーワードとそのオプションを詳細に説明している。設定変更が必要な場合に使用される。

  - coding-style.txt: これは、プロジェクトにコードを提案したい開発者向けである。コードで採用すべきスタイルについて説明している。非常に厳格ではなく、すべてのコードベースが完全にこれを遵守しているわけではないが、これから大きく逸脱する貢献は拒否される。

  - proxy-protocol.txt: これは、HAProxyと多数のサードパーティ製品によって実装されているPROXYプロトコルの事実上の仕様である。

  - README: ソースからHAProxyをビルドする方法
## 2. ロードバランシングとロードバランサーへの簡単な導入

ロードバランシングは、複数のコンポーネントを集約して、各コンポーネントの個別の容量を上回る総処理能力を達成することを意味する。これは、エンドユーザーの介入なしに、スケーラブルな方法で行われる。これにより、1つのコンポーネントが1つの操作を実行するのにかかる時間内に、より多くの操作が同時に実行されることになる。ただし、単一の操作は依然として一度に1つのコンポーネントで実行され、ロードバランシングなしの場合よりも高速になることはない。常に、利用可能なコンポーネントの数と同数の操作、およびすべてのコンポーネントを活用してロードバランシングの恩恵を完全に受けるための効率的なロードバランシングメカニズムが必要である。この良い例は、高速道路の車線数であり、個々の車の速度を上げることなく、同じ時間枠内でより多くの車が通過できるようにしている。

ロードバランシングの例：

  - マルチプロセッサシステムでのプロセススケジューリング
  - リンクロードバランシング（例：EtherChannel、Bonding）
  - IPアドレスロードバランシング（例：ECMP、DNSラウンドロビン）
  - サーバーロードバランシング（ロードバランサー経由）

ロードバランシング操作を実行するメカニズムまたはコンポーネントは、ロードバランサーと呼ばれる。Web環境では、これらのコンポーネントは「ネットワークロードバランサー」と呼ばれ、この活動がロードバランシングの最もよく知られたケースであることから、より一般的には「ロードバランサー」と呼ばれる。

ロードバランサーは以下のレベルで動作する可能性がある：

  - リンクレベル：これはリンクロードバランシングと呼ばれ、パケットを送信するネットワークリンクを選択することで構成される。

  - ネットワークレベル：これはネットワークロードバランシングと呼ばれ、一連のパケットが従うルートを選択することで構成される。

  - サーバーレベル：これはサーバーロードバランシングと呼ばれ、接続またはリクエストを処理するサーバーを決定することで構成される。

2つの異なる技術が存在し、異なるニーズに対応しているが、一部重複している。いずれの場合も、ロードバランシングがトラフィックを自然な流れから逸らすことで構成されており、そうすることで常にすべてのルーティング決定間で必要なレベルの一貫性を維持するための最小限の注意が必要であることを覚えておくことが重要である。

最初の技術はパケットレベルで動作し、パケットを個別に処理する。入力パケットと出力パケットの間に1対1の関係があるため、通常のネットワークスニッファーを使用してロードバランサーの両側でトラフィックを追跡することが可能である。この技術は非常に安価で極めて高速である可能性がある。通常、ハードウェア（ASIC）で実装され、ECMPを行うスイッチなど、ライン速度に達することができる。通常はステートレスであるが、ステートフル（パケットが属するセッションを考慮し、レイヤ4-LBまたはL4と呼ばれる）である可能性もあり、パケットが変更されていない場合、DSR（ロードバランサーを再度通過することなく、サーバーから直接戻る）をサポートする可能性があるが、コンテンツの認識はほとんど提供しない。この技術はネットワークレベルのロードバランシングに非常に適しているが、高速度での非常に基本的なサーバーロードバランシングに使用されることもある。

2番目の技術はセッションコンテンツに作用する。入力ストリームを再構築し、全体として処理する必要がある。コンテンツは変更される可能性があり、出力ストリームは新しいパケットにセグメント化される。この理由により、通常はプロキシによって実行され、レイヤ7ロードバランサーまたはL7と呼ばれることが多い。これは、各側に2つの異なる接続があり、入力パケットと出力パケットのサイズや数に関係がないことを意味する。クライアントとサーバーが同じプロトコルを使用する必要はない（例：IPv4対IPv6、平文対SSL）。操作は常にステートフルであり、戻りのトラフィックはロードバランサーを通過する必要がある。追加の処理にはコストが伴うため、特に小さなパケットでは、常にライン速度を達成できるとは限らない。一方で、幅広い可能性を提供し、通常は純粋なソフトウェアによって達成される（ハードウェアアプライアンスに組み込まれている場合でも）。この技術はサーバーロードバランシングに非常に適している。

パケットベースのロードバランサーは通常、カットスルーモードでデプロイされるため、トラフィックの通常のパスにインストールされ、設定に従ってトラフィックを迂回させる。戻りのトラフィックは必ずしもロードバランサーを通過する必要はない。トラフィックを適切な宛先に導くために、ネットワーク宛先アドレスに一部の変更が適用される場合がある。この場合、戻りのトラフィックがロードバランサーを通過することが必須である。ルートがこれを可能にしない場合、ロードバランサーは戻りのトラフィックを強制的に通過させるために、パケットの送信元アドレスを自身のアドレスに置き換えることもある。

プロキシベースのロードバランサーは、アーキテクチャの変更なしに、独自のIPアドレスとポートを持つサーバーとしてデプロイされる。時には、クライアントがサーバーのIPアドレスに直接接続するのではなく、ロードバランサーのIPアドレスに適切に導かれるように、アプリケーションに一部の適応を実行する必要がある。一部のロードバランサーは、これを可能にするために一部のサーバーの応答を調整する必要がある場合がある（例：HTTPリダイレクトで使用されるHTTP Locationヘッダーフィールド）。一部のプロキシベースのロードバランサーは、所有していないアドレスのトラフィックを傍受し、サーバーに接続する際にクライアントのアドレスを偽装する場合がある。これにより、通常のルーターやファイアウォールであるかのように、パケットベースのロードバランサーと非常によく似たカットスルーモードでデプロイすることができる。これは、パケットモードとプロキシモードの両方を組み合わせた製品に特に評価されている。この場合、DSRは明らかにまだ不可能であり、戻りのトラフィックは依然としてロードバランサーに戻ってルーティングされる必要がある。

非常にスケーラブルな階層化アプローチは、複数のロードバランスされたリンクからトラフィックを受信し、ECMPを使用してこのトラフィックを複数のステートフルパケットベースのロードバランサー（L4）の最初のレイヤーに分散するフロントルーターを持つことで構成される。これらのL4ロードバランサーは、今度はトラフィックをさらに多数のプロキシベースのロードバランサー（L7）に渡し、これらはコンテンツを解析して、どのサーバーが最終的にトラフィックを受信するかを決定する必要がある。

コンポーネントの数とトラフィックの可能なパスが増加すると、障害のリスクが増加する。非常に大規模な環境では、少数の故障したコンポーネントが常に修理または交換されていることも正常である。スタック全体の健全性を認識せずに行われるロードバランシングは、可用性を大幅に低下させる。この理由により、健全なロードバランサーは、トラフィックを配信しようとしているコンポーネントがまだ生きており、到達可能であることを確認し、故障したコンポーネントへのトラフィック配信を停止する。これは様々な方法で達成できる。

最も一般的な方法は、コンポーネントがまだ動作していることを確認するために定期的にプローブを送信することで構成される。これらのプローブは「ヘルスチェック」と呼ばれる。これらは対処すべき障害の種類を代表する必要がある。例えば、pingベースのチェックは、Webサーバーがクラッシュしてポートをリッスンしなくなったことを検出しないが、ポートへの接続はこれを確認し、より高度なリクエストは、サーバーがまだ動作しており、依存しているデータベースがまだアクセス可能であることを検証することさえある。ヘルスチェックは、時折の測定エラーをカバーするために、通常いくつかの再試行を含む。チェック間の期間は、障害が発生した後、故障したコンポーネントが長すぎる間使用されないことを確実にするために十分に小さくする必要がある。

他の方法は、宛先に送信された本番トラフィックをサンプリングして、それが正しく処理されているかどうかを観察し、不適切な応答を返すコンポーネントを排除することで構成される。ただし、これには本番トラフィックの一部を犠牲にする必要があり、これは常に受け入れられるとは限らない。これら2つのメカニズムの組み合わせは、両方の世界の最良を提供し、両方が障害を検出するために使用され、ヘルスチェックのみが障害の終了を検出する。最後の方法は集中報告を含む：中央監視エージェントが、すべてのコンポーネントの状態について定期的にすべてのロードバランサーを更新する。これにより、すべてのコンポーネントにインフラストラクチャのグローバルビューが提供されるが、時には精度や応答性が低い場合がある。これは、多くのロードバランサーと多くのサーバーを持つ環境に最適である。

レイヤ7ロードバランサーは、スティッキネスまたは永続性として知られる別の課題にも直面する。原則は、通常、同じ発信元（エンドユーザーなど）からの複数の後続のリクエストまたは接続を同じターゲットに導く必要があることである。最もよく知られた例は、オンラインストアのショッピングカートである。各クリックが新しい接続につながる場合、ユーザーは常に自分のショッピングカートを保持しているサーバーに送信される必要がある。コンテンツ認識により、リクエスト内の一部の要素を特定して、配信するサーバーを識別することが容易になるが、これだけでは十分ではない場合がある。例えば、送信元アドレスがサーバーを選択するためのキーとして使用される場合、ハッシュベースのアルゴリズムが使用され、特定のIPアドレスが常に利用可能なサーバーの数によるアドレスの除算に基づいて同じサーバーに送信されることが決定される可能性がある。しかし、1つのサーバーが故障した場合、結果が変わり、すべてのユーザーが突然異なるサーバーに送信され、ショッピングカートを失う。この問題に対する解決策は、選択されたターゲットを記憶することで構成され、同じ訪問者が見られるたびに、利用可能なサーバーの数に関係なく、同じサーバーに導かれる。情報はロードバランサーのメモリに保存される場合があり、この場合、単独でない場合は他のロードバランサーに複製する必要がある場合がある。または、クライアントがすべてのリクエストでこの情報を提示できる場合、様々な方法を使用してクライアントのメモリに保存される場合がある（Cookie挿入、サブドメインへのリダイレクトなど）。このメカニズムは、不安定または不均等に分散された情報（送信元IPアドレスなど）に依存する必要がないという追加の利点を提供する。これは実際、レイヤ4のロードバランサーの代わりにレイヤ7ロードバランサーを採用する最も強力な理由である。

Cookie、ホストヘッダーフィールド、URL、またはその他の情報を抽出するために、ロードバランサーはSSL/TLSトラフィックを復号化し、サーバーに渡す際に再暗号化する必要がある場合がある。この高価なタスクは、一部の高トラフィックインフラストラクチャで、時には多くのロードバランサーが存在する可能性がある理由を説明している。

レイヤ7ロードバランサーはトラフィックに対して多くの複雑な操作（復号化、解析、変更、Cookieの照合、どのサーバーに送信するかの決定など）を実行する可能性があるため、確実に一部のトラブルを引き起こす可能性があり、実際には明らかにしただけの多くのトラブルの原因として非難されることが非常に多い。サーバーが不安定で定期的にアップダウンしていること、またはWebサーバーの場合、クライアントがロードバランサーを経由せずに特定のサーバーに直接接続することを強制するハードコードされたリンクを持つページを配信していること、または高負荷下で応答に時間がかかり、タイムアウトを引き起こしていることが発見されることが多い。そのため、ログ記録はレイヤ7ロードバランシングの極めて重要な側面である。トラブルが報告されたら、ロードバランサーが間違った決定を下したかどうか、もしそうであればなぜそうなったかを理解し、再び発生しないようにすることが重要である。
## 3. HAProxyへの導入

HAProxyは、製品を指す場合は「HAProxy」と表記され、実行可能プログラム、ソフトウェアパッケージ、またはプロセスを指す場合は「haproxy」と表記される。ただし、両方とも両方の目的で一般的に使用され、H-A-Proxyと発音される。非常に初期には、「haproxy」は「high availability proxy」を意味し、名前は2つの別々の単語で書かれていたが、現在では「HAProxy」以外の意味は持たない。
### 3.1 HAProxyとは何であり、何ではないか

HAProxyは以下のものである：

  - TCPプロキシ：リスニングソケットからのTCP接続を受け入れ、サーバーに接続し、これらのソケットを接続して双方向のトラフィックフローを可能にする。IPv4、IPv6、さらにはUNIXソケットが両側でサポートされているため、異なるファミリー間のアドレス変換を簡単に提供できる。

  - HTTPリバースプロキシ（HTTP用語では「ゲートウェイ」と呼ばれる）：サーバーとして自身を提示し、リスニングTCPソケットで受け入れられた接続上でHTTPリクエストを受信し、これらの接続からのリクエストを異なる接続を使用してサーバーに渡す。任意の組み合わせでHTTP/1.xまたはHTTP/2を両側で使用でき、TLS上でALPNが使用される場合、各側で話されるプロトコルを自動的に検出する。

  - SSLターミネーター/イニシエーター/オフローダー：SSL/TLSはクライアントからの接続、サーバーへの接続、さらには両方の接続で使用できる。多くの設定を名前（SNI）ごとに適用でき、再起動せずにランタイムで更新できる。このような設定は非常にスケーラブルで、数万から数十万の証明書を含むデプロイメントが報告されている。

  - TCP正規化器：接続がオペレーティングシステムによってローカルで終端されるため、両側の間に関係はなく、無効なパケット、フラグの組み合わせ、ウィンドウ広告、シーケンス番号、不完全な接続（SYNフラッド）などの異常なトラフィックは他側に渡されない。これにより脆弱なTCPスタックがプロトコル攻撃から保護され、サーバーのTCPスタック設定を変更することなくクライアントとの接続パラメータを最適化できる。

  - HTTP正規化器：HTTPトラフィックを処理するように設定されている場合、有効で完全なリクエストのみが渡される。これにより多くのプロトコルベースの攻撃から保護される。さらに、仕様で許容されるプロトコル逸脱は修正されるため、サーバーで問題を引き起こさない（例：複数行ヘッダー）。

  - HTTP修正ツール：URLまたは任意のリクエストまたはレスポンスヘッダーを修正/修正/追加/削除/書き換えることができる。これにより複雑な環境での相互運用性の問題を修正するのに役立つ。

  - コンテンツベーススイッチ：リクエストから任意の要素を考慮して、リクエストまたは接続を渡すサーバーを決定できる。これにより、同じポート上で複数のプロトコルを処理できる（例：HTTP、HTTPS、SSH）。

  - サーバーロードバランサー：TCP接続とHTTPリクエストのロードバランシングができる。TCPモードでは、ロードバランシングの決定が接続全体に対して行われる。HTTPモードでは、リクエストごとに決定が行われる。

  - トラフィックレギュレーター：様々なポイントでレート制限を適用し、サーバーを過負荷から保護し、コンテンツに基づいてトラフィックの優先度を調整し、さらにはパケットにマークを付けることにより、このような情報を下位レイヤーと外部ネットワークコンポーネントに渡すことができる。

  - DDoSとサービス悪用に対する保護：IPアドレス、URL、Cookieなどごとに幅広い統計を維持し、悪用が発生していることを検出してから、アクションを取る（攻撃者を遅くする、ブロックする、古いコンテンツに送るなど）。

  - ネットワークトラブルシューティングの観察ポイント：ログで報告される情報の精度により、ネットワーク関連の問題を特定するためによく使用される。

  - HTTP圧縮オフローダー：サーバーによって圧縮されていないレスポンスを圧縮でき、接続性が悪いクライアントや高レイテンシー、モバイルネットワークを使用するクライアントのページ読み込み時間を短縮する。

  - キャッシュプロキシ：レスポンスをRAMにキャッシュできるため、同じオブジェクトに対する後続のリクエストは、オブジェクトが存在し有効である限り、サーバーからの別のネットワーク転送のコストを回避できる。ただし、オブジェクトを永続的なストレージに保存することはない。このキャッシュ機能はメンテナンス不要になるように設計されており、HAProxyの貴重なリソースを節約することのみに焦点を当てており、サーバーのリソースを節約することは目的としていない。サーバーを最適化するために設計されたキャッシュは、はるかに多くの調整と柔軟性を必要とする。代わりにそのような高度なキャッシュが必要な場合は、Varnish Cacheを使用してください。これはHAProxyと完全に統合され、特にSSL/TLSが任意の側で必要な場合に適している。

  - FastCGIゲートウェイ：FastCGIはHTTPの異なる表現と見なすことができ、そのため、HAProxyはそれらの間に別のレベルのゲートウェイを挿入することなく、任意の組み合わせのFastCGIアプリケーションサーバーで構成されるファームを直接ロードバランシングできる。これによりリソースの節約とメンテナンスコストの削減が実現される。

HAProxyは以下のものではない：

  - 明示的なHTTPプロキシ、つまりブラウザがインターネットに到達するために使用するプロキシ。このタスク専用の優れたオープンソースソフトウェア（Squidなど）が存在する。ただし、HAProxyはそのようなプロキシの前面にインストールしてロードバランシングと高可用性を提供できる。

  - データスクラバー：リクエストやレスポンスのボディを修正しない。

  - 静的Webサーバー：起動時に、自身をchroot jail内に隔離し、権限を削除するため、起動後は単一のファイルシステムアクセスを実行しない。そのため、静的Webサーバーに変換することはできない（動的サーバーはFastCGIを通じてサポートされる）。これにはApacheやNginxなどの優れたオープンソースソフトウェアが存在し、HAProxyはそれらの前面に簡単にインストールしてロードバランシング、高可用性、高速化を提供できる。

  - パケットベースのロードバランサー：IPパケットやUDPデータグラムを見ることはなく、NATやDSRを実行することもない。これらは下位レイヤーのタスクである。IPVS（Linux Virtual Server）などのカーネルベースのコンポーネントが既にこれを非常にうまく行っており、HAProxyと完全に補完し合う。
### 3.2 HAProxyの動作方法

HAProxyは、非常に高速なI/Oレイヤーと優先度ベースのマルチスレッドスケジューラーを組み合わせたイベント駆動の非ブロッキングエンジンである。データ転送を目標として設計されているため、そのアーキテクチャは可能な限り少ない操作でデータを可能な限り高速に移動するように最適化されている。接続を可能な限り長く同じCPUに固定することにより、CPUキャッシュの効率を最適化することに焦点を当てている。そのため、バイパスメカニズムを各レベルで提供する階層化モデルを実装し、必要でない限りデータが上位レベルに到達しないようにしている。処理の大部分はカーネルで実行され、HAProxyはカーネルが作業を可能な限り高速に実行できるように、ヒントを提供したり、後でグループ化できる可能性があると推測される特定の操作を回避したりすることにより、最善を尽くしている。その結果、典型的な数値では、TCPまたはHTTP closeモードでHAProxyが15%、カーネルが85%の処理時間を費やし、HTTP keep-aliveモードではHAProxyが約30%、カーネルが70%を費やす。

単一のプロセスで多くのプロキシインスタンスを実行できる。単一プロセスで30万の異なるプロキシを含む設定が正常に動作することが報告されている。単一コア、単一CPUの設定は99%以上のユーザーにとって十分以上であり、そのため、コンテナと仮想マシンのユーザーは、運用コストを節約し、トラブルシューティングを簡素化するために、取得できる絶対的に最小のイメージを使用することが推奨されている。ただし、HAProxyが実行されるマシンは決してスワップしてはならず、そのCPUは人為的にスロットリング（ハイパーバイザーでのサブCPU割り当て）されてはならず、非常に高いコンテキストスイッチレイテンシーを引き起こす計算集約的なプロセスと共有されてはならない。

スレッド化により、CPUコアごとに1つのスレッドを使用することにより、利用可能なすべての処理容量を活用できる。これは主にSSLまたは40 Gbpsを超えるデータ転送レートが必要な場合に有用である。このような場合、複数の物理CPU間の通信を回避することが非常に重要であり、これによりネットワークスタックとHAProxy自体で強いボトルネックが発生する可能性がある。一部の人にとっては直感に反するが、パフォーマンスの問題に直面したときに最初に行うべきことは、HAProxyが実行されるCPUの数を減らすことが多い。

HAProxyは実行するためにhaproxy実行可能ファイルと設定ファイルのみを必要とする。ログ記録については、適切に設定されたsyslogデーモンとログローテーションを配置することが強く推奨されている。ログはstdout/stderrにも送信でき、これはコンテナ内で有用である可能性がある。設定ファイルは起動前に解析され、その後HAProxyはすべてのリスニングソケットのバインドを試み、何かが失敗した場合は起動を拒否する。この時点を過ぎると、それ以上失敗することはない。これは、ランタイムの失敗がなく、起動を受け入れた場合、停止されるまで動作することを意味する。

HAProxyが起動されると、正確に3つのことを行う：

  - 着信接続を処理する；

  - サーバーのステータスを定期的にチェックする（ヘルスチェックとして知られる）；

  - 他のhaproxyノードと情報を交換する。

着信接続の処理は、多くの設定可能性に依存するため、はるかに最も複雑なタスクであるが、以下の9つのステップとして要約できる：

  - 設定エンティティとして知られる「frontend」に属するリスニングソケットから着信接続を受け入れる。これは1つまたは複数のリスニングアドレスを参照する；

  - これらの接続にフロントエンド固有の処理ルールを適用する。これにより、ブロック、一部のヘッダーの修正、統計ページやCLIなどの内部アプレットを実行するためのインターセプトが生じる可能性がある；

  - これらの着信接続を、サーバーファームを表す別の設定エンティティに渡す。これは「backend」として知られ、サーバーのリストとこのサーバーファームのロードバランシング戦略を含む；

  - これらの接続にバックエンド固有の処理ルールを適用する；

  - ロードバランシング戦略に従って、接続を転送するサーバーを決定する；

  - レスポンスデータにバックエンド固有の処理ルールを適用する；

  - レスポンスデータにフロントエンド固有の処理ルールを適用する；

  - 何が起こったかを詳細に報告するログを出力する；

  - HTTPでは、新しいリクエストを待つために2番目のステップに戻る。そうでなければ接続を閉じる。

フロントエンドとバックエンドは、エンドツーエンド接続の片側のみを見るため、半プロキシと見なされることがある。フロントエンドはクライアントのみを気にし、バックエンドはサーバーのみを気にする。HAProxyはまた、フロントエンドとバックエンドの正確な結合であるフルプロキシもサポートしている。HTTP処理が望まれる場合、設定は一般的にフロントエンドとバックエンドに分割される。これは、任意のフロントエンドが接続を任意のバックエンドに渡すことができるため、多くの可能性を開く。TCPのみのプロキシでは、フロントエンドとバックエンドを使用することはめったに利点を提供せず、設定はフルプロキシでより読みやすくなる可能性がある。
### 3.3 基本機能

このセクションでは、HAProxyが実装する多くの機能を列挙する。その中には、現代のロードバランサーから一般的に期待されるものと、HAProxyのアーキテクチャから直接得られる利点があるものがある。より高度な機能は次のセクションで詳しく説明される。

#### 3.3.1 基本機能：プロキシ

プロキシは、クライアントとサーバー間の2つの独立した接続上でデータを転送する動作である。HAProxyは、プロキシと接続管理に関して以下の基本機能をサポートしている：

  - サーバーにクリーンな接続を提供して、クライアント側の欠陥や攻撃から保護する；

  - 複数のIPアドレスやポート、さらにはポート範囲にリッスンする；

  - 透過的な受け入れ：ローカルシステムに属していない任意のIPアドレスをターゲットとするトラフィックをインターセプトする；

  - サーバーポートはリスニングポートに関連する必要がなく、固定オフセットによって変換される可能性もある（範囲で有用）；

  - 透過的な接続：必要に応じてサーバーに接続する際にクライアントの（または任意の）IPアドレスを偽装する；

  - マルチサイトLBでサーバーに信頼できるリターンIPアドレスを提供する；

  - バッファと可能性として短命の接続によりサーバーをオフロードして、同時接続数とメモリフットプリントを削減する；

  - TCPスタック（例：SACK）、輻輳制御を最適化し、RTTの影響を削減する；

  - 両側で異なるプロトコルファミリーをサポートする（例：IPv4/IPv6/Unix）；

  - タイムアウトの強制：HAProxyは接続がどの段階にあるかに応じて複数のレベルのタイムアウトをサポートするため、死んだクライアントやサーバー、または攻撃者は長すぎる間リソースを付与されない；

  - プロトコル検証：HTTP、SSL、またはペイロードが検査され、無効なプロトコル要素は拒否される（それらをとにかく受け入れるように指示されていない限り）；

  - ポリシーの強制：許可されたもののみが転送されることを保証する；

  - 着信と発信の両方の接続は、特定のネットワーク名前空間（Linuxのみ）に制限される可能性があり、クロスコンテナ、マルチテナントロードバランサーを構築しやすくする；

  - PROXYプロトコルは、非HTTPトラフィックでもサーバーにクライアントのIPアドレスを提示する。これはHAProxy拡張であり、執筆時点で多くのサードパーティ製品によって採用されている。少なくとも以下のものがある：
      - クライアント：haproxy、stud、stunnel、exaproxy、ELB、squid
      - サーバー：haproxy、stud、postfix、exim、nginx、squid、node.js、varnish

#### 3.3.2 基本機能：SSL

HAProxyのSSLスタックは、Googleのエンジニアによると最も機能豊富なものの1つとして認識されている（ http://istlsfastyet.com/ ）。それをかなり完全にする最も一般的に使用される機能は以下の通りである：

  - サイト数に制限のないSNIベースのマルチホスティングとパフォーマンスへの焦点。少なくとも1つのデプロイメントが5万のドメインとそれぞれの証明書で動作することが知られている；

  - ワイルドカード証明書のサポートにより、多くの証明書の必要性が削減される；

  - 証明書ベースのクライアント認証と、有効な証明書を提示できない場合の設定可能なポリシー。これにより、クライアント証明書を再生成するために異なるサーバーファームを提示することができる（例）；

  - バックエンドサーバーの認証により、バックエンドサーバーが本物であり、中間者ではないことが保証される；

  - バックエンドサーバーとの認証により、バックエンドサーバーはそれに接続しているのが本当に期待されるhaproxyノードであることを知る；

  - TLS NPNとALPN拡張により、SPDY/HTTP2接続を確実にオフロードし、それらをクリアテキストでバックエンドサーバーに渡すことが可能になる；

  - OCSPステープリングにより、クライアントが証明書ステータスリクエストを要求したときにインラインでOCSPレスポンスを配信することにより、最初のページ読み込み時間がさらに短縮される；

  - 動的レコードサイズ設定により、高パフォーマンスと低レイテンシーの両方が提供され、パケットがまだ飛行中である間にブラウザが新しいオブジェクトの取得を開始できるようにすることにより、ページ読み込み時間が大幅に短縮される；

  - ログ記録、アクセス制御、レポート作成などに、すべての関連するSSL/TLSレイヤー情報への永続的なアクセス。これらの要素はHTTPヘッダーに埋め込まれるか、PROXYプロトコル拡張としても埋め込まれるため、オフロードされたサーバーは、SSL終端を自身で実行した場合に持っていたであろうすべての情報を得る。

  - 脆弱なSSLライブラリでも、OpenSSLの特定のバージョンに影響するHeartbleed攻撃などの特定の既知の攻撃を検出、記録、ブロックする。

  - ステートレスセッション再開（RFC 5077 TLS Ticket拡張）のサポート。TLSチケットはCLIから更新でき、チケットを頻繁にローテーションすることによりPerfect Forward Secrecyを実装する手段を提供する。

#### 3.3.3 基本機能：モニタリング

HAProxyは可用性に多くの焦点を当てている。そのため、サーバーの状態と、他のネットワークコンポーネントに自身の状態を報告することに気を配っている：

  - サーバーの状態は、サーバーごとのパラメータを使用して継続的に監視される。これにより、サーバーへのパスが通常のトラフィックに対して動作可能であることが保証される；

  - ヘルスチェックは、アップとダウンの遷移に対して2つのヒステリシスをサポートして、状態のフラッピングから保護する；

  - チェックは異なるアドレス/ポート/プロトコルに送信できる：これにより、複数のものの代表と見なされる単一のサービスをチェックしやすくなる（例：HTTP+HTTPSサーバーのHTTPSポート）；

  - サーバーは他のサーバーを追跡でき、同時にダウンする：これにより、複数のサービスをホストするサーバーが原子的に失敗でき、部分的に失敗したサーバーに誰も送られないことが保証される；

  - エージェントはサーバーにデプロイされて負荷とヘルスを監視できる：サーバーは、ヘルスチェックが見ることができるものとは独立して、負荷、動作ステータス、管理ステータスを報告することに興味がある可能性がある。サーバー上でシンプルなエージェントを実行することにより、パス全体を検証するヘルスチェックに加えて、サーバー自身のヘルスに関するサーバーの見解を考慮することが可能になる；

  - 様々なチェック方法が利用可能：TCP接続、HTTPリクエスト、SMTP hello、SSL hello、LDAP、SQL、Redis、send/expectスクリプト、すべてSSLあり/なしで；

  - 状態変更はログと統計ページで失敗理由（例：失敗が検出された瞬間に受信されたHTTPレスポンス）と共に通知される。このような変更時に設定可能なアドレスに電子メールも送信できる；

  - サーバーの状態は統計インターフェースでも報告され、トラフィックがファームのサイズやヘルスに応じて異なるファームに送られる可能性があるため、ルーティング決定に使用できる（例：インターDCリンクの損失）；

  - HAProxyはヘルスチェックリクエストを使用してサーバーに情報を渡すことができる。サーバー名、重み、ファーム内の他のサーバーの数などであるため、サーバーはこの知識に基づいてレスポンスと決定を調整できる（例：より多くのCPUを利用可能にするためにバックアップを延期する）；

  - サーバーはヘルスチェックを使用して、オン/オフ以外のより詳細な状態を報告できる（例：停止したい、新しい訪問者を送るのを停止してください）；

  - HAProxy自体は、ルーターや他のロードバランサーなどの外部コンポーネントに自身の状態を報告でき、非常に完全なマルチパスとマルチレイヤーインフラストラクチャを構築できるようにする。

#### 3.3.4 基本機能：高可用性

真面目なロードバランサーと同様に、HAProxyは最良のグローバルサービス継続性を保証するために可用性に多くの気を配っている：

  - 有効なサーバーのみが使用される；他のものはロードバランシングファームから自動的に追放される；特定の条件下では、それらを使用することを強制することも可能であるが；

  - グレースフルシャットダウンのサポートにより、接続に影響を与えることなくサーバーをファームから取り出すことが可能である；

  - アクティブなサーバーがダウンしている場合、バックアップサーバーは自動的に使用され、可能な場合はセッションが失われないようにそれらを置き換える。これにより、同じサーバーに到達する複数のパスを構築することも可能になる（例：複数のインターフェース）；

  - ファーム内のサーバーが多すぎる場合、ファームのグローバル失敗ステータスを返す能力。これは、モニタリング機能と組み合わせることで、アップストリームコンポーネントが特定のサービスの異なるLBノードを選択できるようになる；

  - ステートレス設計によりクラスターの構築が容易になる：設計により、HAProxyは失敗時に失われる可能性のある情報を保存することなく、最高のサービス継続性を保証するために最善を尽くす。これにより、テイクオーバーが可能な限りシームレスになることが保証される；

  - 標準のVRRPデーモンkeepalivedとよく統合される：HAProxyはkeepalivedに自身の状態を簡単に伝え、フローティング仮想IPアドレスに非常にうまく対応する。注意：クラスターベースのソリューション（Heartbeat、...）よりもIP冗長性プロトコル（VRRP/CARP）のみを使用してください。これらが最速、最もシームレス、最も信頼性の高い切り替えを提供するものである。

#### 3.3.5 基本機能：ロードバランシング

HAProxyは、残念ながら他の多くのロードバランシング製品では利用できないロードバランシング機能のかなり完全なセットを提供する：

  - 10個のロードバランシングアルゴリズムがサポートされており、その中には入力データに適用されて無限の可能性リストを提供するものもある。最も一般的なものは、ラウンドロビン（短い接続用、各サーバーを順番に選択）、leastconn（長い接続用、最も低い接続数を持つサーバーの中で最も最近使用されていないものを選択）、source（SSLファームまたはターミナルサーバーファーム用、サーバーはクライアントの送信元アドレスに直接依存）、URI（HTTPキャッシュ用、サーバーはHTTP URIに直接依存）、hdr（サーバーは特定のHTTPヘッダーフィールドの内容に直接依存）、first（短命の仮想マシン用、すべての接続は未使用のものを電源オフできるように、可能な限り小さなサーバーのサブセットにパックされる）；

  - 上記のすべてのアルゴリズムはサーバーごとの重みをサポートするため、ファーム内の異なるサーバー世代に対応したり、特定のサーバーにトラフィックの小さな部分を向けることが可能である（デバッグモード、ソフトウェアの次のバージョンの実行など）；

  - 動的重みはラウンドロビン、leastconn、一貫性ハッシュでサポートされる；これにより、CLIからサーバーの重みを動的に変更でき、さらにはサーバー上で実行されているエージェントによっても変更できる；

  - 動的重みがサポートされる場合は常にスロースタートがサポートされる；これにより、サーバーが徐々にトラフィックを受け取ることができる。これは、ランタイムでクラスをコンパイルする必要がある脆弱なアプリケーションサーバーと、フルスロットルで実行される前に満たされる必要があるコールドキャッシュにとって重要な機能である；

  - ハッシュは、クライアントの送信元アドレス、URLコンポーネント、クエリ文字列要素、ヘッダーフィールド値、POSTパラメータ、RDP Cookieなどの様々な要素に適用できる；

  - 一貫性ハッシュは、ファーム内でサーバーを追加または削除する際の大規模な再配布からサーバーファームを保護する。これは大規模なキャッシュファームで非常に重要であり、コールドキャッシュを再充填するためにスロースタートを使用できるようにする；

  - サーバーごとの接続数、バックエンドごと、バックエンド内で利用可能な接続スロットの量などの多くの内部メトリクスにより、非常に高度なロードバランシング戦略を構築することが可能になる。

#### 3.3.6 基本機能：スティッキネス

アプリケーションロードバランシングはスティッキネスなしでは無用である。HAProxyは、サーバーの追加/削除、ダウン/アップサイクル、さらには複数のロードバランシングノード間の距離に対して耐性があるように設計された方法など、様々なイベントを横切って訪問者を同じサーバーに維持するためのかなり包括的な可能性セットを提供する：

  - スティッキネス情報は、必要に応じて個別にマッチングされ、異なる場所から学習できる。例えば、JSESSIONID CookieはCookieとURLの両方でマッチングされる可能性がある。最大8つの並列ソースを同時に学習でき、それぞれが異なるスティックテーブルを指す可能性がある；

  - スティッキネス情報は、リクエストまたはレスポンス内で見ることができる任意のものから来ることができる。送信元アドレス、TCPペイロードオフセットと長さ、HTTPクエリ文字列要素、ヘッダーフィールド値、Cookieなどが含まれる。

  - スティックテーブルは、マルチマスターファッションで他のすべてのノード間で複製される；

  - SSL-IDやRDP Cookie（TSEファーム用）などの一般的に使用される要素は、操作を容易にするために直接アクセス可能である；

  - すべてのスティッキングルールはACLによって動的に条件付けされる可能性がある；

  - バックアップサーバーなどの特定のサーバーにスティックしないことを決定することも可能であるため、名目上のサーバーが戻ってきたとき、自動的に負荷を取り戻す。これはしばしばマルチパス環境で使用される；

  - HTTPでは、何も学習せず、代わりにスティッキネス専用のCookieを操作することがしばしば好まれる。このために、クライアントが割り当てられたサーバーを覚えているように、そのようなCookieを検出、書き換え、挿入、またはプレフィックスすることが可能である；

  - サーバーは、ログアウト時にスティッキネスCookieを変更またはクリーンすることを決定できるため、訪問者が去ると自動的にサーバーからバインド解除される；

  - ACLベースのルールを使用して、サーバーの状態に関係なく、選択的にスティッキネスを無視または強制することも可能である；高度なヘルスチェックと組み合わせると、管理者がインストールしているサーバーが稼働しており、全世界に提示する前に実行されていることを確認するのに役立つ；

  - Cookieに最大アイドル時間と期間を設定する革新的なメカニズムにより、永続的なストレージに保存することなく、決して閉じられないデバイス（スマートフォン、TV、家電製品）でスティッキネスをスムーズに停止できる；

  - 複数のサーバーエントリは同じスティッキネスキーを共有できるため、1つのパスがダウンした場合、マルチパス環境でスティッキネスが失われない；

  - ソフトストップにより、スティッキネス情報を持つユーザーのみが割り当てられたサーバーに到達し続けるが、新しいユーザーはそこに行かないことが保証される。

#### 3.3.7 基本機能：ログ記録

ログ記録はロードバランサーにとって非常に重要な機能である。第一に、ロードバランサーはしばしばそれが明らかにする問題を引き起こしたと間違って非難されるからであり、第二に、すべての正常と異常な活動を分析し、他のコンポーネントと相関させる必要があるインフラストラクチャの重要なポイントに配置されているからである。

HAProxyは非常に詳細なログを提供し、ミリ秒精度とファイアウォールログで検索できる正確な接続受け入れ時間（例：NAT相関用）を持つ。デフォルトでは、TCPとHTTPログはかなり詳細で、送信元IPアドレスとポート、フロントエンド、バックエンド、サーバー、タイマー（リクエスト受信期間、キュー期間、接続設定時間、レスポンスヘッダー時間、データ転送時間）、グローバルプロセス状態、接続数、キューステータス、リトライ数、詳細なスティッキネスアクションと切断理由、安全な出力エンコーディングを持つヘッダーキャプチャなど、トラブルシューティングに必要なすべてが含まれている。その後、この形式を拡張または置き換えて、任意のサンプリングデータ、変数、キャプチャを含めることが可能になり、非常に詳細な情報が得られる。例えば、クライアントによる累積リクエスト数や訪問された異なるURLの数を記録することが可能である。

ログレベルは標準ACLを使用してリクエストごとに調整できるため、汚染と見なされる一部のログを自動的にサイレントにし、代わりにトラフィックの小さな部分で異常な動作が発生した場合に警告を上げることが可能である（例：送信元アドレスに対する多すぎるURLやHTTPエラー）。管理ログも独自のレベルで出力され、例えばサーバーの損失や回復について通知する。

各フロントエンドとバックエンドは、複数の独立したログ出力を使用でき、これによりマルチテナンシーが容易になる。ログは好ましくはUDP上で送信され、おそらくJSONエンコードされ、配信を保証するために設定可能な行の長さの後に切り詰められる。ただし、stdout/stderrまたは任意のファイル記述子、さらにはクライアントがそれらを取得するために購読できるリングバッファにも送信することも可能である。

#### 3.3.8 基本機能：統計

HAProxyは、認証、セキュリティレベル、スコープを持つWebベースの統計レポートインターフェースを提供する。したがって、各ホストされた顧客に、自身のインスタンスのみを示す独自のページを提供することが可能である。このページは、新しいポートを開く必要がないように、通常のWebサイトの隠されたURL部分に配置できる。このページはまた、他のHAProxyノードの可用性も報告できるため、一目ですべてが期待通りに動作しているかどうかを簡単に確認できる。ビューは総合的で、多くの詳細（エラーの原因、最後のアクセスと最後の変更期間など）にアクセスでき、これらは他のツールがグラフを描画するためにインポートできるCSVテーブルとしてもアクセス可能である。ページは自己更新して、大画面での監視ページとして使用できる。管理モードでは、ページはまた、メンテナンス操作を容易にするためにサーバーの状態を変更することも可能にする。

Prometheusエクスポーターも提供されているため、デプロイメントに応じて統計を異なる形式で消費できる。
### 3.4 標準機能

このセクションでは、HAProxyで非常によく使用されるが、他のロードバランサーには必ずしも存在しない機能を列挙する。

#### 3.4.1 標準機能：情報のサンプリングと変換

HAProxyは、幅広い「サンプルフェッチ関数」セットを使用した情報サンプリングをサポートする。原則は、サンプルとして知られる情報の断片を抽出して、即座に使用することである。これはスティッキネス、条件の構築、ログでの情報の生成、HTTPヘッダーの充実に使用される。

サンプルは様々なソースからフェッチできる：

  - 定数：整数、文字列、IPアドレス、バイナリブロック；

  - プロセス：日付、環境変数、サーバー/フロントエンド/バックエンド/プロセス状態、バイト/接続数/レート、キュー長、乱数ジェネレータ、...；

  - 変数：セッションごと、リクエストごと、レスポンスごとの変数；

  - クライアント接続：送信元と宛先アドレスとポート、およびすべての関連する統計カウンタ；

  - SSLクライアントセッション：プロトコル、バージョン、アルゴリズム、暗号、キーサイズ、セッションID、すべてのクライアントとサーバー証明書フィールド、証明書シリアル、SNI、ALPN、NPN、特定の拡張に対するクライアントサポート；

  - リクエストとレスポンスバッファの内容：オフセット/長さでの任意のペイロード、データ長、RDP Cookie、SSL helloタイプのデコード、TLS SNIのデコード；

  - HTTP（リクエストとレスポンス）：メソッド、URI、パス、クエリ文字列引数、ステータスコード、ヘッダー値、位置ヘッダー値、Cookie、キャプチャ、認証、ボディ要素；

サンプルはその後、変換として知られる多くの演算子を通過して、何らかの変換を経験する可能性がある。変換はサンプルを消費し、完全に異なるタイプの可能性がある新しいサンプルを生成する。例えば、変換は入力文字列の整数長のみを返すために使用されるか、文字列を大文字に変換するために使用される可能性がある。任意の数の変換が、最終使用前にサンプルに連続して適用される可能性がある。利用可能なすべてのサンプル変換の中で、以下のものが最も一般的に使用される：

  - 算術と論理演算子：入力データに対して高度な計算を実行可能にする。比率、パーセンテージの計算、または単純に1つの単位から別の単位への変換など；

  - IPアドレスマスクは、一部のアドレスをより大きなネットワークでグループ化する必要がある場合に有用である；

  - データ表現：URLデコード、base64、hex、JSON文字列、ハッシュ；

  - 文字列変換：固定位置での部分文字列の抽出、固定長、特定の区切り文字の周りの特定のフィールドの抽出、特定の単語の抽出、大文字小文字の変更、正規表現ベースの置換の適用；

  - 日付変換：HTTP日付形式への変換、ローカルからUTCへの変換とその逆、オフセットの追加または削除；

  - スティックテーブルのエントリを検索して統計または割り当てられたサーバーを見つける；

  - ファイルからのマップベースのキーから値への変換（主にジオロケーション用に使用される）。

#### 3.4.2 標準機能：マップ

マップは、起動時に2列のファイルをメモリにロードし、その後各入力サンプルを最初の列から検索し、エントリが見つかった場合は2番目の列の対応するパターンを返すか、見つからなかった場合はデフォルト値を返す変換の強力なタイプである。出力情報もサンプルであるため、他のマップ検索を含む他の変換を順番に経験できる可能性がある。マップは最も一般的に、クライアントのIPアドレスをAS番号または国コードに変換するために使用される。これはネットワークアドレスの最長マッチをサポートするが、様々な他の目的に使用できる。

その強さの一部は、CLIからまたは他のサンプルを使用する特定のアクションから動的に更新できることから来る。これにより、後続のアクセス間で情報を保存および取得できる。もう一つの強さは、バイナリツリーベースのインデックス作成から来る。これにより、数十万のエントリを含む場合でも非常に高速になり、ジオロケーションを非常に安価で簡単に設定できる。

#### 3.4.3 標準機能：ACLと条件

HAProxyのほとんどの操作は条件付きにできる。条件は、論理演算子（AND、OR、NOT）を使用して複数のACLを組み合わせることによって構築される。各ACLは以下の要素に基づく一連のテストである：

  - テストする要素を取得するためのサンプルフェッチメソッド；

  - 要素を変換するためのオプションの一連の変換；

  - マッチングするパターンのリスト；

  - パターンをサンプルと比較する方法を示すマッチングメソッド

例えば、サンプルはHTTP「Host」ヘッダーから取得され、その後小文字に変換され、正規表現マッチングメソッドを使用して多くの正規表現パターンとマッチングされる可能性がある。

技術的には、ACLはマップと同じコア上に構築されており、正確に同じ内部構造、パターンマッチングメソッド、パフォーマンスを共有する。唯一の本当の違いは、サンプルを返す代わりに、「見つかった」または「見つからなかった」のみを返すことである。使用の観点から、ACLパターンは設定ファイル内でインラインで宣言でき、独自のファイルを必要としない。ACLは使用しやすさのために、または設定を理解しやすくするために名前を付けることができる。名前付きACLは複数回宣言でき、1つがマッチするまですべての定義を順番に評価する。

約13の異なるパターンマッチングメソッドが提供されており、その中にはIPアドレスマスク、整数範囲、部分文字列、正規表現が含まれる。これらは関数のように動作し、任意のプログラミング言語と同様に、必要なもののみが評価される。そのため、ORを含む条件が既に真である場合、次のものは評価されず、同様にANDを含む条件が既に偽である場合、条件の残りは評価されない。

宣言されたACLの数に実用的な制限はなく、一般的に使用される少数が提供されている。ただし、経験によると、多くの名前付きACLを使用する設定はトラブルシューティングが非常に困難であり、時にはインラインで匿名ACLを使用する方が、分析されているスコープ外の参照が少なくて済むため、簡単である。

#### 3.4.4 標準機能：コンテンツスイッチング

HAProxyは、コンテンツベーススイッチングとして知られるメカニズムを実装している。原則は、接続またはリクエストがフロントエンドに到着し、その後このリクエストまたは接続と共に運ばれる情報が処理され、この時点で、これらの情報を利用するACLベースの条件を記述して、どのバックエンドがリクエストを処理するかを決定できることである。したがって、トラフィックはリクエストの内容に基づいて1つのバックエンドまたは別のバックエンドに向けられる。最も一般的な例は、Hostヘッダーやパスからの要素（サブディレクトリまたはファイル名拡張子）を使用して、HTTPリクエストが静的オブジェクトまたはアプリケーションをターゲットとしているかどうかを決定し、静的オブジェクトトラフィックを高速で軽量なサーバーで構成されるバックエンドに向け、残りのすべてのトラフィックをより複雑なアプリケーションサーバーに向けることである。これにより、よりグローバルなソリューションとして複数のテクノロジーを共存させるための細かい粒度の仮想ホスティングソリューションが構成される。

コンテンツスイッチングの別のユースケースは、様々な基準に応じて異なるロードバランシングアルゴリズムを使用することである。キャッシュはURIハッシュを使用する可能性があり、アプリケーションはラウンドロビンを使用する可能性がある。

最後に、これにより、複数の顧客がバックエンドごと（したがって顧客ごとの接続制限）を強制することにより、共通リソースの小さな共有を使用できる。

コンテンツスイッチングルールは非常にうまくスケールするが、そのパフォーマンスは使用中のACLの数と複雑さに依存する可能性がある。ただし、サンプル値が直接バックエンド名に変わり、ACLをまったく使用しない動的コンテンツスイッチングルールを記述することも可能である。このような設定は、本番環境で少なくとも30万のバックエンドで正常に動作することが報告されている。

#### 3.4.5 標準機能：スティックテーブル

スティックテーブルは一般的にスティッキネス情報を保存するために使用される。つまり、特定の訪問者が向けられたサーバーへの参照を保持する。キーは訪問者に関連付けられた識別子（その送信元アドレス、接続のSSL ID、HTTPまたはRDP Cookie、URLまたはペイロードから抽出された顧客番号、...）であり、保存された値はサーバーの識別子である。

スティックテーブルは、キーに3つの異なるタイプのサンプルを使用できる：整数、文字列、アドレス。1つのスティックテーブルのみがプロキシで参照でき、プロキシ名でどこでも指定される。最大8つのキーが並行して追跡できる。サーバー識別子は、キーとサーバーの両方が既知になった後、リクエストまたはレスポンス処理中にコミットされる。

スティックテーブルの内容は、アクティブ-アクティブモードで他のHAProxyノード（「ピア」として知られる）と、リロード操作中の新しいプロセスと共に複製できるため、すべてのロードバランシングノードが同じ情報を共有し、クライアントのリクエストが複数のノードに分散されている場合、同じルーティング決定を取る。

スティックテーブルはクライアントを認識することを可能にするものにインデックスされているため、クライアントごとの統計などの追加情報を保存するためにもしばしば使用される。追加の統計は追加のスペースを取り、明示的に宣言される必要がある。保存できる統計のタイプには、入力と出力の帯域幅、同時接続数、期間中の接続レートと数、エラーの量と頻度、特定のタグとカウンタなどが含まれる。特定のサーバーにスティックすることを強制されることなく、そのような情報を保持することをサポートするために、特別な「追跡」機能が実装されており、同時に異なるテーブルから最大3つの同時キーを追跡できる。各保存された統計は検索、ダンプ、CLIからクリアでき、ライブトラブルシューティング機能に追加される。

このメカニズムは、戻ってくる訪問者を優遇したり、良いまたは悪い行動に応じて配信されるサービスの品質を調整したりするために使用できるが、主にサービス悪用とより一般的にDDoSと戦うために使用される。これは、高い処理速度で特定の悪い行動を検出するための複雑なモデルを構築できるようにする。

#### 3.4.6 標準機能：フォーマットされた文字列

HAProxyが文字列を操作する必要がある場所が多くある。ログ、リダイレクト、ヘッダー追加などである。最大の柔軟性を提供するために、フォーマットされた文字列の概念が導入された。当初はログ目的のためであり、これがまだ「log-format」と呼ばれている理由である。これらの文字列には、文字列に様々な動的データ（変数とサンプルフェッチ式を含む）を導入することを可能にするエスケープ文字が含まれており、さらには結果が文字列に変換されている間、エンコーディングを調整することも可能である（例：引用符を追加する）。これにより、ヘッダー内容を構築し、レスポンスデータまたはレスポンステンプレートを構築し、またはログ行をカスタマイズするための強力な方法が提供される。さらに、最も一般的な文字列を構築することを簡単にするために、ログで一般的に使用される情報の約50の特別なタグがショートカットとして提供される。

#### 3.4.7 標準機能：HTTP書き換えとリダイレクト

ロードバランサーを、これのために設計されていないアプリケーションの前面にインストールすることは、適切なツールなしでは困難なタスクである可能性がある。この場合最も一般的に要求される操作の1つは、ロードバランサーがオリジンサーバーとして表示され、ハードコードされた情報を修正するために、リクエストとレスポンスヘッダーを調整することである。これには、リクエスト内のパスの変更（強く推奨されない）、Hostヘッダーフィールドの変更、リダイレクト用のLocationレスポンスヘッダーフィールドの変更、Cookieのパスとドメイン属性の変更などが含まれる。また、多くのサーバーがやや冗長で、レスポンスで多すぎる情報を漏らす傾向があり、それらを標的攻撃に対してより脆弱にする。理論的にはロードバランサーの役割ではないが、実際には、すべてがクリーンアップされることを保証するために、インフラストラクチャの最良の場所に配置されている。

同様に、時々ロードバランサーは一部のリクエストをインターセプトし、新しいターゲットURLへのリダイレクトでレスポンスする必要がある。一部の人々はリダイレクトと書き換えを混同する傾向があるが、これらは2つの完全に異なる概念である。書き換えはクライアントとサーバーに異なるものを見させ（訪問されているページの場所について意見が一致しない）、リダイレクトはクライアントに新しいURLを訪問するように求めるため、サーバーと同じ場所を見る。

これを行うために、HAProxyは書き換えとリダイレクトのための様々な可能性をサポートする：

  - リクエストとレスポンスでの正規表現ベースのURLとヘッダー書き換え。正規表現は操作しやすく、よく理解されているため、ヘッダー値を変更するために最も一般的に使用されるツールである；

  - ヘッダーはまた、フォーマットされた文字列に基づいて追加、削除、または置換できるため、そこに情報を渡すことが可能である（例：クライアント側TLSアルゴリズムと暗号）；

  - HTTPリダイレクトは、相対、絶対、または完全に動的（フォーマットされた文字列）URIに対して任意の3xxコードを使用できる；

  - HTTPリダイレクトはまた、特定のCookieの設定またはクリア、クエリ文字列の削除、不足している場合のスラッシュの追加などの追加オプションもサポートする；

  - 強力な「return」ディレクティブにより、動的コンテンツまたはテンプレートファイルを使用して、ステータス、ヘッダー、ボディなど、レスポンスのすべての部分をカスタマイズできる。

  - すべての操作はACLベースの条件をサポートする；

#### 3.4.8 標準機能：サーバー保護

HAProxyはサービス可用性を最大化するために多くのことを行い、このためにサーバーを過負荷と攻撃から保護するために多大な努力を払っている。最初で最も重要なポイントは、完全で有効なリクエストのみがサーバーに転送されることである。最初の理由は、HAProxyがバイトストリームと同期を保つために必要なプロトコル要素を見つける必要があること、2番目の理由は、リクエストが完全になるまで、一部の要素がそのセマンティクスを変更するかどうかを知る方法がないことである。これからの直接的な利点は、サーバーが無効または不完全なリクエストにさらされないことである。これはslowloris攻撃に対する非常に効果的な保護であり、HAProxyにはほとんど影響しない。

もう一つの重要なポイントは、HAProxyがリクエストとレスポンスを保存するバッファを含み、リクエストが完全な場合のみサーバーに送信し、ローカルネットワークからレスポンス全体を非常に迅速に読み取ることにより、サーバー側接続が非常に短時間使用され、これによりサーバーリソースが可能な限り保存されることである。

これへの直接的な拡張は、HAProxyがサーバーへの同時接続数または未処理リクエスト数を人為的に制限できることである。これにより、トラフィックスパイク中に継続的に100%の容量で実行されている場合でも、サーバーが過負荷になることは決してないことが保証される。すべての過剰なリクエストは単純にキューに入れられ、1つのスロットが解放されたときに処理される。最終的に、この大きなリソース節約は、ほとんどの場合、サーバーを過負荷にすることよりも実際に高速になるほど、サーバーレスポンス時間を大幅に改善することを保証する。キューに入れられたリクエストは他のサーバーに再ディスパッチされるか、クライアントが中止した場合にキューで中止される可能性があり、これによりサーバーは「リロード効果」からも保護される。遅く読み込まれるページ上の訪問者による「リロード」の各クリックは通常新しいリクエストを引き起こし、サーバーを過負荷状態に維持する。

スロースタートメカニズムはまた、再起動中のサーバーが起動を完了しているか、一部のクラスをコンパイルしている間の高トラフィックレベルから保護する。

プロトコルレベルの保護に関して、HTTPパーサーを緩和して、標準に準拠していないが無害なリクエストまたはレスポンスを受け入れ、さらには修正することも可能である。これにより、修正が開発されている間、不正なアプリケーションにアクセスできる。並行して、問題のあるメッセージは完全にキャプチャされ、開発者がアプリケーションの問題を特定するのに役立つ詳細なレポートが提供される。最も危険なプロトコル違反は適切に検出され、対処され、修正される。例えば、2つのContent-lengthヘッダーを持つ不正なリクエストまたはレスポンスは、値が正確に同じ場合は修正され、異なる場合は拒否される。これはセキュリティ問題になるためである。プロトコル検査はHTTPに限定されず、TLSやRDPなどの他のプロトコルでも利用可能である。

プロトコル違反または攻撃が検出された場合、ユーザーにレスポンスするための様々なオプションがある。一般的な「HTTP 400 bad request」を返す、TCPリセットで接続を閉じる、または攻撃者を混乱させるために長い遅延（「tarpit」）の後にエラーを偽装するなどである。これらすべてが、攻撃を維持することが非常に高価になる攻撃者を落胆させることにより、サーバーを保護することに貢献する。

HAProxyはまた、偶発的なデータ漏洩とセッション交差から保護するためのより高度なオプションを提案する。疑わしいサーバーレスポンスを記録できるだけでなく、特定の訪問者の機密性に影響を与える可能性があるレスポンスを記録し、オプションでブロックすることもできる。そのような例の1つは、キャッシュ可能なレスポンスに現れるキャッシュ可能なCookieであり、これにより中間キャッシュがそれを別の訪問者に配信し、偶発的なセッション共有を引き起こす可能性がある。
### 3.5 高度な機能

#### 3.5.1 高度な機能：管理

HAProxyは、通常の本番環境で非常に安定し、安全に管理できるように設計されている。インストールプロセスを必要としない単一の実行可能ファイルとして提供される。複数のバージョンが簡単に共存でき、重要度の順にインスタンスを段階的にアップグレードすることが可能（そして推奨される）であり、一度にすべてを移行する必要がないことを意味する。設定ファイルは簡単にバージョン管理される。設定チェックはオフラインで行われるため、失敗する可能性があるサービスを再起動する必要がない。設定チェック中、多くの高度な間違いが検出される可能性がある（例：別のものを隠すルール、または動作しないスティッキネス）が、詳細な警告と設定ヒントが修正のために提案される。設定ファイルの後方互換性は非常に長い時間にわたって続き、バージョン1.5は13年前に書かれたバージョン1.1の設定を完全にサポートし、1.6は異なる方法で実行できる、ほとんど使用されていない、古いキーワードのサポートのみを削除する。設定とソフトウェアアップグレードメカニズムは、古いプロセスと新しいプロセスがシステム上で共存し、それぞれが独自の接続を処理できるため、スムーズで破壊的でない。システムステータス、ビルドオプション、ライブラリ互換性は起動時に報告される。

一部の高度な機能により、アプリケーション管理者はサーバーをスムーズに停止し、その上でアクティビティがなくなったことを検出し、その後オフラインにし、停止し、アップグレードし、アップグレード中にトラフィックを受け取らないことを保証し、その後パブリックに開くことなく通常のパスを通じて再度テストできる。これらすべてをHAProxyに触れることなく行える。これにより、複雑な本番操作でさえ、技術的リソースが利用可能な営業時間中に行えることが保証される。

プロセスは可能な限りリソースを節約しようとし、メモリプールを使用して割り当て時間を節約し、メモリフラグメンテーションを制限し、ペイロードバッファの内容が送信されるとすぐに解放し、強力なメモリ制限を強制することをサポートする。これにより、接続はより多くのメモリを割り当てる代わりに、バッファが利用可能になるまで待機する必要がある。このシステムは、特定の厳格な環境でのメモリ使用量を保証するのに役立つ。

コマンドラインインターフェース（CLI）は、多くの操作を実行し、トラブルシューティング情報を取得するために、UNIXまたはTCPソケットとして利用可能である。このソケットで行われるすべては設定変更を必要としないため、主に一時的な変更に使用される。このインターフェースを使用して、サーバーのアドレス、重み、ステータスを変更し、統計を参照してカウンタをクリアし、スティッキネステーブルをダンプしてクリアし、可能性としてキー基準で選択的に、クライアント側とサーバー側の接続をダンプしてキルし、エラーの正確な原因と場所の詳細な分析と共にキャプチャされたエラーをダンプし、ACLとマップからエントリをダンプ、追加、削除し、TLS共有シークレットを更新し、接続制限とレート制限を任意のフロントエンドに動的に適用し（共有ホスティング環境で有用）、特定のフロントエンドを無効にしてリスニングポートを解放できる（営業時間中の操作が禁止されており、それでも修正が必要な場合に有用）。証明書とその設定の動的な更新も許可され、さらにトラフィックの各処理ステップのトレースの有効化と参照も許可される。

SNMPが必須の環境では、少なくとも2つのエージェントが存在する。1つはHAProxyソースと共に提供され、Net-SNMP Perlモジュールに依存する。もう1つは商用パッケージと共に提供され、Perlを必要としない。両方ともカバレッジの観点からほぼ同等である。

HAProxyがデプロイされているマシンに4つのユーティリティをインストールすることがしばしば推奨される：

  - socat（CLIに接続するために、ただしnetcatの特定のフォークもある程度は実行できる）；

  - 最新のHAProxyバージョンからのhalog：これはログ解析ツールであり、ネイティブTCPとHTTPログを非常に高速に解析し（1秒あたり1〜2 GB）、URLごと、送信元アドレスごとのリクエスト、レスポンス時間またはエラー率でソートされたURL、終了コードなどの有用な情報と統計を抽出する。本番サーバーにデプロイされてライブの問題のトラブルシューティングを支援するように設計されているため、使用する準備ができている必要がある；

  - tcpdump：ログで明らかになった問題をトラブルシューティングするために必要なネットワークトレースを取得するために強く推奨される。アプリケーションとhaproxyの分析が分岐する瞬間があり、ネットワークトレースは誰が正しく、誰が間違っているかを言う唯一の方法である。tcpdumpのおかげでネットワークスタックとハイパーバイザーのバグを検出することも非常に一般的である；

  - strace：tcpdumpの仲間である。HAProxyが本当に見ているものを報告し、オペレーティングシステムが責任を負う問題とHAProxyが責任を負う問題を分類するのに役立つ。HAProxyのバグが疑われる場合、straceがしばしば要求される；

#### 3.5.2 高度な機能：システム固有の機能

HAProxyがデプロイされるオペレーティングシステムに応じて、特定の追加機能が利用可能または必要になる可能性がある。多くのプラットフォームでサポートされているが、HAProxyは主にLinuxで開発されているため、一部の機能がこのプラットフォームでのみ利用可能である理由を説明する。

透過的なバインドと接続機能、接続を特定のネットワークインターフェースにバインドするサポート、および複数のプロセスを同じIPアドレスとポートにバインドする機能は、LinuxとBSDシステムでのみ利用可能である。ただし、Linuxのみが利用可能なプロセス間で着信リクエストのカーネル側ロードバランシングを実行する。

Linuxでは、HAProxyをすべてのコンテナ間のゲートウェイにすることを可能にするネットワーク名前空間（「コンテナ」としても知られる）のサポート、クライアント側接続でMSS、Netfilterマーク、IP TOSフィールドを設定する機能、リスニング側でのTCP FastOpenのサポート、カーネルが設定されたタイムアウト前にクライアントが消えたことを検出したときに接続を迅速にキルするためのTCPユーザータイムアウト、カーネルが接続の両側間でデータを転送して複数のメモリコピーを回避するためのTCPスプライシング、着信接続の通知をカーネルバッファでデータが利用可能になった場合のみ取得するための「defer-accept」バインドオプションを有効にする機能、接続を確認するACKでリクエストを送信する機能（「piggy-back」と呼ばれることもある）が「tcp-smart-connect」オプションで有効になる。Linuxでは、HAProxyはまた、ネットワーク上で可能な限り多くのパケットを節約するためにTCP遅延ACKを操作することに多大な注意を払う。

一部のシステムには、過去と未来に前後にジャンプする信頼できない時計がある。これは、複数のプロセッサが正確に同じ時刻を見ない一部のNUMAシステムで発生し、最近では仮想化環境でより一般的になった。仮想時計が実際の時計と関係がないため、巨大な時間ジャンプが発生する（時には最大30秒が観察されている）。これは一般的にタイムアウト強制に関して多くの問題を引き起こす。これらのシステムのこの欠陥により、HAProxyは自身の単調時計を維持する。これはシステムの時計に基づいているが、ドリフトが測定され、補償される。これにより、非常に悪いシステム時計でも、タイマーが合理的に正確に保たれ、タイムアウトが動作し続けることが保証される。この問題はそのようなシステム上で実行されているすべてのソフトウェアに影響し、HAProxyに特有ではないことに注意してください。一般的な影響は、偽のタイムアウトまたはアプリケーションのフリーズである。したがって、システムでこの動作が検出された場合、HAProxyがそれに対して自身を保護するという事実に関係なく、修正する必要がある。

Linuxでは、新しい開始プロセスは前のプロセスと通信して、リスニングファイル記述子を再利用できるため、プロセスの置換中にリスニングソケットが中断されることはない。

#### 3.5.3 高度な機能：スクリプティング

HAProxyは、Lua埋め込み言語のサポートでビルドできる。これにより、リクエストまたはレスポンスの複雑な操作、ルーティング決定、統計処理などに関連する新しい可能性の広い領域が開かれる。Luaを使用して、他のサーバーとの並列接続を確立して情報を交換することも可能である。この方法で、例えば認証システムを開発することが可能になる（ただし複雑である）。Luaの使用方法の詳細については、「doc/lua-api/index.rst」ファイルのドキュメントを参照してください。

#### 3.5.4 高度な機能：トレーシング

任意の瞬間に管理者はCLIを介して接続し、様々な内部サブシステムでトレーシングを有効にできる。詳細の様々なレベルがデフォルトで提供されるため、実際には、リクエストごとに1行からリクエストごとに500行までの任意のものを取得できる。フィルターと自動キャプチャオン/オフ/一時停止メカニズムも利用可能であるため、特定のイベントを待ち、詳細に観察することが本当に可能である。これは、故障したサーバーとクライアントからのプロトコル違反、またはサービス拒否攻撃を診断するのに非常に便利である。
### 3.6 サイジング

典型的なCPU使用率の数値では、TCPまたはHTTP closeモードでHAProxyが15%、カーネルが85%の処理時間を費やし、HTTP keep-aliveモードではHAProxyが約30%、カーネルが70%を費やす。これは、オペレーティングシステムとその調整がグローバルパフォーマンスに強い影響を与えることを意味する。

使用法はユーザー間で大きく異なり、一部は帯域幅に焦点を当て、他のものはリクエストレートに焦点を当て、他のものは接続同時実行性に焦点を当て、他のものはSSLパフォーマンスに焦点を当てる。このセクションは、このタスクを支援するためのいくつかの要素を提供することを目的としている。

すべての操作にはコストが伴うことを心に留めておくことが重要であるため、各個別の操作は他の操作の上にオーバーヘッドを追加する。これは特定の状況では無視できる可能性があり、他の場合では支配的になる可能性がある。

接続からのリクエストを処理する際、以下のことが言える：

  - データの転送は、リクエストまたはレスポンスヘッダーの解析よりもコストが低い；

  - リクエストまたはレスポンスヘッダーの解析は、サーバーへの接続の確立とその後閉じることよりもコストが低い；

  - 接続の確立と閉じることは、TLS再開操作よりもコストが低い；

  - TLS再開操作は、キー計算を伴う完全なTLSハンドシェイクよりもコストが低い；

  - アイドル接続は、バッファがデータを保持している接続よりもCPUコストが低い；

  - TLSコンテキストは、データを持つ接続よりもさらに多くのメモリコストがかかる；

したがって実際には、ペイロードバイトの処理はヘッダーバイトの処理よりも安価である。したがって、小さなオブジェクト（ボリューム単位あたり多くのリクエスト）よりも大きなオブジェクト（ボリューム単位あたり少数のリクエスト）で高ネットワーク帯域幅を達成しやすい。これが、最大帯域幅が常に大きなオブジェクトで測定され、リクエストレートまたは接続レートが小さなオブジェクトで測定される理由である。

一部の操作は複数のCPUに分散された複数のプロセスでうまくスケールし、他のものはそれほどうまくスケールしない。ネットワーク帯域幅は、大きなオブジェクトではCPUがめったにボトルネックにならないため、非常に遠くまでスケールしない。主にネットワーク帯域幅とネットワークインターフェースに到達するためのデータバスである。接続レートは、ローカルポートテーブルを処理する際のシステム内のいくつかのロックにより、複数のプロセッサ上でうまくスケールしない。永続的接続上のリクエストレートは、多くのメモリやネットワーク帯域幅を必要とせず、ロックされた構造にアクセスする必要がないため、非常にうまくスケールする。TLSキー計算は完全にCPUバウンドであるため、非常にうまくスケールする。TLS再開は適度にうまくスケールするが、共有テーブルへのアクセスのオーバーヘッドが期待される小さな利得を相殺する約4プロセスでその限界に達する。

非常にうまく調整されたシステムから期待できるパフォーマンス数値は以下の範囲内である。これらを数量のオーダーとして取り、プロセッサ、IRQ設定、メモリタイプ、ネットワークインターフェースタイプ、オペレーティングシステム調整などに基づいて、任意の方向で重要な変動を期待することが重要である。

以下の数値は、3.7 GHzで動作するCore i7で見つかった。デュアルポート10 Gbps NICを装備し、Linuxカーネル3.10、HAProxy 1.6、OpenSSL 1.0.2で動作している。HAProxyは単一の専用CPUコア上の単一プロセスとして実行され、2つの追加コアがネットワーク割り込みに専用されていた：

  - 256 kB以上のオブジェクトで最大20 Gbpsのクリアテキストネットワーク帯域幅、41kB以上で10 Gbps；

  - 大きなオブジェクトでAES256-GCM暗号を使用したTLSトラフィックの4.6 Gbps；

  - クライアントからサーバーへの1秒あたり83000のTCP接続；

  - クライアントからサーバーへの1秒あたり82000のHTTP接続；

  - サーバークローズモード（クライアントとのkeep-alive、サーバーとのclose）での1秒あたり97000のHTTPリクエスト；

  - エンドツーエンドkeep-aliveモードでの1秒あたり243000のHTTPリクエスト；

  - 1秒あたり300000のフィルタリングされたTCP接続（anti-DDoS）

  - 永続的TLS接続上のkeep-aliveモードでの1秒あたり160000のHTTPSリクエスト；

  - TLS再開接続を使用した1秒あたり13100のHTTPSリクエスト；

  - RSA2048で再ネゴシエーションされたTLS接続を使用した1秒あたり1300のHTTPS接続；

  - システムバッファに必要なメモリを含むRAMのGBあたり20000の同時飽和接続；注意深い調整でより良い結果を得ることが可能であるが、この結果は簡単に達成できる；

  - システムバッファに必要なメモリを含むRAMのGBあたり約8000の同時TLS接続（クライアント側のみ）；

  - システムバッファに必要なメモリを含むRAMのGBあたり約5000のエンドツーエンドTLS接続（両側）；

AWSの64コアARM Graviton2プロセッサでのマルチスレッド有効HAProxy 2.4のより最近のベンチマークは、サブミリ秒レスポンス時間で1秒あたり200万のHTTPSリクエストと100 Gbpsのトラフィックに達した：

https://www.haproxy.com/blog/haproxy-forwards-over-2-million-http-requests-per-second-on-a-single-aws-arm-instance/

したがって、心に留めておくべき良い経験則は、リクエストレートがTLS keep-aliveとTLS再開の間で10で除算され、TLS再開とTLS再ネゴシエーションの間で10で除算されることである。一方、HTTP keep-aliveとHTTP closeの間では3でのみ除算される。もう一つの良い経験則は、AES命令を持つ高周波コアがコアあたり約20 GbpsのAES-GCMを実行できることを覚えておくことである。

もう一つの良い経験則は、同じサーバー上で、HAProxyが以下を飽和させることができると考えることである：

  - 約5-10の静的ファイルサーバーまたはキャッシュプロキシ；

  - 約100のアンチウイルスプロキシ；

  - 使用中のテクノロジーに応じて約100-1000のアプリケーションサーバー。
### 3.7 HAProxyの入手方法

HAProxyは、GPLv2ライセンスでカバーされたオープンソースプロジェクトである。これは、ソースへのアクセスも要求に応じて提供される限り、誰もが再配布できることを意味する。特に何らかの修正が行われた場合。

HAProxyは「master」または「mainline」と呼ばれるメイン開発ブランチとして進化し、コードが安定していると見なされると、そこから新しいブランチが派生する。多くのWebサイトが、プロジェクトに参加するため、またはブリーディングエッジ機能が必要なため、本番環境で一部の開発ブランチを自発的に実行している。そのフィードバックは、バグを修正し、開発されているバージョンの全体的な品質と安定性を判断するために非常に貴重である。

コードが十分に安定しているときに作成される新しいブランチは安定バージョンを構成し、一般的に数年維持されるため、最新でなくても、新しいブランチに移行する緊急事態はない。安定ブランチが発行されると、バグ修正のみを受け取る可能性があり、ユーザーの生活を楽にする場合にのみ、非常にまれにマイナー機能更新を受け取る可能性がある。安定ブランチに入るすべての修正は必然的にマスターブランチから来る。これにより、アップグレード後に修正が失われることはないことが保証される。この理由により、バグを修正する場合は、安定ブランチではなくマスターブランチに対してパッチを作成してください。既に修正されていることを発見する可能性もある。このプロセスはまた、安定ブランチでの回帰が非常にまれであることを保証するため、現在のブランチの最新バージョンにアップグレードしない言い訳は決してない。

ブランチは「1.6」などのドットで区切られた2桁の数字で番号付けされる。1.9以降、2番目の数字が奇数のブランチは主に敏感な技術的更新に焦点を当て、より高度なユーザーを対象としている。これらは他のものよりも多くのバグを引き起こす可能性があるためである。これらは約1年間のみ維持され、緊急時にロールバックできない場所にデプロイしてはならない。完全なバージョンには、修正のレベルを示す1つまたは2つのサブバージョン番号が含まれる。例えば、バージョン1.5.14は、バージョン1.5.0が発行された後、ブランチ1.5の14番目の修正リリースである。個別のバグに対する126の修正、ドキュメントの24の更新、および前述の126のバグを修正するために必要だった75の他のバックポートされたパッチが含まれている。既存の機能は、同じブランチ内のアップグレードが常に無害であることを保証するために、安定ブランチで修正または削除されることは決してない。

HAProxyは、異なるリリースリズムで複数のソースから利用可能である：

  - 公式コミュニティWebサイト： http://www.haproxy.org/ ：このサイトは最新の開発リリース、すべての安定リリース、および各ブランチのナイトリースナップショットのソースを提供する。リリースサイクルは速くなく、安定リリース間、または開発スナップショット間で数ヶ月である。非常に古いバージョンもまだそこでサポートされている。すべてがソースのみとして提供されるため、そこから来るものは再構築または再パッケージ化する必要がある；

  - GitHub： https://github.com/haproxy/haproxy/ ：これは開発ブランチのみのミラーであり、問題トラッカー、継続的インテグレーション、コードカバレッジツールとの統合を提供する。これは貢献者のみのためである；

  - LinuxディストリビューションやBSDポートなどの多くのオペレーティングシステム。これらのシステムは一般的に長期的に維持されたバージョンを提供する。これらは公式のものからのすべての修正を常に含むわけではないが、少なくとも重要な修正を含む。これは、高度な設定を求めず、更新を簡単に保ちたいだけのほとんどのユーザーにとってしばしば良いオプションである；

  - http://www.haproxy.com/ からの商用バージョン：これらは、様々なオペレーティングシステム用に構築された、またはアプライアンスとして提供される、サポートされたプロフェッショナルパッケージである。最新の安定バージョンに基づいており、強い需要がある次のリリースからの多くの機能がバックポートされている。最新の機能を安定ブランチの信頼性と共に求めるユーザー、バグ修正への最速のレスポンス時間、または単にオープンソース製品の上にサポート契約を求めるユーザーにとって最良のオプションである。

使用しているバージョンがブランチ内の最新であることを保証するために、以下の方法で進める必要がある：

  - 実行しているHAProxy実行可能ファイルを確認する：一部のシステムはデフォルトで出荷し、管理者はシステム上の別の場所にバージョンをインストールするため、起動スクリプトでどれが使用されているかを確認することが重要である；

  - HAProxyバージョンがどのソースから来るかを決定する。このために、一般的に「haproxy -v」と入力するだけで十分である。開発バージョンは、ブランチ番号の後に「dev」という単語があるこのように表示される：

      HAProxy version 2.4-dev18-a5357c-137 2021/05/09 - https://haproxy.org/

    安定バージョンは、オペレーティングシステムベンダーによって提供される未修正の安定バージョンと同様に、このように表示される：

      HAProxy version 1.5.14 2015/07/02

    安定バージョンのナイトリースナップショットは、バージョンの後に16進数シーケンスがあり、リリースの日付ではなくスナップショットの日付があるこのように表示される：

      HAProxy version 1.5.14-e4766ba 2015/07/29

    他の形式は、独自のパッチセットを持つシステム固有のパッケージを示す可能性がある。例えば、HAProxy Enterpriseバージョンは以下の形式（&lt;branch&gt;-&lt;latest commit&gt;-&lt;revision&gt;）で表示される：

      HAProxy version 1.5.0-994126-357 2015/07/02

    歴史的に2.4より前のバージョンは、プロセス名を「HA」と「Proxy」の間にハイフンで報告していたことに注意してください。上記のものは正しい形式のみを示すように調整されたため、この単語を無視するか、スクリプトで緩いマッチを使用する方が良い。さらに、現代のバージョンはプロジェクトのホームへのリンクを追加する。

    最後に、2.1以降のバージョンには「Status」行が含まれ、バージョンが本番環境で安全かどうか、もしそうであればいつまでか、およびこのバージョンに影響する既知のバグのリストへのリンクが示される。

  - システム固有のパッケージについては、システムがまだサポートされており、ブランチの修正がまだ提供されていることを保証するために、ベンダーのパッケージリポジトリまたは更新システムをチェックする必要がある。haproxy.orgからのコミュニティバージョンについては、サイトを訪問し、ブランチのステータスを確認し、最新バージョンとあなたのものを比較して、最新であるかどうかを確認してください。そうでない場合はアップグレードできます。ブランチが維持されていない場合、あなたは確実に非常に遅れており、より最近のブランチへのアップグレードを考慮する必要がある（そうする際はREADMEを注意深く読んでください）。

HAProxyは、それが来たソースに従って更新する必要がある。通常、システムベンダーのパッケージをアップグレードする方法に従う。ソースから取得された場合は、ソースを抽出した後、ソースディレクトリのREADMEファイルを読み、オペレーティングシステムの指示に従ってください。
## 4. コンパニオン製品と代替製品

HAProxyは以下に記載されている特定の製品とかなり良く統合されるため、HAProxyと直接関連していなくても、ここで言及されている。
### 4.1 Apache HTTPサーバー

Apacheは事実上の標準HTTPサーバーである。ファイル配信と動的コンテンツの両方をサポートする、非常に完全でモジュラーなプロジェクトである。一部のアプリケーションサーバーのフロントエンドとして機能できる。リクエストのプロキシ処理やレスポンスのキャッシュも可能である。これらの使用例すべてにおいて、フロントロードバランサーが一般的に必要とされる。

Apacheは様々なモードで動作でき、一部は他よりも重い。特定のモジュールは依然として重いpre-forkedモデルを必要とし、多数の接続でのApacheのスケーリングを妨げる。この場合、HAProxyはサーバーごとの接続制限を安全な値に強制することで、大きな助けを提供でき、サーバーの速度を大幅に向上させ、アプリケーションにより良く使用されるリソースを保護する。

Apacheは「mod_rpaf」拡張機能を使用してX-Forwarded-Forヘッダーからクライアントのアドレスを抽出できる。HAProxyは設定で「option forwardfor」が指定されている場合、このヘッダーを自動的に提供する。HAProxyはまた、インターネットに公開されているApacheに対して、幅広い種類のDoS攻撃により良く耐えることができるため、素晴らしい保護を提供できる。
### 4.2 NGINX

NGINXは2番目の事実上の標準HTTPサーバーである。Apacheと同様に、幅広い機能をカバーしている。NGINXはHAProxyと同様のモデルで構築されているため、数万の同時接続を処理するのに問題がない。一部のアプリケーション（例：含まれているPHP FPMを使用）へのゲートウェイとして使用される場合、PHPアプリケーションの負荷を軽減するためにフロントエンド接続制限を設定することがしばしば有益である。HAProxyは明らかに、通常のロードバランサーとして、またPHPを混雑から解放して高速化するトラフィック調整器として、そこで有用である。

また、両方の製品はイベント駆動アーキテクチャのおかげでCPUを非常に少なく使用するため、両方を同じシステムにインストールすることはしばしば容易である。NGINXはHAProxyのPROXYプロトコルを実装しているため、HAProxyがクライアントの接続情報をNGINXに渡して、アプリケーションが関連するすべての情報を取得できることは容易である。

一部のベンチマークでは、大きな静的ファイル配信において、NGINXの前面でHAProxyに一貫性のあるハッシュを実装することで、OSのキャッシュヒット率を最適化することで有益であることが示されている。これは基本的にサーバーノード数で乗算される。
### 4.3 Varnish

Varnishはスマートなキャッシュリバースプロキシで、おそらくWebアプリケーションアクセラレーターとして最もよく説明される。VarnishはSSL/TLSを実装せず、そのCPUサイクルすべてを最も得意とするものに専念したいと考えている。Varnishはまた、HAProxyのPROXYプロトコルを実装しているため、HAProxyはVarnishの前面にSSLオフローダーとして、またロードバランサーとして非常に簡単にデプロイでき、関連するすべてのクライアント情報を渡すことができる。

また、Varnishは自然に、サーバーが圧縮されたオブジェクトを提供したが圧縮しない場合のキャッシュからの解凍をサポートしている。HAProxyはその後、バックエンドサーバーが圧縮を実装していない場合の発信データを圧縮するために使用できるが、トラフィックが低くない限り、ロードバランサーで圧縮することはめったに良いアイデアではない。

複数のノードにわたる大きなキャッシュファームを構築する際、HAProxyは一貫性のあるURLハッシュを使用して、負荷をキャッシュノードにインテリジェントに分散し、キャッシュの重複を避けることができる。これにより、すべてのキャッシュノードの合計である総キャッシュサイズが得られる。

さらに、HAProxyで非常に小さな単純なオブジェクトを短時間キャッシュすることで、ネットワークラウンドトリップを節約し、HAProxyとVarnishノードの両方のCPU負荷を軽減できる場合がある。これは、Varnishでこれらのオブジェクトに対して処理が行われない場合にのみ可能である（これはしばしば「faviconキャッシュ」の概念として言及され、これにより、下流の無用なリクエストのかなりの割合を時々避けることができる）。

しかし、他のキャッシュの前面でHAProxyキャッシュを長時間（数秒以上）有効にしないでください。それは、本当に重要な節約を提供することなく、トラブルシューティングを大幅に複雑にする。
### 4.4 代替製品

Linux Virtual Server（LVSまたはIPVS）は、Linuxカーネル内に含まれるレイヤー4ロードバランサーである。パケットレベルで動作し、TCPとUDPを処理する。ほとんどの場合、レイヤー7の知識がまったくないため、代替というよりも補完である。

Poundは別のよく知られたロードバランサーである。HAProxyよりもはるかにシンプルで、機能もはるかに少ないが、多くの非常に基本的なセットアップでは両方を使用できる。その作者は常にコードの監査可能性を第一に重視し、機能セットを低く保ちたいと考えている。そのスレッドベースのアーキテクチャは高接続数でのスケーリングが劣るが、良い製品である。

Penはかなり軽量なロードバランサーである。SSLをサポートし、クライアントのIPアドレスの固定サイズテーブルを使用して永続性を維持する。パケット指向モードをサポートし、直接サーバーリターンとUDPをある程度サポートできる。小さな負荷を対象としている（永続性テーブルは2048エントリしかない）。

NGINXはある程度のロードバランシングを行うことができるが、明らかにその主要な機能ではない。本番トラフィックはサーバー障害の検出に使用され、ロードバランシングアルゴリズムはより制限的で、スティッキネスは非常に制限的である。しかし、既に存在している一部のシンプルなデプロイメントシナリオでは意味がある。良い点は、HAProxyと非常に良く統合されるため、その制限に達した後にHAProxyを追加することに問題がないことである。

Varnishはまた、そのバックエンドサーバーの一部のロードバランシングを行い、実際のヘルスチェックをサポートする。しかし、スティッキネスを実装していないため、NGINXと同様に、スティッキネスが必要ない限り、開始するには十分である。同様に、HAProxyとVarnishが非常に良く統合されるため、機能セットを補完するために後でミックスに追加することは容易である。
## 5. 連絡先

開発者やコミュニティメンバーに何かについて連絡したい場合、通常最良の方法はメーリングリストにメッセージをhaproxy@formilux.orgに送信することである。このリストは公開されており、そのアーカイブも公開されているため、機密情報の開示は避けるべきであることに注意してください。様々な経験レベルの数千人のユーザーがそこに存在し、最も複雑な質問でさえ通常比較的迅速に最適な回答を見つける。

提案も歓迎される。電子メールに困難を感じているユーザーには、http://discourse.haproxy.org/ でDiscourseプラットフォームが利用可能である。しかし、そこでは質問を読む人が少なく、ほとんどが本当に小さなチームによって処理されていることに注意してください。いずれにせよ、他の人を助けるために空き時間を捧げている人々に対して忍耐強く、敬意を持って接してください。

バグを見つけたと思われるが確信がない場合、メーリングリストで報告するのが最適である。バグを見つけたと確信があり、バージョンがそのブランチで最新であり、既にGitHubアカウントを持っている場合、https://github.com/haproxy/haproxy/ に直接行き、利用可能なすべての詳細とともに問題を報告してください。これも公開されているため、後で後悔する可能性のある情報を投稿しないように注意してください。問題トラッカーは非常に長いスレッドとして表示されるため、非常に長いダンプ（数百行以上）を貼り付けることは避け、代わりに添付してください。

多くのユーザーが公開の場で議論された場合に深刻な問題に陥る可能性がある重要なセキュリティ問題と確実に考えられるものを見つけた場合、再現手順とともにsecurity@haproxy.orgに送信できる。信頼できる開発者の小さなチームがそれを受け取り、修正を提案できる。通常、エンバーゴは使用せず、修正が利用可能になるとすぐにマージされる。まれな状況では、ソフトウェアベンダーとリリースが調整されることがある。このプロセスは通常、誰もがの作業を混乱させ、急いだリリースが時々新しいバグを導入する可能性があるため、厳密に必要でない限り避けるのが最適であることに注意してください。そのため、不必要にそのような追加の負担を引き起こす報告に対する配慮はしばしば少なく、あなたの作業が認められる最良の方法は通常、変更ログに表示される動作する修正を提供することである。
