# HAProxy Configuration Manual 3.2.4

## LICENSE

```
本資料は、GPL v2ライセンスに基づき公開された 以下のドキュメントを簡易的に抜粋翻訳したもので、内容の正確性、網羅性は保証しない。
https://docs.haproxy.org/3.2/configuration.html

Copyright (c) 2006 Willy Tarreau - w@1wt.eu

この翻訳物の配布もGPL v2に従う。
```

## 1. Quick reminder about HTTP

HAProxyがHTTPモードで動作している場合、リクエストとレスポンスの両方が完全に分析され、インデックス化されるため、コンテンツ内で見つかったほぼすべてのものに対してマッチング条件を構築することが可能である。

しかし、HTTPリクエストとレスポンスがどのように形成され、HAProxyがそれらをどのように分解するかを理解することが重要である。そうすることで、正しいルールを書くことと、既存の設定をデバッグすることが容易になる。

まず、HTTPはHAProxyが可能な限り厳密に従う一連のRFCによって標準化されている：
  - RFC 9110: HTTP Semantics (プロトコル要素の意味を説明)
  - RFC 9111: HTTP Caching (HTTPキャッシュが従うべきルールを説明)
  - RFC 9112: HTTP/1.1 (表現、相互運用性ルール、セキュリティ)
  - RFC 9113: HTTP/2 (表現、相互運用性ルール、セキュリティ)
  - RFC 9114: HTTP/3 (表現、相互運用性ルール、セキュリティ)

これらに加えて、RFC 8999から9002は、HTTP/3プロトコルで使用されるQUICトランスポート層を指定している。
### 1.1 The HTTP transaction model

HTTPプロトコルはトランザクション駆動である。これは、各リクエストが1つかつ1つのみのレスポンスにつながることを意味する。元々、プロトコルのバージョン1.0では、接続ごとに単一のリクエストがあった：TCP接続がクライアントからサーバーに確立され、クライアントが接続上でリクエストを送信し、サーバーが応答し、接続が閉じられる。新しいリクエストはその後新しい接続を必要とする：

  [CON1] [REQ1] ... [RESP1] [CLO1] [CON2] [REQ2] ... [RESP2] [CLO2] ...

このモードでは、しばしば「HTTP close」モードと呼ばれるが、HTTPトランザクションと同じ数の接続確立がある。接続がレスポンス後にサーバーによって閉じられるため、クライアントはコンテンツ長を知る必要がなく、接続が閉じられたときにレスポンスが完了したと考える。これはまた、ネットワークエラーにより一部のレスポンスが切り詰められた場合、クライアントが誤ってレスポンスが完了したと思い込む可能性があり、これは時々画面に切り詰められた画像が表示される原因となっていた。

プロトコルのトランザクション性により、2つの後続するトランザクション間で接続を閉じることを避けるために改善することが可能であった。しかし、このモードでは、サーバーが各レスポンスのコンテンツ長を示すことが必須であり、クライアントが無限に待機しないようにする。このために、特別なヘッダーが使用される：「Content-length」。このモードは「keep-alive」モードと呼ばれ、HTTP/1.1と共に到着した（一部のHTTP/1.0エージェントがサポートしている）、リクエスト間で再利用される接続は「persistent connections」と呼ばれる：

  [CON] [REQ1] ... [RESP1] [REQ2] ... [RESP2] [CLO] ...

その利点は、トランザクション間のレイテンシーの削減、サーバー側で必要な処理能力の削減、切り詰められたレスポンスを検出する能力である。一般的にcloseモードより高速であるが、常にそうとは限らない。なぜなら、一部のクライアントがしばしば同時接続をより小さな値に制限し、これが貧弱なネットワーク接続性の不足を補償しないためである。また、一部のサーバーは可能な新しいリクエストを待つために長時間接続を維持しなければならず、多数の接続による高いメモリ使用量を経験する可能性があり、早すぎる閉鎖は接続が閉じられた瞬間に到着した一部のリクエストを破損させる可能性がある。

このモードでは、レスポンスサイズを事前に知る必要があるため、動的に生成されたり圧縮されたコンテンツでは常に可能とは限らない。この理由で、別のモードが実装された：「chunked mode」、全体のサイズを一度に発表する代わりに、送信者は既にバッファにあるレスポンスの次の「チャンク」のサイズのみを広告し、ゼロサイズのチャンクで任意の瞬間に終了できる。このモードでは、Content-Lengthヘッダーは使用されない。

通信における別の改善は、パイプライン化モードである。これはまだkeep-aliveを使用するが、クライアントは2番目のリクエストを送信するために最初のレスポンスを待たない。これはページを構成する多数の画像を取得するのに有用である：

  [CON] [REQ1] [REQ2] ... [RESP1] [RESP2] [CLO] ...

これは明らかにパフォーマンスに多大な利益をもたらす可能性がある。なぜなら、後続するリクエスト間のネットワークレイテンシーが排除されるためである。多くのHTTPエージェントは、HTTPでレスポンスを対応するリクエストに関連付ける方法がないため、パイプライン化を正しくサポートしていない。この理由で、サーバーがリクエストが受信されたのと正確に同じ順序で応答することが必須である。実際には、様々なクライアントによる数回の試行の後、特定のサーバーでの信頼性の欠如により完全に放棄された。しかし、サーバーがそれをサポートすることは必須である。

次の改善は、HTTP/2とHTTP/3で実装されている多重化モードである。このモードでは、複数のトランザクション（すなわち、リクエスト-レスポンスペア）が単一の接続上で並行して送信され、それらはすべて互いに独立して独自の速度で進行する。多重化プロトコルでは、同じ接続上で発生するこれらの並行通信を表すために、「ストリーム」の新しい概念が導入された。各ストリームは一般的に特定の接続に対して一意の識別子が割り当てられ、両方のエンドポイントがデータを配信する場所を知るために使用される。クライアントが同じ接続上で多数（最大100、時にはそれ以上）のストリームを並行して開始し、サーバーにそれらを整理させ、利用可能なレスポンスに応じて任意の順序で応答させることは非常に一般的である。多重化モードの主な利点は、ラウンドトリップの数を大幅に削減し、高レイテンシーネットワーク上でのページ読み込み時間を高速化することである。これは時々多くの画像を使用するサイトで見えることがあり、すべての画像が並行して読み込まれるように見える。

これらのプロトコルはまた、ワイヤ上のバイト数を削減するためにヘッダーフィールドを圧縮するいくつかのメカニズムを採用することにより効率を改善した。そのため、適切なツールなしでは、HTTP/1のように手動で現実的に操作できず、肉眼で読み取ることもできない。この理由で、HTTPメッセージの様々な例は、プロトコルの新しいバージョンであっても、文献（この文書を含む）でHTTP/1構文を使用して表現され続けている。

HTTP/2は、パケット損失がすべてのストリームに一度に影響するなどの設計上の制限に苦しんでおり、クライアントがオブジェクトを取得するのに時間がかかりすぎる場合（例：ディスクに保存する必要がある）、その取得を遅くし、その間、その背後で保留されているデータにアクセスすることが不可能になる可能性がある。これは「head of line blocking」または「HoL blocking」、時には単に「HoL」と呼ばれる。

HTTP/3はQUIC上に実装されており、QUIC自体はUDP上に実装されている。QUICは、独立して処理されるストリームにより、トランスポートレベルでのhead of line blockingを解決する。実際、損失を経験する際、影響を受けたストリームは他のストリームに影響せず、それらすべてに並行してアクセスできる。QUICはまた、接続移行サポートを提供するが、現在haproxyはそれをサポートしていない。

デフォルトでHAProxyは永続接続に関してkeep-aliveモードで動作する：各接続に対して各リクエストとレスポンスを処理し、レスポンスの終了と新しいリクエストの開始の間で両側で接続をアイドル状態にしておく。クライアントからHTTP/2接続を受信する際、すべてのリクエストを並行して処理し、keep-alive HTTP接続であるかのように、接続をアイドル状態にしておき、新しいリクエストを待機する。

HAProxyは本質的に3つの接続モードをサポートする：

- keep alive    : すべてのリクエストとレスポンスが処理され、クライアント向けとサーバー向けの接続が新しいリクエストのために維持される。これはデフォルトであり、現代のWebと現代のプロトコル（HTTP/2とHTTP/3）に適している。

- server close  : サーバー向け接続がレスポンス後に閉じられる。

- close         : 接続が両側でレスポンス終了後に積極的に閉じられる。

これに加えて、デフォルトで、サーバー向け接続はHTTPプロトコル仕様で義務付けられているように、任意のクライアントからの任意のリクエストによって再利用可能である。そのため、特定のクライアントに関連する任意の情報は、必要に応じて各リクエストと共に渡されなければならない（例：クライアントの送信元アドレスなど）。HTTP/2がサーバーと共に使用される場合、デフォルトでHAProxyはクライアント間のhead of line blockingのリスクを避けるために、この接続を同じクライアントに専用にする。
### 1.2 Terminology

HAProxy内では、用語はHTTPプロトコルとその使用法の進化に従って時代とともに少し進化してきた。元々は接続、セッション、ストリーム、トランザクションの間に重要な違いはなかったが、これらは時間とともに明確になり、HTTPプロトコルの現代版に存在するものと密接に一致するようになった。ただし、一部の用語は歴史的互換性の目的で設定やコマンドラインインターフェースに残っている。

以下は、HAProxyの現在のバージョンに適用される定義である：

- connection: 接続は、リモートエージェント（クライアントまたはサーバー）とhaproxyの間の単一の双方向通信チャネルであり、可能な限り低いレベルである。通常、IPとポートのペア間で確立されたTCPソケットに対応する。クライアント向け側では、接続はクライアントがhaproxyに接続したときにインスタンス化される最初のエンティティであり、接続レベルで適用されるルールは適用される最初のものである。

- session: セッションは、接続に関連付けられたコンテキスト情報を追加する。これには、トランスポート層固有の情報（例：TLSキーなど）または変数が含まれる。この用語は長い間HAProxy内で2つのエンド間のエンドツーエンドHTTP/1.0通信を表すために使用されてきた。そのため、現在はストリームを表しているにもかかわらず、特定のCLIコマンドや統計の名前に残っている。ただし、ヘルプメッセージと説明はこれを明確にしようとしている。ネットワークレベルの用語（例：オペレーティングシステム内のTCPセッション、またはファイアウォールを横切るTCPセッション）、または非HTTPユーザーレベルアプリケーション（例：telnetセッションやSSHセッション）に関しては、まだ有効である。クッキーに完全なユーザーコンテキストを保存し、同じサーバーに送信される必要がある「アプリケーションセッション」と混同してはならない。

- stream: ストリームは、アプリケーションレベルでのエンドツーエンド双方向通信に正確に対応し、分析と変換が適用される可能性がある。HTTPでは、単一のリクエストとそれに関連するレスポンスを含み、リクエストの到着によってインスタンス化され、レスポンスの配信終了で完了する。このコンテキストでは、そのようなストリームと多重化プロトコルのストリームの間に1:1の関係がある。TCP通信では接続ごとに単一のストリームがある。

- transaction: トランザクションは、リクエストと関連するレスポンスのペアのみである。この用語は、ストリームの前にセッションと組み合わせて使用されていたが、現在はトランザクションとストリームの間に1:1の関係がある。これは本質的に変数のスコープ「txn」で見える。これはトランザクション全体、したがってストリームの間有効である。

- request: クライアントからサーバーへのトラフィックを指定する。主にHTTPで操作が実行される場所を示すために使用される。この用語はまた、データが処理される場所を示すTCP操作にも存在する。リクエストはしばしばトラフィックまたはアクティビティの単位としてカウンターに現れる。それらは常にレスポンスを意味するとは限らない（例：エラーによる）が、リクエストなしの自発的なレスポンスがないため、リクエストは全体的なアクティビティの関連する指標のままである。TCPでは接続と同じ数のリクエストがある。

- response: これはサーバーからクライアントへのトラフィック、または時にはHAProxyがレスポンス自体を生成する場合（例：HTTPリダイレクト）のHAProxyからクライアントへのトラフィックを指定する。

- service: これは一般的に、サーバーを必要としないHAProxy内の一部の内部処理を示す。統計ページ、キャッシュ、または小さなアプリケーションを実装するための一部のLuaコードなどである。サービスは通常、リクエストを読み取り、一部の操作を実行し、レスポンスを生成する。
### 1.3 HTTP request

まず、このHTTPリクエストを考えてみよう：

```
  Line     Contents
  number
     1     GET /serv/login.php?lang=en&profile=2 HTTP/1.1
     2     Host: www.mydomain.com
     3     User-agent: my small browser
     4     Accept: image/jpeg, image/gif
     5     Accept: image/png
```

#### 1.3.1 The Request line

1行目は「リクエスト行」である。これは常に3つのフィールドで構成される：

- a METHOD      : GET
- a URI         : /serv/login.php?lang=en&profile=2
- a version tag : HTTP/1.1

それらすべては、標準がLWS（linear white spaces）と呼ぶものによって区切られる。これらは一般的にスペースであるが、タブまたは改行/キャリッジリターンの後にスペース/タブが続くこともある。メソッド自体はコロン（':'）を含むことができず、アルファベット文字に制限される。これらの様々な組み合わせにより、ユーザーが複雑または不正確な正規表現を書くことを残すのではなく、HAProxyが分割を実行することが望ましい。

URI自体はいくつかの形式を持つことができる：

- A "relative URI" :

      `/serv/login.php?lang=en&profile=2`

    これはホスト部分のない完全なURLである。これは一般的にサーバー、リバースプロキシ、透過プロキシが受信するものである。

- An "absolute URI", also called a "URL" :

      `http://192.168.0.12:8080/serv/login.php?lang=en&profile=2`

    これは「スキーム」（プロトコル名の後に'://'が続く）、ホスト名またはアドレス、オプションでコロン（':'）の後にポート番号、その後アドレス部分の後の最初のスラッシュ（'/'）から始まる相対URIで構成される。これは一般的にプロキシが受信するものであるが、HTTP/1.1をサポートするサーバーもこの形式を受け入れなければならない。

- a star ('*') : この形式はOPTIONSメソッドとの関連でのみ受け入れられ、中継できない。次のホップの能力を問い合わせるために使用される。

- an address:port combination : `192.168.0.12:80`
    これはCONNECTメソッドと共に使用される。CONNECTメソッドはHTTPプロキシを通じてTCPトンネルを確立するために使用され、一般的にHTTPSのためであるが、時には他のプロトコルのためにも使用される。

相対URIでは、2つのサブ部分が識別される。疑問符の前の部分は「path」と呼ばれる。これは典型的にサーバー上の静的オブジェクトへの相対パスである。疑問符の後の部分は「クエリ文字列」と呼ばれる。これは主に動的スクリプトに送信されるGETリクエストで使用され、使用中の言語、フレームワーク、またはアプリケーションに非常に特異的である。

HTTP/2とHTTP/3はリクエストと共にバージョン情報を伝達しないため、バージョンは基盤となるプロトコルのものと同じであると仮定される（すなわち「HTTP/2」）。さらに、これらのプロトコルはリクエスト行を1つの部分として送信せず、名前がコロンで始まる「疑似ヘッダー」と呼ばれる個別のフィールドに分割する。これらはHAProxyによって同等のリクエスト行に便利に再組み立てされる。この理由で、ログで見つかったリクエスト行は、HTTP/1.xとHTTP/2またはHTTP/3の間でわずかに異なる可能性がある。

#### 1.3.2 The request headers

ヘッダーは2行目から始まる。これらは行の始まりに名前で構成され、すぐ後にコロン（':'）が続く。伝統的に、コロンの後にLWSが追加されるが、これは必須ではない。その後、値が来る。複数の同一のヘッダーは、順序が尊重される限り、値がカンマで区切られて1つの行に折りたたまれる可能性がある。これは「Cookie:」フィールドで一般的に遭遇される。後続の行がLWSで始まる場合、ヘッダーは複数行にわたって広がる可能性がある。1.3の例では、4行目と5行目は「Accept:」ヘッダーの合計3つの値を定義する。最後に、仕様に従って、ヘッダーの始まりまたは終わりのすべてのLWSは無視され、値の一部ではない。

一般的な誤解に反して、ヘッダー名は大文字小文字を区別せず、それらの値も他のヘッダー名を参照する場合（「Connection:」ヘッダーのような）は大文字小文字を区別しない。HTTP/2とHTTP/3では、ヘッダー名は常に小文字で送信される。これはデバッグモードで実行する際に見ることができる。内部的には、すべてのヘッダー名は小文字に正規化されるため、HTTP/1.xとHTTP/2またはHTTP/3は正確に同じ表現を使用し、それらは反対側でそのまま送信される。これが、キャメルケースで入力されたHTTP/1.xリクエストが小文字で配信される理由を説明する。

ヘッダーの終わりは最初の空行によって示される。人々はしばしばそれが二重改行であると言うが、これは正確ではない。二重改行は空行の有効な形式の1つであるが。

幸いなことに、HAProxyはヘッダーのインデックス作成、値のチェック、カウントの際にこれらの複雑な組み合わせをすべて処理する。そのため、それらがどのように書かれる可能性があるかについて心配する理由はない。しかし、アプリケーションが異常で有効なことを行う場合に、アプリケーションがバグがあると非難しないことが重要である。

重要な注意：
   RFC7231で提案されているように、HAProxyは複数行ヘッダーを結合するために、ヘッダーの途中の改行をLWSに置き換えることによりヘッダーを正規化する。これは適切な分析に必要であり、能力の低いHTTPパーサーが正しく動作し、そのような複雑な構造に騙されないようにするのに役立つ。
### 1.4 HTTP response

HTTPレスポンスはHTTPリクエストと非常によく似ている。両方ともHTTPメッセージと呼ばれる。このHTTPレスポンスを考えてみよう：
```
  Line     Contents
  number
     1     HTTP/1.1 200 OK
     2     Content-length: 350
     3     Content-Type: text/html
```
特別な場合として、HTTPはステータスコード1xxのいわゆる「情報レスポンス」をサポートする。これらのメッセージは、レスポンスの一部を伝達しないという点で特別である。これらは単にクライアントにリクエストの投稿を続けるように求めるようなシグナリングメッセージとして使用される。ステータス100レスポンスの場合、要求された情報は情報メッセージに続く次の非100レスポンスメッセージによって運ばれる。これは、複数のレスポンスが単一のリクエストに送信される可能性があり、これがkeep-aliveが有効になっている場合にのみ機能することを意味する（1xxメッセージはHTTP/1.1で登場した）。HAProxyはこれらのメッセージを処理し、それらを正しく転送してスキップし、次の非100レスポンスのみを処理することができる。そのため、これらのメッセージは明示的にそうでないと述べない限り、ログに記録されず、変換されない。ステータス101メッセージは、プロトコルが同じ接続上で変更されており、HAProxyがCONNECTが発生したかのようにトンネルモードに切り替える必要があることを示す。その後、Upgradeヘッダーには接続が切り替わるプロトコルのタイプに関する追加情報が含まれる。

#### 1.4.1 The response line

1行目は「レスポンス行」である。これは常に3つのフィールドで構成される：

- a version tag : HTTP/1.1
- a status code : 200
- a reason      : OK

ステータスコードは常に3桁である。最初の桁は一般的なステータスを示す：
- 1xx = スキップされる情報メッセージ（例：100、101）
- 2xx = OK、コンテンツが続く（例：200、206）
- 3xx = OK、コンテンツは続かない（例：302、304）
- 4xx = クライアントによって引き起こされたエラー（例：401、403、404）
- 5xx = サーバーによって引き起こされたエラー（例：500、502、503）

599より大きいステータスコードは通信で発信されてはならない。ただし、特定のエージェントは内部ステータスを報告するためにログでそれらを生成する可能性がある。そのようなすべてのコードの詳細な意味についてはRFC9110を参照してください。HTTP/2以上にはバージョンタグがなく、ステータスコードを報告するために「:status」疑似ヘッダーを使用する。

「reason」フィールドは単なるヒントであるが、クライアントによって解析されない。そこには何でも見つかる可能性があるが、確立されたメッセージを尊重することは一般的な慣行である。これは「OK」、「Found」、または「Authentication Required」などの1つまたは複数の単語で構成される可能性がある。これはHTTP/2以上には存在せず、そこで発信されない。HTTP/2以上からのレスポンスがHTTP/1クライアントに送信される場合、HAProxyはステータスコードに一致するそのような一般的な理由フィールドを生成する。

HAProxyは以下のステータスコードを自ら発信する可能性がある：
```
  Code  When / reason
   200  access to stats page, and when replying to monitoring requests
   301  when performing a redirection, depending on the configured code
   302  when performing a redirection, depending on the configured code
   303  when performing a redirection, depending on the configured code
   307  when performing a redirection, depending on the configured code
   308  when performing a redirection, depending on the configured code
   400  for an invalid or too large request
   401  when an authentication is required to perform the action (when
        accessing the stats page)
   403  when a request is forbidden by a "http-request deny" rule
   404  when the requested resource could not be found
   408  when the request timeout strikes before the request is complete
   410  when the requested resource is no longer available and will not
        be available again
   500  when HAProxy encounters an unrecoverable internal error, such as a
        memory allocation failure, which should never happen
   501 when HAProxy is unable to satisfy a client request because of an
       unsupported feature
   502  when the server returns an empty, invalid or incomplete response, or
        when an "http-response deny" rule blocks the response.
   503  when no server was available to handle the request, or in response to
        monitoring requests which match the "monitor fail" condition
   504  when the response timeout strikes before the server responds
```
上記のエラー4xxと5xxコードはカスタマイズ可能である（セクション4.2の「errorloc」を参照）。他のステータスコードは特定のアクションによって意図的に発信される可能性がある（
## 2. Configuring HAProxy
### 2.1 Configuration file format

HAProxyの設定プロセスは3つの主要なパラメータソースを含む：

  - コマンドラインからの引数、これらは常に優先される
  - 設定ファイル、その形式はここで説明される
  - 実行中のプロセスの環境、一部の環境変数が明示的に参照される場合

設定ファイルは、いくつかの基本的なルールに従うかなりシンプルな階層形式に従う：

  1. 設定ファイルは文の順序付けられたシーケンスである

  2. 文は、保護されていない「#」（ハッシュ）の前の単一の空でない行である

  3. 行は、保護されていないスペースまたはタブ文字で区切られたトークンまたは「単語」のシリーズである

  4. 行の最初の単語または単語のシーケンスは、この文書にリストされているキーワードまたはキーワードシーケンスの1つである

  5. 他のすべての単語は最初のもののすべての引数であり、一部はこの文書にリストされている既知のキーワードであり、他は値、設定の他の部分への参照、または式である

  6. 特定のキーワードは、その中でキーワードのサブセットのみがサポートされるセクションを区切る

  7. セクションはファイルの終わり、または新しいセクションを開始する特別なキーワードで終了する

これは、シンプルだが信頼性の高い設定ジェネレータを書くために知る必要があるすべてであるが、任意の設定を信頼性を持って解析したり、特定のコーナーケースを処理する方法を理解するには十分ではない。

まず、上記のルールのいくつかの結果がある。ルール6と7は、新しいセクションを定義するために使用されるキーワードがどこでも有効であり、特定のセクションで異なる意味を持つことができないことを意味する。これらのキーワードは常に単一の単語（単語のシーケンスとは対照的に）であり、伝統的にそれらに続くセクションは同じ名前を使用して指定される。例えば「global section」について話す場合、これは「global」キーワードに続く設定のセクションを指定する。この使用法は、対処する必要がある部分を特定するのに役立つエラーメッセージで多く使用される。

多くのセクションは内部オブジェクトまたは設定スペースを作成し、これらは他のものと区別される必要がある。この場合、これらはこの特定のセクションの名前を設定する追加の単語を取る。それらの一部にとって、セクション名は必須である。例えば「frontend foo」は「foo」という名前の「frontend」タイプの新しいセクションを作成する。通常、名前はそのセクションに特異的であり、異なるタイプの2つのセクションは同じ名前を使用できるが、これは設定管理を複雑にする傾向があるため推奨されない。

ルール7の直接的な結果は、複数のファイルが一度に読み取られる場合、それらのそれぞれが新しいセクションで開始されなければならず、各ファイルの終わりがセクションを終了するということである。ファイルはサブセクションを含むことも、既存のセクションを終了して新しいセクションを開始することもできない。

ルール1は順序が重要であると述べている。実際、一部のキーワードは、特定の順序で適用されるルールの順序付けられたシーケンスを作成するために複数回繰り返すことができるディレクティブを作成する。例えば「tcp-request」は、様々な基準で「accept」と「reject」ルールを交互に使用するために使用できる。そのため、設定ファイルプロセッサは、ファイルを編集する際に常にセクションの順序を保持しなければならない。セクションの順序は通常重要ではないが、globalセクションは他のセクションの前に配置されなければならない。ただし、必要に応じて繰り返すことができる。さらに、一部の自動識別子は、作成されたオブジェクト（例：プロキシ）の一部に自動的に割り当てられる可能性があり、セクションを並べ替えることにより、それらの識別子が変更される。これらは例えば統計に現れる。そのため、以下の設定は「foo」にID番号1を、「bar」にID番号2を割り当てる。2つのセクションが逆転されている場合、これらは交換される：

     listen foo
         bind :80

     listen bar
         bind :81

もう1つの重要な点は、上記のルール2と3によると、空行、スペース、タブ、および保護されていない「#」文字に続くコメントは、設定の一部ではないということである。これらは区切り文字として使用されるだけである。これは、以下の設定が厳密に同等であることを意味する：

         global#this is the global section
     daemon#daemonize
         frontend         foo
     mode             http   # or tcp

および：

     global
         daemon

     # this is the public web frontend
     frontend foo
         mode http

一般的な慣行は、新しいセクションを開始するキーワードのみを左に揃え、他のすべてのキーワードをインデント（すなわち、タブ文字またはいくつかのスペースを前置）することである。これにより、それらが同じセクションに属していることが即座に視覚的に分かる（上記の2番目の例で行われているように）。新しいセクションの前にコメントを配置することは、読者がそれが望ましいものかどうかを決定するのに役立つ。セクションの終わりに空白行を残すことも、編集する際に終わりを視覚的に見つけるのに役立つ。

タブはインデントに非常に便利であるが、コピーアンドペーストがうまくいかない。代わりにスペースが使用される場合、フィールドでの編集が自動インデントをサポートしない制限されたエディタで負担にならないように、多すぎない（2から4）を配置することが推奨される。

初期には、固定タブ位置で引数を分割することが一般的であった。なぜなら、ほとんどのキーワードは2つ以上の引数を取らないためである。複雑な式を特徴とする現代のバージョンでは、この慣行はもはや通用せず、推奨されない。
### 2.2 Quoting and escaping

パスワードの単一引用符付けが推奨される。

例:

```
userlist L1
  group G1 users tiger,scott
  group G2 users xdb,scott

  user tiger password $6$k6y3o.eP$JlKBx9za9667qe4(...)xHSwRv6J.C0/D7cV91
  user scott insecure-password 'elgato'
  user xdb insecure-password 'hello'

userlist L2
  group G1
  group G2

  user tiger password $6$k6y3o.eP$JlKBx(...)xHSwRv6J.C0/D7cV91 groups G1
  user scott insecure-password 'elgato' groups G1,G2
  user xdb insecure-password 'hello' groups G2
```

### 2.3 Environment variables

パラメータについては、環境変数に関するセクション2.3を参照。

注意：「peer」キーワードは「server」キーワード（以下を参照）に透過的に置き換えられる可能性がある。

「server」キーワードは、5.2段落で見つかったトランスポート設定に関連するすべての「server」パラメータのサポートと共に、「peer」キーワードを置き換える可能性がある。基盤となるピアがローカルである場合、アドレスパラメータは存在してはならない。これは「bind」行で提供されなければならない（この「peers」セクションの「bind」キーワードを参照）。

多くの「server」パラメータは「peers」セクションには無関係である。ピアは本質的に動的ホスト名解決もヘルスチェックもサポートしないため、「init_addr」、「resolvers」、「check」、「agent-check」、または「track」などのパラメータはサポートされない。同様に、ロードバランシングもスティッキネスもないため、「weight」や「cookie」などのパラメータは効果がない。

例：
```
# The old way.
peers mypeers
    peer haproxy1 192.168.0.1:1024
    peer haproxy2 192.168.0.2:1024
    peer haproxy3 10.2.0.1:1024

backend mybackend
    mode tcp
    balance roundrobin
    stick-table type ip size 20k peers mypeers
    stick on src

    server srv1 192.168.0.30:80
    server srv2 192.168.0.31:80

例：
peers mypeers
    bind 192.168.0.1:1024 ssl crt mycerts/pem
    default-server ssl verify none
    server haproxy1 #local peer
    server haproxy2 192.168.0.2:1024
    server haproxy3 10.2.0.1:1024
```

「shards」キーワードは、peersセクションで宣言された各ピアにすべてのスティックテーブルコンテンツを送信する代わりに、スティックテーブルコンテンツを一部のピアに配布したい場合に使用される。このような場合、「shards」はこのスティックテーブルコンテンツ配布に関与するピアの数を指定する。「shard」サーバーパラメータも参照。

「table」キーワードは、現在のセクションのスティッキネステーブルを設定する。この行は、他のセクションの「stick-table」キーワードと正確に同じ方法で解析される。ただし、「peers」引数はここでは必要ではなく、スティックテーブルを指定する追加の必須の最初のパラメータがある。他のセクションとは対照的に、「peers」セクションには複数の「table」行がある可能性がある（「table」と「stick-table」キーワードの完全な定義も参照）。
### 2.4 Conditional blocks

設定の一部の任意の部分を条件付きで有効または無効にすることが便利な場合がある。例えば、SSLまたは暗号を有効/無効にする、設定を変更せずに一部の本番前リスナーを有効または無効にする、または移行中に2つの異なるバージョンのHAProxyをサポートするために設定の構文を調整するなどである。HAProxyは、テキストの一部のブロックを統合または無視することを可能にする、ネスト可能なプリプロセッサライクなディレクティブのセットを提供する。これらのディレクティブは独自の行に配置されなければならず、それらに続く行に作用する。それらの2つは式をサポートし、他のものは代替ブロックに切り替えるか、現在のレベルを終了するだけである。条件付きブロックを形成するために、以下の4つのディレクティブが定義される：

  - .if &lt;condition&gt;
  - .elif &lt;condition&gt;
  - .else
  - .endif

「.if」ディレクティブは新しいレベルをネストし、「.elif」は同じレベルに留まり、「.else」も同様であり、「.endif」はレベルを閉じる。各「.if」は一致する「.endif」で終了しなければならない。「.elif」は「.if」または「.elif」の後にのみ配置でき、チェーンできる「.elif」の数に制限はない。「.if」ごとに「.else」は1つしかなく、常に「.if」またはブロックの最後の「.elif」の後になければならない。

必要に応じて、コメントは「#」の後の同じ行に配置できる。これらは無視される。ディレクティブは他の設定ディレクティブと同様にトークン化され、そのため条件で環境変数を使用することが可能である。

条件はまた、-ccパラメータで起動時に評価することもできる。
管理文書の「3. Starting HAProxy」を参照。

条件は空の文字列（その場合falseを返す）、または以下の任意の組み合わせで構成される式のいずれかである：

  - 整数ゼロ（'0'）、常に「false」を返す
  - 非ゼロ整数（例：'1'）、常に「true」を返す
  - オプションで括弧内の引数が続く述語
  - 括弧のペア「（」と「）」の間に配置された条件
  - 上記の非空要素の前に置かれる感嘆符（'!'）、これはそのステータスを否定する
  - 論理AND（'&&'）で結合された式、これらは左から右に評価され、1つがfalseを返すまで続く
  - 論理OR（'||'）で結合された式、これらは右から左に評価され、1つがtrueを返すまで続く

同じ行トークナイザーと引数パーサーが設定言語の残りの部分に使用される。単語は1つ以上の引用符で囲まれていないスペースまたはタブの連続シリーズの周りで分割され、評価前に単一のスペースを使用して一緒に再組み立てされる。これは、ユーザーが行全体を引用する必要がないようにするためである。しかし、これはまた、カンマまたは括弧の周りのスペースが確実に値の一部であることを意味する。これは常に期待されるわけではない。例えば、以下の式：
```
   .if defined( HAPROXY_MWORKER )
```
は変数「 HAPROXY_MWORKER 」（スペース付き）の存在をテストし、これ：
```
   .if streq("$ENABLE_SSL",     1)
```
は環境変数「ENABLE_SSL」を値「 1」（単一の先行スペース付き）と比較する。理由は、行が最初に以下のように単語に分割されるためである：
```
   .if streq("$ENABLE_SSL",     1)
  |---|--------------------|   |--|
    1           2               3
```
その後、弱い引用が適用され、環境変数「$ENABLE_SSL」が解決される（例としてENABLE_SSL=0としよう）、最後に単語が単語間に単一のスペースを配置することにより単一の文字列に再組み立てされる：
```
   .if streq(0, 1)
  |---|-------|--|
    1     2     3
```
そして、その時のみ単一の式として解析される。カンマと「1」の間に挿入されたスペースは依然として引数値の一部であり、この引数を「 1」にする：
```
   .if streq(0, 1)
  |---|-----|-|--|
    \    \    \  \_ argument2: " 1"
     \    \    \___ argument1: "0"
      \    \_______ function: "streq"
       \___________ directive: ".if"
```
ここで、ENABLE_SSLが「1」に等しかったとしても、文字列が1つのスペースで異なるため「 1」と一致しなかったことが分かる。

注意：「2.2. Quoting and escaping」セクションで説明されているように、良い経験則は、式内に不要なスペースを挿入しないことである。

他の言語と同様に、AND演算子はOR演算子より優先されることに注意。そのため、「A && B || C && D」は「(A && B) || (C && D)」として評価される。

現在サポートされている述語のリストは以下の通りである：

  - defined(&lt;name&gt;)       : 環境変数&lt;name&gt;が存在する場合、その内容に関係なくtrueを返す

  - feature(&lt;name&gt;)       : 機能&lt;name&gt;が「haproxy -vv」によって報告される機能リストに存在としてリストされている場合trueを返す
                            （これは&lt;name&gt;が'+'の後に現れることを意味する）

  - streq(&lt;str1&gt;,&lt;str2&gt;)  : 2つの文字列が等しい場合のみtrueを返す
  - strneq(&lt;str1&gt;,&lt;str2&gt;) : 2つの文字列が異なる場合のみtrueを返す
  - strstr(&lt;str1&gt;,&lt;str2&gt;) : 2番目の文字列が最初の文字列で見つかる場合のみtrueを返す

  - version_atleast(&lt;ver&gt;): 現在のhaproxyバージョンが&lt;ver&gt;以上である場合trueを返し、そうでなければfalseを返す。バージョン構文は「haproxy -v」によって示されるものと同じであり、欠けているコンポーネントはゼロであると仮定される。

  - version_before(&lt;ver&gt;) : 現在のhaproxyバージョンが&lt;ver&gt;より厳密に古い場合trueを返し、そうでなければfalseを返す。バージョン構文は「haproxy -v」によって示されるものと同じであり、欠けているコンポーネントはゼロであると仮定される。

  - enabled(&lt;opt&gt;)        : オプション&lt;opt&gt;が実行時に有効になっている場合trueを返す。サポートされているオプションのサブセットのみ：
                                POLL, EPOLL, KQUEUE, EVPORTS, SPLICE,
                                GETADDRINFO, REUSEPORT, FAST-FORWARD,
                                SERVER-SSL-VERIFY-NONE

例：
```
# 1. HAPROXY_MWORKER変数はHAProxyによってマスターとワーカープロセス環境で自動的に設定される
# （2.3. Environment variablesのHAProxy変数マトリックスを参照）。その存在は追加のリスナーを有効にする。

global
  master-worker

.if defined(HAPROXY_MWORKER)
    listen mwcli_px
       bind :1111
       ...
.endif

# 2. HAPROXY_BRANCHはHAProxyによってマスターとワーカープロセス環境で自動的に設定される
# （2.3. Environment variablesのHAProxy変数マトリックスを参照）。HAPROXY_BRANCH値をチェックし、
# 条件付きでmworker-max-reloadsパラメータを有効にする。

global
  master-worker

.if streq("$HAPROXY_BRANCH",3.1)
     mworker-max-reloads 5
.endif

# 3. 一部の任意の環境変数はユーザーによってglobalセクションで設定される。HAProxyがマスター-ワーカーモードで
# 開始される場合、これらはマスターとワーカープロセス環境で提示される。これらの変数の値をチェックし、
# 条件付きでポート80と443を有効にする。環境変数チェックは機能とバージョンチェックと混在できる。

global
  setenv WITH_SSL yes
  unsetenv SSL_ONLY

.if strneq("$SSL_ONLY",yes)
       bind :80
.endif

.if streq("$WITH_SSL",yes)
  .if feature(OPENSSL)
       bind :443 ssl crt ...
  .endif
.endif

.if feature(OPENSSL) && (streq("$WITH_SSL",yes) || streq("$SSL_ONLY",yes))
       bind :443 ssl crt ...
.endif

.if version_atleast(2.4-dev19)
    profiling.memory on
.endif

.if !feature(OPENSSL)
    .alert "SSL support is mandatory"
.endif
```

他の4つのディレクティブが一部のステータスを報告するために提供される：

  - .diag "message"    : 診断モード（-dD）でのみこのメッセージを発信
  - .notice "message"  : NOTICEレベルでこのメッセージを発信
  - .warning "message" : WARNINGレベルでこのメッセージを発信
  - .alert "message"   : ALERTレベルでこのメッセージを発信

WARNINGレベルで発信されたメッセージは、「strict-mode」が有効になっている場合、プロセスの開始に失敗する可能性がある。ALERTレベルで発信されたメッセージは常に致命的なエラーを引き起こす。これらは、不適切な条件を検出し、ユーザーにアドバイスを提供するために使用できる。

例：
```
.if "${A}"
  .if "${B}"
     .notice "A=1, B=1"
  .elif "${C}"
     .notice "A=1, B=0, C=1"
  .elif "${D}"
     .warning "A=1, B=0, C=0, D=1"
  .else
     .alert "A=1, B=0, C=0, D=0"
  .endif
.else
     .notice "A=0"
.endif

.diag "WTA/2021-05-07: replace 'redirect' with 'return' after switch to 2.4"
      http-request redirect location /goaway if ABUSE
```
### 2.5 Time format

「stick match」、「stick on」、「stick store-request」、「track-sc」、時間形式に関するセクション2.5、ピアに関するセクション11.2、帯域幅制限に関するセクション9.7、ACLに関するセクション7も参照。
### 2.6 Size format

一部のパラメータは、帯域幅制限などのサイズを表す値を含む。これらの値は一般的にバイトで表現される（明示的にそうでないと述べられていない限り）が、数値に単位を接尾辞として付けることにより、他の任意の単位で表現される可能性がある。これは、すべてのキーワードで繰り返されないため、これを考慮することが重要である。サポートされている単位は大文字小文字を区別しない：

  - k : キロバイト。1キロバイト = 1024バイト
  - m : メガバイト。1メガバイト = 1048576バイト
  - g : ギガバイト。1ギガバイト = 1073741824バイト

時間とサイズの両方の形式は整数を必要とし、小数点表記は許可されない。
### 2.7 Name format for maps and ACLs

マップまたはACLのパターンのリストを使用することが可能である。パターンのリストはその名前によって識別され、設定の異なる場所で使用される可能性がある。パターンのリストは、名前形式に応じて3つのカテゴリに分割される：

  * 通常ファイルに基づくパターンのリスト：これはデフォルトの場合である。ファイル名、絶対または相対、が名前として使用される。ファイルは存在しなければならず、そうでなければエラーが引き起こされる。ただし、空である可能性がある。「file@」プレフィックスも指定できるが、リストを識別する名前の一部ではない。プレフィックスありまたはなしのファイル名は、同じパターンのリストを参照する。

  * オプションファイルに基づくパターンのリスト：ファイル名の前に「opt@」プレフィックスが付かなければならない。ファイルの存在はオプションである。ファイルが存在する場合、そのコンテンツが読み込まれるが、存在しない場合でもエラーは報告されない。プレフィックスはリストを識別する名前の一部ではない。これは、特定のファイル名について、オプションファイルと通常ファイルが同じパターンのリストを参照することを意味する。

  * 仮想ファイルに基づくパターンのリスト：名前は単なる識別子である。これは任意のファイルへの参照ではない。「virt@」プレフィックスが使用されなければならない。これは名前の一部である。そのため、他の種類のリストと混在することはできない。

仮想ファイルは、起動時とリロード時にパターンがなく、パターンが完全に動的に管理される場合に有用である。オプションファイルは同じ条件下で使用できる。ただし、パターンはファイルにダンプできる。例えば「show map」CLIコマンドに基づく外部スクリプトを通じてである。この方法で、リロード時にパターンを保持することが可能である。

注意：可能性は低いが、これは「file@」、「opt@」、または「virt@」で始まる通常ファイルは、ファイル名の前に「./」を明示的に追加する（例えば「file@./virt@map」）ことによってのみ読み込むことができることを意味する。
### 2.8 Variables

「SPOE」ストリームからのメインストリーム。詳細については変数に関するセクション2.8を参照。

SPOE設定とSPOP仕様に関するすべての情報については、「doc/SPOE.txt」を参照。
### 2.9 Address formats

「bind」、「server」、「nameserver」、および「log」などのいくつかの文はアドレスを必要とする。

このアドレスは、ホスト名、IPv4アドレス、IPv6アドレス、または'*'である可能性がある。'*'は特別なアドレス「0.0.0.0」と等しく、「bind」または「dgram-bind」の場合にシステムのすべてのIPv4でリッスンするために使用できる。IPv6の同等物は'::'である。

文に応じて、ポートまたはポート範囲がIPアドレスに続く。これは'bind'文では必須であり、'server'ではオプションである。

このアドレスはまた、スラッシュ'/'で始まることもできる。これは「unix」ファミリーと見なされ、'/'とそれに続く文字はパスに存在しなければならない。

デフォルトのソケットタイプまたはトランスポート方法「datagram」または「stream」は、アドレスを示す設定文に依存する。実際、'bind'と'server'はデフォルトで「stream」ソケットタイプを使用するが、'log'、'nameserver'、または'dgram-bind'は「datagram」を使用する。

オプションで、プレフィックスを使用してアドレスファミリーと/またはソケットタイプとトランスポート方法を強制できる。

#### 2.9.1 Address family prefixes

'&lt;name&gt;'に続く'abns@&lt;name&gt;'は抽象名前空間である（Linuxのみ）。

'&lt;name&gt;'に続く'abnsz@&lt;name&gt;'はゼロ終端抽象名前空間である（Linuxのみ）。

'&lt;n&gt;'に続く'fd@&lt;n&gt;'は、親から継承されたファイル記述子&lt;n&gt;である。fdはバインドされなければならず、既にリッスンしている可能性がある。

'&lt;address&gt;'に続く'ip@&lt;address&gt;[:port1[-port2]]'は、構文に応じてIPv4またはIPv6アドレスと見なされる。このアドレスを使用する文に応じて、ポートまたはポート範囲が指定される可能性があるか、指定されなければならない。

'&lt;address&gt;'に続く'ipv4@&lt;address&gt;[:port1[-port2]]'は、常にIPv4アドレスと見なされる。このアドレスを使用する文に応じて、ポートまたはポート範囲が指定される可能性があるか、指定されなければならない。

'&lt;address&gt;'に続く'ipv6@&lt;address&gt;[:port1[-port2]]'は、常にIPv6アドレスと見なされる。このアドレスを使用する文に応じて、ポートまたはポート範囲が指定される可能性があるか、指定されなければならない。

'&lt;n&gt;'に続く'sockpair@&lt;n&gt;'は、接続されたunixソケットまたはsocketpairのファイル記述子である。接続中、開始者は接続されたソケットのペアを作成し、そのうちの1つをFDを通じて反対側に渡す。リスナーはunixソケットからFDを受信するのを待ち、accept()のFDであるかのようにそれを使用する。慎重に使用されるべきである。

'&lt;path&gt;'に続く'unix@&lt;path&gt;'は、UNIXソケット&lt;path&gt;と見なされる。このプレフィックスは、スラッシュ'/'で始まらないUNIXソケットパスを宣言するのに有用である。

#### 2.9.2 Socket type prefixes

前の「Address family prefixes」もまた、ソケットタイプとトランスポート方法を強制するためにプレフィックスを付けることができる。デフォルトはこのアドレスを使用する文に依存するが、一部の場合、ユーザーはそれを異なるものに強制できる。これは「log」文の場合である。デフォルトはUDP上のsyslogであるが、TCP上のsyslogを使用するように強制できる。

これらのプレフィックスは内部目的のために設計されており、ユーザーは代わりに次のセクション「2.9.3 Protocol prefixes」のエイリアスを使用すべきである。ただし、これらは時々便利である可能性がある。例えば、ファイル記述子番号によって知られている継承されたソケットと組み合わせて使用する場合、アドレスファミリーは「fd」であり、ソケットタイプが宣言されなければならない。

ユーザーが期待することを実行するためにそれらのプレフィックスの1つを必要とする場合、プロトコルプレフィックスを使用して同じものを設定できないため、これについてメンテナーに報告すべきである。

'&lt;family&gt;@&lt;address&gt;'に続く'stream+&lt;family&gt;@&lt;address&gt;'は、ソケットタイプとトランスポート方法を「stream」に強制する

'&lt;family&gt;@&lt;address&gt;'に続く'dgram+&lt;family&gt;@&lt;address&gt;'は、ソケットタイプとトランスポート方法を「datagram」に強制する

'&lt;family&gt;@&lt;address&gt;'に続く'quic+&lt;family&gt;@&lt;address&gt;'は、ソケットタイプを「datagram」に強制し、トランスポート方法を「stream」に強制する

#### 2.9.3 Protocol prefixes

'&lt;address&gt;'に続く'quic4@&lt;address&gt;[:port1[-port2]]'は、常にIPv4アドレスと見なされるが、ソケットタイプは「datagram」に強制され、トランスポート方法は「stream」に強制される。このアドレスを使用する文に応じて、UDPポートまたはポート範囲が指定される可能性があるか、指定されなければならない。これは「quic+ipv4@」と同等である。

'&lt;address&gt;'に続く'quic6@&lt;address&gt;[:port1[-port2]]'は、常にIPv6アドレスと見なされるが、ソケットタイプは「datagram」に強制され、トランスポート方法は「stream」に強制される。このアドレスを使用する文に応じて、UDPポートまたはポート範囲が指定される可能性があるか、指定されなければならない。これは「quic+ipv6@」と同等である。

'&lt;address&gt;'に続く'tcp@&lt;address&gt;[:port1[-port2]]'は、構文に応じてIPv4またはIPv6アドレスと見なされるが、ソケットタイプとトランスポート方法は「stream」に強制される。このアドレスを使用する文に応じて、ポートまたはポート範囲が指定される可能性があるか、指定されなければならない。これは'stream+ip@'のエイリアスと見なされる。

'&lt;address&gt;'に続く'tcp4@&lt;address&gt;[:port1[-port2]]'は、常にIPv4アドレスと見なされるが、ソケットタイプとトランスポート方法は「stream」に強制される。このアドレスを使用する文に応じて、ポートまたはポート範囲が指定される可能性があるか、指定されなければならない。これは'stream+ipv4@'のエイリアスと見なされる。

'&lt;address&gt;'に続く'tcp6@&lt;address&gt;[:port1[-port2]]'は、常にIPv6アドレスと見なされるが、ソケットタイプとトランスポート方法は「stream」に強制される。このアドレスを使用する文に応じて、ポートまたはポート範囲が指定される可能性があるか、指定されなければならない。これは'stream+ipv4@'のエイリアスと見なされる。

'&lt;address&gt;'に続く'mptcp@&lt;address&gt;[:port1[-port2]]'は、構文に応じてIPv4またはIPv6アドレスと見なされるが、ソケットタイプとトランスポート方法はMPTCPプロトコルで「stream」に強制される。このアドレスを使用する文に応じて、ポートまたはポート範囲が指定される可能性があるか、指定されなければならない。

'&lt;address&gt;'に続く'mptcp4@&lt;address&gt;[:port1[-port2]]'は、常にIPv4アドレスと見なされるが、ソケットタイプとトランスポート方法はMPTCPプロトコルで「stream」に強制される。このアドレスを使用する文に応じて、ポートまたはポート範囲が指定される可能性があるか、指定されなければならない。

'&lt;address&gt;'に続く'mptcp6@&lt;address&gt;[:port1[-port2]]'は、常にIPv6アドレスと見なされるが、ソケットタイプとトランスポート方法はMPTCPプロトコルで「stream」に強制される。このアドレスを使用する文に応じて、ポートまたはポート範囲が指定される可能性があるか、指定されなければならない。

'&lt;address&gt;'に続く'udp@&lt;address&gt;[:port1[-port2]]'は、構文に応じてIPv4またはIPv6アドレスと見なされるが、ソケットタイプとトランスポート方法は「datagram」に強制される。このアドレスを使用する文に応じて、ポートまたはポート範囲が指定される可能性があるか、指定されなければならない。これは'dgram+ip@'のエイリアスと見なされる。

'&lt;address&gt;'に続く'udp4@&lt;address&gt;[:port1[-port2]]'は、常にIPv4アドレスと見なされるが、ソケットタイプとトランスポート方法は「datagram」に強制される。このアドレスを使用する文に応じて、ポートまたはポート範囲が指定される可能性があるか、指定されなければならない。これは'dgram+ipv4@'のエイリアスと見なされる。

'&lt;address&gt;'に続く'udp6@&lt;address&gt;[:port1[-port2]]'は、常にIPv6アドレスと見なされるが、ソケットタイプとトランスポート方法は「datagram」に強制される。このアドレスを使用する文に応じて、ポートまたはポート範囲が指定される可能性があるか、指定されなければならない。これは'dgram+ipv4@'のエイリアスと見なされる。

'&lt;path&gt;'に続く'uxdg@&lt;path&gt;'は、unixソケット&lt;path&gt;と見なされるが、トランスポート方法は「datagram」に強制される。これは'dgram+unix@'のエイリアスと見なされる。

'&lt;path&gt;'に続く'uxst@&lt;path&gt;'は、unixソケット&lt;path&gt;と見なされるが、トランスポート方法は「stream」に強制される。これは'stream+unix@'のエイリアスと見なされる。

将来のバージョンでは、QUICのように「datagram」タイプのソケットに基づくストリームトランスポートを提案するプロトコルを指定するために、他のプレフィックスが使用される可能性がある。
### 2.10 Examples

```
# ポート80ですべてのインターフェースでリッスンし、127.0.0.1:8000でリッスンする単一のサーバー「server1」を持つ
# 単一のバックエンド「servers」にリクエストを転送するHTTPプロキシのシンプルな設定
global
    daemon
    maxconn 256

defaults
    mode http
    timeout connect 5000ms
    timeout client 50000ms
    timeout server 50000ms

frontend http-in
    bind *:80
    default_backend servers

backend servers
    server server1 127.0.0.1:8000 maxconn 32


# 単一のlistenブロックで定義された同じ設定。短いが、特にHTTPモードでは表現力が低い。
global
    daemon
    maxconn 256

defaults
    mode http
    timeout connect 5000ms
    timeout client 50000ms
    timeout server 50000ms

listen http-in
    bind *:80
    server server1 127.0.0.1:8000 maxconn 32
```

haproxyが$PATHにあると仮定して、シェルでこれらの設定をテストする：

    $ sudo haproxy -f configuration.conf -c
## 3. Global parameters

それらの使用方法については「Global parameters」セクション3を参照してシステムを調整する方法を見つける。

  - 「feconn」は、ストリームがログに記録された時点でのフロントエンドでの同時接続の総数である。高負荷を維持するために必要なリソースの量を推定し、フロントエンドの「maxconn」に達した時を検出するのに有用である。この値が大幅にジャンプして増加する場合、ほとんどの場合、バックエンドサーバーで輻輳が発生しているためであるが、時にはサービス拒否攻撃によって引き起こされる可能性がある。

  - 「beconn」は、ストリームがログに記録された時点でバックエンドによって処理された同時接続の総数である。これには、サーバー上でアクティブな同時接続の総数と、キューで保留中の接続数が含まれる。特定のアプリケーションの高負荷をサポートするために必要な追加サーバーの量を推定するのに有用である。この値が大幅にジャンプして増加する場合、ほとんどの場合、バックエンドサーバーで輻輳が発生しているためであるが、時にはサービス拒否攻撃によって引き起こされる可能性がある。

  - 「srv_conn」は、ストリームがログに記録された時点でサーバー上でまだアクティブな同時接続の総数である。これはサーバーの設定された「maxconn」パラメータを超えることはできない。この値がサーバーの「maxconn」に非常に頻繁に近いか等しい場合、トラフィック規制が多く関与していることを意味する。これは、サーバーのmaxconn値が低すぎるか、最適な応答時間で負荷を処理するのに十分なサーバーがないことを意味する。サーバーの「srv_conn」の1つのみが高い場合、通常、このサーバーに問題があり、他のサーバーよりもリクエストの処理に時間がかかる原因となっていることを意味する。

  - 「retries」は、サーバーに接続しようとした際にこのストリームが経験した接続再試行の数である。これは通常ゼロでなければならない。ただし、接続が試行されたのと同じ瞬間にサーバーが停止されている場合を除く。頻繁な再試行は、一般的にHAProxyとサーバーの間のネットワーク問題、またはサーバーで新しい接続がキューに入るのを防ぐ誤設定されたシステムバックログのいずれかを示す。このフィールドは、オプションで「+」記号が前置される可能性がある。これは、ストリームが初期サーバーで最大再試行回数に達した後に再配信を経験したことを示す。この場合、ログに現れるサーバー名は、接続が再配信されたサーバーであり、最初のサーバーではない。ただし、両方が時々同じである可能性がある（例えばハッシュの場合）。そのため、一般的な経験則として、再試行回数の前に「+」が存在する場合、このカウントはログに記録されたサーバーに帰属されるべきではない。

  - 「srv_queue」は、サーバーキューでこのリクエストの前に処理されたリクエストの総数である。リクエストがサーバーキューを通過していない場合はゼロである。キューでの時間をキュー内のリクエスト数で割ることにより、サーバーの応答時間を推定することが可能である。ストリームが再配信を経験し、2つのサーバーキューを通過する場合、それらの位置は累積されることに注意することが重要である。リクエストは、再配信が発生しない限り、サーバーキューとバックエンドキューの両方を通過すべきではない。

  - 「backend_queue」は、バックエンドのグローバルキューでこのリクエストの前に処理されたリクエストの総数である。リクエストがグローバルキューを通過していない場合はゼロである。サーバーの「maxconn」パラメータで割ることにより、平均キュー長を推定することが可能である。これは簡単に不足しているサーバーの数に変換される。ストリームが再配信を経験する場合、バックエンドのキューを2回通過する可能性があり、その場合、両方の位置が累積されることに注意することが重要である。リクエストは、再配信が発生しない限り、サーバーキューとバックエンドキューの両方を通過すべきではない。

  - 「captured_request_headers」は、フロントエンドでの「capture request header」文の存在により、リクエストでキャプチャされたヘッダーのリストである。複数のヘッダーをキャプチャでき、これらは縦棒（'|'）で区切られる。キャプチャが有効になっていない場合、中括弧は現れず、残りのフィールドのシフトが引き起こされる。このフィールドにスペースが含まれる可能性があり、それを使用するには、使用されていない場合よりもスマートなログパーサーが必要であることに注意することが重要である。詳細については、以下の「HTTPヘッダーとクッキーのキャプチャ」セクションを参照してください。

  - 「captured_response_headers」は、フロントエンドでの「capture response header」文の存在により、レスポンスでキャプチャされたヘッダーのリストである。複数のヘッダーをキャプチャでき、これらは縦棒（'|'）で区切られる。キャプチャが有効になっていない場合、中括弧は現れず、残りのフィールドのシフトが引き起こされる。このフィールドにスペースが含まれる可能性があり、それを使用するには、使用されていない場合よりもスマートなログパーサーが必要であることに注意することが重要である。詳細については、以下の「HTTPヘッダーとクッキーのキャプチャ」セクションを参照してください。

  - 「http_request」は、メソッド、リクエスト、HTTPバージョン文字列を含む完全なHTTPリクエスト行である。印刷不可能な文字はエンコードされる（以下の「印刷不可能な文字」セクションを参照）。これは常に最後のフィールドであり、常に引用符で区切られ、引用符を含むことができる唯一のフィールドである。新しいフィールドがログ形式に追加される場合、これらはこのフィールドの前に追加される。リクエストが巨大で標準のsyslogバッファ（1024文字）に収まらない場合、このフィールドは切り詰められる可能性がある。これが、このフィールドが常に最後のものである必要がある理由である。
### 3.1 JWT verification

RFC7518のセクション3.1で言及されているアルゴリズムが管理される（HS、ES、RS、PS、256、384、または512キーサイズ、および特別な「none」ケース）。

使用されるアルゴリズムがHMACファミリーの場合、&lt;key&gt;はHMAC署名計算で使用される秘密鍵である。そうでない場合、&lt;key&gt;はトークンの署名を検証するために使用できる公開鍵へのパスである。JWTを検証するために使用される可能性のあるすべての公開鍵は、実行時にディスクアクセスが必要ないように専用キャッシュに追加されるため、初期化中に既知でなければならない。この理由により、使用される任意の公開鍵は、jwt_verify呼び出しで少なくとも1回明示的に言及されなければならない。2番目のパラメータとして中間変数を渡すことは推奨されない。

このコンバーターはトークンの署名のみを検証し、実行しない。
### 3.2 Performance tuning

#### busy-polling
一部の状況、特に可変周波数をサポートするプロセッサでの低レイテンシーを扱う場合や、仮想マシン内で実行する場合、プロセスがポーラーを使用してI/Oを待機するたびに、プロセッサはスリープ状態に戻るか、長時間他のVMに提供される。これにより過度に高いレイテンシーが引き起こされる。このオプションは、ポーラーで常にnullタイムアウトを使用することにより、プロセッサがスリープ状態になることを防ぐソリューションを提供する。これにより、プロセッサの過熱のリスクを犠牲にして、レイテンシーが大幅に削減される（観察された30〜100マイクロ秒）。これはスレッドと共に使用することもでき、その場合、不適切にバインドされたスレッドが重く競合し、パフォーマンスが悪化し、「show info」出力のCPU stolenフィールドで高い値が表示される可能性がある。これはどのスレッドが誤設定されているかを示す。このオプションを使用する場合、プロセスをネットワーク割り込みと同じプロセッサで実行させないことが重要である。また、同じコアを共有する複数のCPUスレッドで使用することを避けることが推奨される。このオプションはデフォルトで無効である。有効になっている場合、「no」キーワードを前置することにより、強制的に無効にすることもできる。「select」および「poll」ポーラーでは無視される。

このオプションは、シームレスリロードのコンテキストで古いプロセスで自動的に無効になる。これにより、複数のプロセスが現在の接続の終了を待機している間、長時間存在する場合の過度のCPU競合を避ける。

#### max-spread-checks
デフォルトでは、HAProxyはファーム内のすべてのサーバーの最小ヘルスチェック間隔にわたってヘルスチェックの開始を分散させようとする。原則は、同じサーバー上で実行されているサービスをハンマリングすることを避けることである。しかし、大きなチェック間隔（10秒以上）を使用する場合、ファーム内の最後のサーバーはテストを開始するまでに時間がかかり、これが問題となる可能性がある。このパラメータは、サーバーのチェック間隔が大きい場合でも、最初と最後のチェックの間の遅延に上限を強制するために使用される。サーバーが短い間隔で実行される場合、それらの間隔は尊重される。

#### maxcompcpuusage
HAProxyが新しいリクエストの圧縮を停止するか、現在のリクエストの圧縮レベルを下げる前に到達できる最大CPU使用率を設定する。これは'maxcomprate'のように動作するが、入ってくるデータ帯域幅の代わりにCPU使用率を測定する。値はHAProxyによって使用されるCPUの割合で表現される。100の値は制限を無効にする。デフォルト値は100である。より低い値を設定すると、圧縮作業がプロセス全体を遅くすることや、高いレイテンシーを導入することを防ぐことができる。

#### maxcomprate
プロセスごとの入力圧縮率を&lt;number&gt;キロバイト/秒に設定する。各ストリームについて、最大値に達した場合、ストリーム中に圧縮レベルが下がる。ストリームの開始時に最大値に達した場合、ストリームは全く圧縮されない。最大値に達していない場合、圧縮レベルはtune.comp.maxlevelまで増加する。ゼロの値は制限がないことを意味し、これがデフォルト値である。

#### maxconn
プロセスごとの同時接続の最大数を&lt;number&gt;に設定する。これはコマンドライン引数「-n」と同等である。コマンドライン引数「-n」で提供される値は、グローバルセクションで設定されたmaxconn値よりも優先される。Haproxyプロセスはまた、SYSTEM_MAXCONNコンパイル時変数でコンパイルされる可能性があり、この場合、システムmaxconn最大値として提供される。再び、コマンドライン「-n」引数は、設定されている場合、実行時にSYSTEM_MAXCONN制限をバイパスすることを許可する。maxconnに達すると、プロキシは接続の受け入れを停止する。プロセスのソフトファイル記述子制限（「ulimit -n」コマンドで取得可能）は、提供されたmaxconnに従って自動的に調整される。「ulimit-n」も参照。注意：「select」ポーラーは一部のプラットフォームで1024ファイル記述子を超えて信頼性を持って使用できない。プラットフォームがselectのみをサポートし、起動時に「select FAILED」を報告する場合、動作するまでmaxconnを減らす必要がある（一般的に500未満）。maxconn値が設定されていない場合、現在のファイル記述子制限に基づいて自動的に計算される（「ulimit -nH」コマンドによって報告される）。最大値はハード値とソフト値の間で取られる。その後、自動値は「fd-hard-limit」とメモリ制限によって減らされる可能性がある（後者が「-m」コマンドラインオプションで強制された場合）。自動値はまた、バッファサイズ、圧縮に割り当てられたメモリ、SSLキャッシュサイズ、およびSSLの使用または非使用と関連するmaxsslconn（これも自動である可能性がある）に依存する。

#### maxconnrate
プロセスごとの1秒あたりの接続数を&lt;number&gt;に設定する。この制限に達すると、プロキシは接続の受け入れを停止する。これは各フロントエンドの容量に関係なく、グローバル容量を制限するために使用できる。これはサービス保護措置としてのみ使用できることに注意することが重要である。制限に達した場合、フロントエンド間で公平な共有が必ずしもないため、各フロントエンドも期待される共有に近い値に制限することも良いアイデアである。また、tune.maxacceptを下げることで公平性を改善できる。

#### maxpipes
プロセスごとのパイプの最大数を&lt;number&gt;に設定する。現在、パイプはカーネルベースのTCPスプライシングでのみ使用される。パイプには2つのファイル記述子が含まれるため、「ulimit-n」値はそれに応じて増加される。デフォルト値はmaxconn/4であり、これはほとんどの重い使用に対して十分以上であるように見える。スプライスコードは動的にパイプを割り当てて解放し、標準コピーにフォールバックできるため、この値を低く設定しすぎると、パフォーマンスにのみ影響する可能性がある。

#### maxsessrate
プロセスごとの1秒あたりのセッション数を&lt;number&gt;に設定する。この制限に達すると、プロキシは接続の受け入れを停止する。これは各フロントエンドの容量に関係なく、グローバル容量を制限するために使用できる。これはサービス保護措置としてのみ使用できることに注意することが重要である。制限に達した場合、フロントエンド間で公平な共有が必ずしもないため、各フロントエンドも期待される共有に近い値に制限することも良いアイデアである。また、tune.maxacceptを下げることで公平性を改善できる。

#### maxsslconn
プロセスごとの同時SSL接続の最大数を&lt;number&gt;に設定する。デフォルトではSSL固有の制限はない。これは、グローバルmaxconn設定がすべての接続に適用されることを意味する。この制限を設定すると、opensslが過度のメモリを使用し、mallocがNULLを返したときにクラッシュすることを避けることができる（残念ながら、そのような条件を信頼性を持ってチェックしないため）。制限は入ってくる接続と出て行く接続の両方に適用されることに注意すること。そのため、復号化されてから暗号化される1つの接続は2つのSSL接続としてカウントされる。この値が設定されていないが、メモリ制限が強制されている場合、この値はメモリ制限、maxconn、バッファサイズ、圧縮に割り当てられたメモリ、SSLキャッシュサイズ、およびフロントエンド、バックエンド、またはその両方でのSSLの使用に基づいて自動的に計算される。メモリ制限がある場合にmaxconnもmaxsslconnも指定されていない場合、HAProxyは自動的にこれらの値を調整し、100%の接続をリスクなくSSL経由で行えるようにし、有効になっている側（フロントエンド、バックエンド、その両方）を考慮する。

#### maxsslrate
プロセスごとの1秒あたりのSSLセッション数を&lt;number&gt;に設定する。この制限に達すると、SSLリスナーは接続の受け入れを停止する。これは各フロントエンドの容量に関係なく、グローバルSSL CPU使用率を制限するために使用できる。これはサービス保護措置としてのみ使用できることに注意することが重要である。制限に達した場合、フロントエンド間で公平な共有が必ずしもないため、各フロントエンドも期待される共有に近い値に制限することも良いアイデアである。また、セッションはSSLスタックに入る前にカウントされ、後ではないことにも注意することが重要である。これにより、悪いハンドシェイクからスタックを保護することもできる。また、tune.maxacceptを下げることで公平性を改善できる。

#### maxzlibmem
zlibが使用できるプロセスごとのRAMの最大量をメガバイトで設定する。最大量に達すると、RAMが利用できない限り、将来のストリームは圧縮されない。0に設定すると、制限がない。デフォルト値は0である。値はUNIXソケットで「show info」の「MaxZlibMemUsage」行でバイト単位で利用可能であり、zlibによって使用されるメモリは「ZlibMemUsage」でバイト単位である。

#### ssl-default-bind-ciphers
SSL/TLS接続で使用されるデフォルトの暗号スイートを設定する。この設定は、bind行で暗号スイートが指定されていない場合に適用される。OpenSSLの暗号スイート名の形式を使用する。デフォルト値は「ALL:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA」である。

#### ssl-default-bind-options
SSL/TLS接続で使用されるデフォルトのオプションを設定する。この設定は、bind行でオプションが指定されていない場合に適用される。利用可能なオプションは「no-sslv3」、「no-tlsv1」、「no-tlsv1.1」、「no-tlsv1.2」、「no-tlsv1.3」である。デフォルト値は「no-sslv3」である。

#### ssl-engine
暗号化操作に使用されるOpenSSLエンジンを設定する。エンジン名は、OpenSSLがサポートするエンジンの名前である必要がある。「ALL」の値は、すべての暗号化操作にエンジンを使用する。アルゴリズムのリストが指定されていない場合、「ALL」の値が使用される。異なるアルゴリズムのカンマ区切りのリストを指定でき、RSA、DSA、DH、EC、RAND、CIPHERS、DIGESTS、PKEY、PKEY_CRYPTO、PKEY_ASN1を含む。これはOpenSSL設定ファイルが使用するのと同じ形式である。

HAProxy Version 2.6は、デフォルトビルドでエンジンのサポートを無効にした。このオプションは、HAProxyがそのサポートでビルドされた場合にのみ利用可能である。ssl-engineが必要な場合、HAProxyはUSE_ENGINE=1フラグで再ビルドできる。

#### ssl-mode-async
SSLコンテキストにSSL_MODE_ASYNCモードを追加する。これは、非同期対応SSLエンジンが使用される場合に非同期TLS I/O操作を有効にする。現在の実装は最大32エンジンをサポートする。OpenSSL ASYNC APIは読み取り/書き込みバッファの移動をサポートせず、HAProxyのバッファ管理に準拠していない。そのため、非同期モードは読み取り/書き込み操作で無効になる（初期ハンドシェイクと再ネゴシエーションハンドシェイク中にのみ有効になる）。

#### tune.applet.zero-copy-forwarding
アプレットのデータのゼロコピーフォワーディングを有効（'on'）または無効（'off'）にする。デフォルトで有効である。

#### tune.buffers.limit
プロセスごとに割り当て可能なバッファの数にハード制限を設定する。デフォルト値は0で、これは無制限を意味する。制限は、ユーザーが複雑な計算を実行する必要がないように、緊急事態用の予約バッファを満たすために自動的に再調整される。この値を強制することは、プロセスが取得するメモリの量を制限しながら、健全な動作を維持するのに特に有用である可能性がある。この制限に達すると、バッファを要求するタスクは、別のバッファが最初に解放されるまで待機する。ほとんどの場合、待機時間は非常に短く、制限が妥当なままである限り、知覚されない。しかし、いくつかの歴史的な制限がバージョンにわたってこのメカニズムを弱体化させており、持続的な不足の特定の状況では、一部のタスクがタイムアウトが期限切れになるまでフリーズする可能性があることが知られているため、厳密に必要でない場合はこれを使用しない方が安全である。

#### tune.buffers.reserve
メモリ割り当ての失敗によるメモリ不足状態でのみ使用するために事前割り当てされ予約される、スレッドごとのバッファの数を設定する。最小値は0で、デフォルトは4である。ユーザーがこの値を変更したい理由はない。コア開発者が非常に特定の理由で変更することを提案しない限り。

#### tune.bufsize
バッファサイズをこのサイズ（バイト単位）に設定する。低い値により、同じ量のRAMでより多くのストリームが共存でき、高い値により、非常に大きなクッキーを持つ一部のアプリケーションが動作する。デフォルト値は16384で、ビルド時に変更できる。非常に低い値は統計などの一部のサービスを破壊し、デフォルトサイズより大きい値はメモリ使用量を増加させ、システムがメモリ不足になる可能性があるため、デフォルト値からこれを変更しないことを強く推奨する。少なくとも、グローバルmaxconnパラメータは、これが増加するのと同じ係数で減少されるべきである。さらに、HTTP/2の使用は、この値が16384以上でなければならないことを要求する。HTTPリクエストが（tune.bufsize - tune.maxrewrite）より大きい場合、HAProxyはHTTP 400（Bad Request）エラーを返す。同様に、HTTPレスポンスがこのサイズより大きい場合、HAProxyはHTTP 502（Bad Gateway）を返す。このパラメータで設定された値は、32ビットマシンでは8の次の倍数、64ビットマシンでは16の次の倍数に自動的に切り上げられることに注意すること。

#### tune.bufsize.small
小バッファのサイズをバイト単位で設定する。デフォルト値は1024である。

これらのバッファは、メモリ消費が制約されているが、フルバッファを割り当てる必要がないと思われる特定のコンテキストで使用するように設計されている。しかし、小バッファが不十分な場合、標準サイズバッファに切り替えるために再割り当てが自動的に行われる。

現在、HTTP/3プロトコルでレスポンスヘッダーを発信するためにのみ使用される。

#### tune.comp.maxlevel
最大圧縮レベルを設定する。圧縮レベルは圧縮中のCPU使用量に影響する。この値は圧縮中のCPU使用量に影響する。圧縮を使用する各ストリームは、この値で圧縮アルゴリズムを初期化する。デフォルト値は1である。

#### tune.disable-fast-forward
データの高速フォワーディングを無効にする。これは、ストリームを起動することなく、データを一方の側から他方の側に直接渡すことにより、データフォワーディングを最適化するメカニズムである。このディレクティブにより、この最適化を無効にすることができる。カーネルTCPスプライシングだけでなく、ゼロコピーフォワーディングも無効になることに注意すること。このコマンドは通常の使用を意図したものではなく、一般的に開発者が複雑なデバッグセッションに沿って提案するのみである。この理由により、内部的に実験的としてマークされており、「expose-experimental-directives」がこのディレクティブの前の行に表示される必要があることを意味する。

#### tune.disable-zero-copy-forwarding
データのゼロコピーフォワーディングをグローバルに無効にする。これは、チャンネルのバッファを使用することを避けることにより、データの高速フォワーディングを最適化するメカニズムである。このディレクティブにより、この最適化を無効にすることができる。カーネルTCPスプライシングも無効になることに注意すること。

#### tune.epoll.mask-events
HAProxyの履歴に沿って、Linuxカーネルのepollメカニズムのバグによって引き起こされたいくつかの複雑な問題が発生した。これらは通常、非常にまれで、報告者の環境以外では再現不可能であり、epollを無効にしてpollに切り替えることによってのみ回避できる可能性がある。これは高パフォーマンス環境ではあまり満足のいくものではない。毎回、問題は非常に特定の（そしてまれな）イベントタイプのみに影響し、それらをマスクする機能を提供することは、より受け入れ可能な回避策を構成できる。このオプションは、いくつかの珍しいイベントを静かに無視し、それらを入力（未指定の入ってくるイベントを報告する）に置き換えることにより、この可能性を提供する。効果は、特定の場所での高速エラー処理パスを避け、一般的なパスのみを使用することである。これは、カーネルバグを診断または回避するために専門家が招待されない限り、使用されるべきではない。

オプションは単一の引数を取り、これはマスクされるイベントを指定する各単語のカンマ区切りのリストである。現在サポートされているイベントのリストは：
  - 「err」: EPOLLERRイベントをマスクする
  - 「hup」: EPOLLHUPイベントをマスクする
  - 「rdhup」: EPOLLRDHUPイベントをマスクする

#### tune.events.max-events-at-once
非同期タスクハンドラー（event_hdl APIから）が一度に処理できるイベントの数を設定する。&lt;number&gt;は1から10000の間でなければならない。大きな数は、タスクが中断なしに重い作業を行う結果としてスレッド競合を引き起こす可能性があり、一方で、小さな数は、タスクが実行ごとに十分なイベントを消費できず、イベントプロデューサーに追いつくことができないため、タスクが常に再スケジュールされる結果となる可能性がある。デフォルト値はビルド時に強制される可能性があり、そうでない場合はデフォルトで100になる。

#### tune.fail-alloc
DEBUG_FAIL_ALLOCでコンパイルされているか「-dMfail」で開始されている場合、割り当て試行が失敗する確率のパーセンテージを与える。0（失敗なし）から100（成功なし）の間でなければならない。これは、メモリ失敗が適切に処理されることを確認するためにデバッグし、確実にするのに有用である。設定されていない場合、比率は0である。しかし、コマンドライン「-dMfail」オプションは自動的に1%の失敗率に設定するため、テストのために設定を変更する必要がない。

#### tune.fd.edge-triggered
サポートするFDのエッジトリガーポーリングモードを有効（'on'）または無効（'off'）にする。これは現在epollでのみサポートされている。epoll_ctl()呼び出しの数を大幅に削減し、特定のシナリオでパフォーマンスをわずかに改善する可能性がある。これはまだ実験的であり、バグがまだ存在する場合、フリーズした接続が発生する可能性があり、デフォルトで無効になっている。

#### tune.glitches.kill.cpu-usage
0から100の間の最小CPU使用率を設定し、その時点で、過度に多くのグリッチを示す接続が殺される。これは、グリッチ閾値制限に達した接続に適用される。非常に長い接続がパフォーマンスに影響を与えることなく悪く動作することが多い環境では、それらが害を及ぼさない限り、それらを保持し、CPUが忙しくなり始めた時のみ、そのような接続の殺しを開始することが望ましい場合がある。このパラメータにより、グリッチ閾値に達した接続が、CPU使用率がこのレベル以上である場合に積極的に殺されるが、それ以下の場合は決して殺されないことを指定できる。CPU使用率はスレッドごとに測定されるため、単一の不適切に動作する接続が殺される可能性があることに注意すること。デフォルトはゼロで、グリッチ閾値に達した接続が自動的に殺されることを意味する。経験則として、この値を通常観察されるCPU使用率の2倍、または一般的に観察されるCPU使用率にアイドル時間の半分を加えた値に設定することができる（つまり、CPUが一般的に60%に達する場合、ここで80を設定することは意味がある）。このパラメータは、tune.h2.fe.glitches-thresholdまたはtune.quic.frontend.glitches-thresholdがない場合、効果がない。

#### tune.h1.zero-copy-fwd-recv
H1マルチプレクサーのデータのゼロコピー受信を有効（'on'）または無効（'off'）にする。デフォルトで有効である。

#### tune.h1.zero-copy-fwd-send
H1マルチプレクサーのデータのゼロコピー送信を有効（'on'）または無効（'off'）にする。デフォルトで有効である。

#### tune.h2.be.glitches-threshold
バックエンド接続でのグリッチの数の閾値を設定し、その接続が自動的に殺される。これにより、それらのための明示的なルールを書くことなく、不適切に動作する接続を自動的に殺すことができる。デフォルト値はゼロで、閾値が設定されていないことを示し、イベントが接続を閉じる原因となることはない。一部のH2サーバーが長期間の接続で時々いくつかのグリッチを引き起こす可能性があるため、ここでのゼロ以外の値は、わずかに問題のあるサーバーに影響を与えることなく効果的であるために、おそらく数百または数千であるべきであることに注意すること。また、「tune.glitches.kill.cpu-usage」を使用することにより、CPU使用率が特定のレベルを超えた場合のみ接続を殺すことも可能である。

#### tune.h2.be.initial-window-size
送信接続のHTTP/2初期ウィンドウサイズを設定する。これは、HAProxyからの確認応答を待たずにサーバーが応答できるバイト数である。この設定はペイロードコンテンツのみに影響し、ヘッダーには影響しない。設定されていない場合、tune.h2.initial-window-sizeで設定された共通のデフォルト値が適用される。この値をわずかに増やすことで、より高速なダウンロードを許可したり、サーバーでのCPU使用量を削減したりすることができるが、クライアント間の不公平性を作成することを犠牲にする。tune.h2.be.rxbufを使用する方が良い。これは不公平性を引き起こさない。リソース使用量には影響しない。

#### tune.h2.be.max-concurrent-streams
送信接続（つまり、サーバーへの単一接続での未処理リクエストの数）のHTTP/2最大同時ストリーム数を設定する。設定されていない場合、tune.h2.max-concurrent-streamsで設定されたデフォルトが適用される。デフォルト100より小さい値は、サイトの応答性を改善するが、サーバーへのより多くの確立された接続を維持することを犠牲にする。「http-reuse」設定が「always」に設定されている場合、同じ接続上で多すぎる異なるクライアントを混在させないように、この値を減らすことが推奨される。クライアントが他のクライアントより遅い場合、「head of line blocking」として知られるメカニズムが、接続を共有するすべてのクライアントのダウンロード速度にカスケード効果を引き起こす傾向があるためである（この場合、tune.h2.be.initial-window-sizeを低く保つ）。この値を増やすことは強く推奨されない。一部は低い値（通常1..5）で実行することが最適であると考えるかもしれない。

#### tune.h2.be.rxbuf
送信接続のHTTP/2受信バッファサイズをバイト単位で設定する。このサイズはtune.bufsizeの次の倍数に切り上げられ、データをアップロードするすべてのストリーム（HEADERSとDATAフレームの両方）間で共有される。いずれの場合も、各ストリームに常に1つのバッファが付与され、未使用バッファの7/8はペイロードをダウンロードするストリーム間で共有され、アップロードパフォーマンスを大幅に改善し、http-reuseが「always」に設定されている場合に複数のクライアント間で共有されるバックエンド接続でのhead-of-line blocking（HoL）を回避できる。ストリームごとの広告されたウィンドウは、利用可能なスペースを反映するように自動的に調整されるため、実際にはtune.h2.be.initial-window-sizeに触れる必要はないはずである。すべてのストリームを処理するために必要なサイズより小さい値が設定されている場合、この最小値が使用される。デフォルト値は約1600k（16kBバッファを持つ100ストリーム）である。

#### tune.h2.fe.glitches-threshold
フロントエンド接続でのグリッチの数の閾値を設定し、その接続が自動的に殺される。これにより、それらのための明示的なルールを書くことなく、不適切に動作する接続を自動的に殺すことができる。デフォルト値はゼロで、閾値が設定されていないことを示し、イベントが接続を閉じる原因となることはない。一部のH2クライアントが長期間の接続で時々いくつかのグリッチを引き起こす可能性があるため、ここでのゼロ以外の値は、わずかに問題のあるクライアントに影響を与えることなく効果的であるために、おそらく数百または数千であるべきであることに注意すること。また、「tune.glitches.kill.cpu-usage」を使用することにより、CPU使用率が特定のレベルを超えた場合のみ接続を殺すことも可能である。

#### tune.h2.fe.initial-window-size
受信接続のHTTP/2初期ウィンドウサイズを設定する。これは、HAProxyからの確認応答を待たずにクライアントがアップロードできるバイト数である。この設定はペイロードコンテンツ（つまり、POSTリクエストのボディ）のみに影響し、ヘッダーには影響しない。設定されていない場合、tune.h2.initial-window-sizeで設定された共通のデフォルト値が適用される。この値を増やすことで、より高速なアップロードを許可することができる。デフォルト値はtune.bufsize（16384）に等しく、100msのping時間でストリームあたり少なくとも1.25 Mbpsの帯域幅、1msのping時間で125 Mbpsを許可する。リソース使用量には影響しない。大きすぎる値を使用すると、ページが大きなアップロードと並行してアクセスされる場合、クライアントが応答性の欠如を経験する可能性がある。tune.h2.fe.rxbufを使用する方が良い。これは不公平性を引き起こさない。

#### tune.h2.fe.max-concurrent-streams
受信接続（つまり、クライアントからの単一接続での未処理リクエストの数）のHTTP/2最大同時ストリーム数を設定する。設定されていない場合、tune.h2.max-concurrent-streamsで設定されたデフォルトが適用される。デフォルト100より大きい値は、高レイテンシーネットワーク上の多くの小さなオブジェクトを持つ複雑なサイトのページ読み込み時間をわずかに改善する可能性があるが、クライアントが一度により多くのリソースを割り当てることを許可することにより、より多くのメモリを使用することにもなる可能性がある。100のデフォルト値は一般的に良好で、この値を変更しないことが推奨される。

#### tune.h2.fe.max-total-streams
受信接続で処理されるHTTP/2最大総ストリーム数を設定する。この制限に達すると、HAProxyは優雅なGOAWAYフレームを送信し、保留中のすべてのストリームが閉じられた後に接続を閉じることをクライアントに通知する。実際には、クライアントはこれを受信するとできるだけ早く閉じる傾向があり、次のリクエストのために新しい接続を確立する。これは、クライアントが非常に長い時間接続し続け、ファーム内でいくつかの不均衡を引き起こす状況で時々有用で望ましい。例えば、一部の非常に動的な環境では、負荷の増加に適応するために新しいロードバランサーが動的にインスタンス化され、負荷が下がったら確立された接続を壊すことなく停止されるべきである可能性がある。ここで制限を設定することにより、接続は限られた寿命を持ち、頻繁に更新され、一部は他のノードに確立される可能性があるため、既存のリソースが迅速に解放される。

この制限と上記の「tune.h2.fe.max-concurrent-streams」の間に暗黙の関係があることを理解することが重要である。実際、HAProxyは常に、クライアントとフロントエンドの間で飛行中である可能性のある保留中のストリームを処理することに同意するため、広告された制限は常にmax-concurrent-streamsで設定された値によって自動的に引き上げられ、この値は、非準拠クライアントによる違反が接続の閉鎖につながるハード制限として機能する。したがって、ログから接続ごとのリクエスト数を数える場合、max-total-streamsと（max-total-streams + max-concurrent-streams）の間の任意の数が、クライアントがストリームを作成する速度に応じて観察される可能性がある。

デフォルト値はゼロで、プロトコルによって暗示されるもの（2^30 ~= 10.7億）を超える制限を強制しない。1000程度の値は、ほとんどのクライアントに知覚可能なレイテンシーを引き起こすことなく、既に頻繁な接続更新を引き起こす可能性がある。これを低く設定しすぎると、頻繁なTLS再接続によるCPU使用量の増加、およびページ読み込み時間の増加が発生する可能性がある。一部の負荷テストツールは再接続をサポートせず、この設定でエラーを報告する可能性があることに注意すること。そのため、パフォーマンスベンチマークを実行する際は無効にする必要がある場合がある。

#### tune.h2.fe.rxbuf
受信接続のHTTP/2受信バッファサイズをバイト単位で設定する。このサイズはtune.bufsizeの次の倍数に切り上げられ、データをアップロードするすべてのストリーム（HEADERSとDATAフレームの両方）間で共有される。いずれの場合も、各ストリームに常に1つのバッファが付与され、未使用バッファの7/8はペイロードをアップロードするストリーム間で共有され、アップロードパフォーマンスを大幅に改善できる。ストリームごとの広告されたウィンドウは、利用可能なスペースを反映するように自動的に調整されるため、実際にはtune.h2.fe.initial-window-sizeに触れる必要はないはずである。すべてのストリームを処理するために必要なサイズより小さい値が設定されている場合、この最小値が使用される。1600k（16kBバッファを持つ100ストリーム）のデフォルト値は、100ms RTTのクライアントで約130 Mbpsのアップロード速度を許可する。

#### tune.h2.header-table-size
HTTP/2動的ヘッダーテーブサイズを設定する。デフォルトは4096バイトで、65536バイトより大きくすることはできない。大きい値は、クライアントの機能に応じて、よりコンパクトなリクエストを送信するのに役立つ場合がある。このメモリ量は各HTTP/2接続で消費される。これを変更しないことが推奨される。

#### tune.h2.initial-window-size
受信接続と送信接続の両方のHTTP/2初期ウィンドウサイズのデフォルト値を設定する。この値は、tune.h2.fe.initial-window-sizeが設定されていない場合の受信接続、およびtune.h2.be.initial-window-sizeが設定されていない場合の送信接続で使用される。この設定は初期値とストリームごとの最小値の両方として使用される。デフォルト値は16384（tune.bufsize）に等しく、アップロードでは100msのping時間を示すネットワーク上でストリームあたり少なくとも1.25 Mbpsの帯域幅、または1msのローカルネットワーク上で125 Mbpsを許可する。最大値より少ない受信バッファが使用されている場合、tune.h2.be.rxbufとtune.h2.fe.rxbufで定義された制限内で、未使用バッファは受信ストリーム間で共有される。そのため、通常、このデフォルト設定を変更する理由はない。このデフォルト値を変更すると、アップロード速度が向上し、ダウンロードでのクライアント間の不公平性が増加するため、代わりに側固有の設定tune.h2.fe.initial-window-sizeとtune.h2.be.initial-window-sizeを使用することが推奨される。

#### tune.h2.max-concurrent-streams
接続ごとのHTTP/2最大同時ストリーム数（つまり、単一接続での未処理リクエストの数）のデフォルト値を設定する。この値は、tune.h2.fe.max-concurrent-streamsが設定されていない場合の受信接続、およびtune.h2.be.max-concurrent-streamsが設定されていない場合の送信接続で使用される。デフォルト値は100である。影響は側によって異なるため、詳細については上記の2つの設定を参照すること。この設定を使用せず、代わりに側固有の設定に切り替えることが推奨される。ゼロの値は制限を無効にし、単一のクライアントがHAProxyによって割り当て可能な限り多くのストリームを作成できるようにする。この値を変更しないことが強く推奨される。

#### tune.h2.max-frame-size
HAProxyがピアに受信する意思があることを通知するHTTP/2最大フレームサイズを設定する。デフォルト値は16384とバッファサイズ（tune.bufsize）の大きい方である。いずれの場合も、HAProxyはバッファより大きいフレームサイズのサポートを通知しない。この設定の主な目的は、大きなバッファを使用する際に最大フレームサイズ設定を制限することである。大きすぎるフレームサイズはパフォーマンスに影響を与えるか、一部のピアの不適切な動作を引き起こす可能性がある。この値を変更しないことが強く推奨される。

#### tune.h2.zero-copy-fwd-send
H2マルチプレクサーのデータのゼロコピー送信を有効（'on'）または無効（'off'）にする。デフォルトで有効である。

#### tune.http.cookielen
キャプチャされたクッキーの最大長を設定する。これは「capture cookie xxx len yyy」が取ることが許可される最大値であり、上限値は自動的にこれに切り詰められる。すべてのクッキーキャプチャが設定値に関係なくこのサイズを割り当てるため（それらは同じプールを共有する）、高すぎる値を設定しないことが重要である。この値はリクエストごとレスポンスごとであるため、割り当てられるメモリは接続ごとにこの値の2倍である。指定されていない場合、制限は63文字に設定される。この値を変更しないことが推奨される。

#### tune.http.logurilen
ログでのリクエストURIの最大長を設定する。これにより、ログ行で貴重なクエリ文字列を持つ長いリクエストURIの切り詰めを防ぐ。これはsyslog制限とは関係ない。この制限を増やす場合、「log ... len yyy」パラメータも増やすことができる。syslogデーモンも特定の設定ディレクティブを必要とする場合がある。
デフォルト値は1024である。

#### tune.http.maxhdr
受信HTTPメッセージで許可されるヘッダーの最大数を設定する。メッセージがこの値より多くのヘッダー（最初の行を含む）で来る場合、リクエストの場合は「400 Bad Request」ステータスコード、レスポンスの場合は「502 Bad Gateway」で拒否される。デフォルト値は101で、広く展開されているApacheサーバーが同じ制限を使用することを考慮すると、すべての使用に十分である。バグのあるアプリケーションが修正されるまでの間、一時的に動作することを許可するために、この制限をさらに押し上げることが有用である場合がある。受け入れられる範囲は1..32767である。各新しいヘッダーが各ストリームで32ビットのメモリを消費することを覚えておき、この制限を高く押し上げすぎないこと。

HTTP/1.1はテキストプロトコルであるため、メッセージが送信される際に特別な制限はないことに注意すること。メッセージ解析中の制限で十分である。HTTP/2とHTTP/3はバイナリプロトコルであり、エンコーディングステップを必要とする。ヘッダーがプロトコルによって課せられた制限に準拠するためにエンコードされる際にも制限が設定される。この制限は十分に大きいが、意図的に文書化されていない。同じ理由で、デコーディングの最初のステップにも同じ制限が適用される。

#### tune.idle-pool.shared
同じサーバーのスレッド間でのアイドル接続プールの共有を有効（'on'）または無効（'off'）にする。デフォルトは、サーバーへの永続接続の数を最小限に抑え、接続再利用率を最適化するために、スレッド間でそれらを共有することである。しかし、HAProxyの接続再利用周りのバグを疑う場合のデバッグを支援するために、複数のスレッド間でのこのアイドルプール共有を強制的に無効にし、このオプションを「off」に強制することが便利である場合がある。デフォルトはonである。高パフォーマンスレベルを達成するために接続再利用に依存するすべてのサーバーで「pool-low-conn」に保守的な値を設定せずにこのオプションを無効にすることは強く推奨されない。そうでなければ、スレッド数が増加するにつれて接続が非常に頻繁に閉じられる可能性がある。

#### tune.idletimer
HAProxyが空のバッファがおそらくアイドルストリームに関連付けられていると考える期間を設定する。これは、大きなデータと小さなデータを交互に転送しながら、一部のパケットサイズを最適に調整するために使用される。splice()を使用するか、SSLで大きなバッファを送信するかの決定は、このパラメータによって調整される。値は0から65535の間のミリ秒単位である。ゼロの値は、HAProxyがアイドルストリームを検出しようとしないことを意味する。デフォルトは1000で、エンドユーザーの一時停止（例：クリックする前にページを読む）を正しく検出すると思われる。この値を変更する理由はないはずである。下記のtune.ssl.maxrecordも確認すること。

#### tune.listener.default-shards
通常、すべての「bind」行は単一のシャード、つまり、プロセスのすべてのスレッドがリッスンする単一のソケットを作成する。多くのスレッドでは、これは非常に効率的ではなく、ポーリング状態の更新やイベントの様々なスレッドへの配布でカーネルに重要なオーバーヘッドを引き起こす可能性さえある。現代のオペレーティングシステムは受信接続のバランシングをサポートしており、これは複数のソケットが同じアドレスとポートにバインドされることを許可し、すべての受信接続をこれらのソケットに均等に配布するメカニズムで構成される。これにより、各スレッドは、バインドされているソケットで待機している接続のみを見る。これにより、カーネル側のオーバーヘッドが大幅に削減され、受信接続パスでのパフォーマンスが向上する。これは通常、HAProxyで「bind」行の「shards」設定を使用して有効になる。これはデフォルトで1に設定され、各リスナーがプロセス内で一意になることを意味する。多くのプロセッサを備えたシステムでは、常にスレッドごとに1つのリスニングソケットを作成するためにデフォルト設定を「by-thread」に変更するか、常にスレッドグループごとに1つのリスニングソケットを作成するために「by-group」に変更することがより便利である場合がある。「by-thread」でのファイル記述子の使用に注意すること。各リスナーはスレッドと同じ数のソケットを必要とするためである。また、一部のオペレーティングシステム（例：FreeBSD）は、同じアドレスで256個以下のソケットに制限される。単一のスレッドグループを含むデフォルト設定では「by-group」は「by-process」と同等のままであることに注意すること。このメカニズムをサポートしないシステムでは、同じソケットの共有にフォールバックする。デフォルトは「by-group」で、複数のバインドをサポートしないシステムまたはソケットファミリーでは「by-process」にフォールバックする。

#### tune.listener.multi-queue
リスナーのマルチキュー受け入れを有効（'on' / 'fair'）または無効（'off'）にする。これは、受信トラフィックを「bind」行が実行を許可されるすべてのスレッドに分散し、それらを自分自身で取得する代わりにする。これにより、より滑らかなトラフィック配布が提供され、特にスレッドが外部アクティビティ（例えば、1つのスレッドと競合するネットワーク割り込み）により不均等に負荷される可能性がある環境で、より良くスケールする。デフォルトモード「on」は、サンプルで接続が少ないスレッドを選択することにより、スレッドの選択を最適化する。接続が長寿命である場合、これはしばしば最良の選択である。すべてのスレッドを忙しく保つことを管理するためである。2番目のモード「fair」は、インスタント負荷レベルに関係なく、すべてのスレッドを循環する。これは短命接続、または最初のモードで負荷の少ないスレッドを見つける確率が低い非常に多くのスレッドを持つマシンにより適している場合がある。最後に、トラブルシューティング、または接続が短命で、オペレーティングシステムが既に十分に良い配布を提供していると推定される状況のために、「off」を使用して再配布メカニズムを強制的に無効にすることができる。デフォルトは「on」である。

#### tune.lua.bool-sample-conversion
HAProxyサンプルオブジェクトがLuaにプッシュされる際にどのように処理されるべきかをHAProxyに明示的に伝える。実際、ネイティブコンバーター、サンプルフェッチ、またはLuaスクリプトからの変数（いくつか名前を付ける）を活用する際、HAProxyは内部smpタイプを同等のLuaタイプに変換する。歴史的な実装により、ブール処理の周りに曖昧さがある。Lua -&gt; HAProxy smp変換を行う際、ブールは適切に保持されるが、HAProxy smp -&gt; Lua変換を行う際、ブールは誤って整数に変換された。これは、ブールを返すサンプルフェッチまたはコンバーターがLuaから活用される際に整数0または1を返すことを意味する。残念ながら、Luaでは、ブールと整数は交換可能ではない。したがって、曖昧さを避けるために、「tune.lua.bool-sample-conversion」を明示的に「normal」（これはより良い一貫性のために歴史的な動作を削除することを意味する）または「pre-3.1-bug」（既存のスクリプトロジックの不適切な動作を防ぐために歴史的な動作を強制する）のいずれかに設定する必要がある。オプションが明示的に設定されておらず、設定からLuaスクリプトが読み込まれる場合、HAProxyは警告を発し、オプションは歴史的な動作と一致するために暗黙的に「pre-3.1-bug」にデフォルト設定される。使用中のLuaスクリプトがブールHAProxyサンプルをブールとして適切に処理していることを確認した後、このオプションを「normal」に設定することが推奨される。

この設定は、考慮されるために、任意の「lua-load」または「lua-load-per-thread」ディレクティブの前に設定される必要がある。そうでなければ無視される。

#### tune.lua.burst-timeout
「burst」実行タイムアウトは任意のLuaハンドラーに適用される。ハンドラーがタイムアウトに達する前に終了またはyieldに失敗した場合、スレッド競合を防ぎ、トラフィックが長時間提供されないことを防ぎ、最終的にウォッチドッグが介入することによるプロセスのクラッシュを防ぐために中止される。yield-cumulativeである他のluaタイムアウトとは異なり、burst-timeoutは単一のlua実行ウィンドウで費やされる時間が設定されたタイムアウトを超えないことを保証する。

ここでyieldするとは、lua実行がcore.(m)sleep()やcore.yield()などのlua-yielding関数への明示的な呼び出し、または自動強制yield（tune.lua.forced-yieldを参照）に従って効果的に中断され、関連するタスクが再スケジュール用に設定されたときに後で再開されることを意味する。すべてのluaハンドラーがyieldできるわけではない。yieldableハンドラーとunyieldableハンドラーの間で区別する必要がある。

yieldableハンドラー（タスク、アクション..）の場合、タイムアウトに達することは「tune.lua.forced-yield」がシステムに対して高すぎる可能性があることを意味し、それを減らすことで状況が改善される可能性があるが、lua関数内のいくつかの重要なポイントで手動yieldを追加することが役立つかどうかをチェックすることも良いアイデアである。また、ハンドラーが中断できない特定のluaライブラリ関数で過度に時間を費やしていることを示す場合もある。

unyieldableハンドラー（luaコンバーター、サンプルフェッチ）の場合、ハンドラーが過度の計算を行っていることを示す場合がある。そのようなハンドラーは、リクエスト実行フローをブロックすることが多いため、リクエスト処理が通過することを許可するために迅速に終了することが期待される。これは不適切な設計から生じる可能性がある。ここでの一般的な解決アプローチは、「tune.lua.forced-yield」を減らすことが役立たないため、速度のためにlua関数をより良く最適化しようとすることである。

このタイムアウトは純粋なLuaランタイムのみをカウントする。Luaがcore.sleepを行う場合、スリープ時間は考慮されない。デフォルトタイムアウトは1000msである。

注意：lua GCサイクルがハンドラーから開始される場合（明示的に要求されるか、luaによってしばらく時間が経過した後に自動的にトリガーされる）、GCサイクル時間も考慮される。

実際、GCサイクル時間を推論する方法はないため、これは飽和システム（GCが追いつくのに苦労し、利用可能な実行ランタイムの大部分を消費する）でいくつかの誤検知を引き起こす可能性がある。そのような場合、以下が解決の手がかりである：

  - スクリプトがluaメモリフットプリントを減らすために最適化できるかどうかをチェックする
  - lua GCパラメータの微調整および/または手動GCサイクルの要求
    （参照： https://www.lua.org/manual/5.4/manual.html#pdf-collectgarbage ）
  - tune.lua.burst-timeoutの増加

値を0に設定すると、この保護が完全に無効になる。

#### tune.lua.forced-yield
このディレクティブは、実行された命令の&lt;number&gt;ごとにLuaエンジンにyieldを強制する。これにより、長いスクリプトを中断し、HAProxyスケジューラーが接続の受け入れやトラフィックの転送などの他のタスクを処理することを許可する。デフォルト値は「lua-load-per-thread」を使用して読み込まれたスクリプトで10000命令、「lua-load」を使用して読み込まれたスクリプトでMAX(500, 10000 / nbthread)命令である（複数のスレッドがグローバルluaロックを競合することによるスレッド競合を作成しないように注意しながら、パフォーマンスのための最適値であることが判明した）。

HAProxyがしばしばいくつかのLuaコードを実行するが、より多くの応答性が必要な場合、この値を下げることができる。Luaコードがかなり長く、その結果がデータを処理するために絶対に必要な場合、&lt;number&gt;を増やすことができるが、マルチスレッドコンテキストで競合を増加させる可能性があるため、値は賢明に設定されるべきである。

#### tune.lua.log.loggers
現在のプロキシに適用可能なロガー（もしあれば）を介してLUAスクリプトの出力のログ記録を有効（'on'）または無効（'off'）にする。

デフォルトは'on'である。

#### tune.lua.log.stderr
LUAスクリプトの出力のstderrを介したログ記録を有効（'on'）または無効（'off'）にする。
'auto'に設定されている場合、以下のいずれかの条件でstderrを介したログ記録が条件付きで'on'になる：

  - tune.lua.log.loggersが'off'に設定されている
  - スクリプトがグローバルロガーのない非プロキシコンテキストで実行される
  - スクリプトがロガーが接続されていないプロキシコンテキストで実行される

有効になっている場合、このログ記録はtune.lua.log.loggersを介して設定されたログ記録に追加されることに注意すること。

デフォルトは'auto'である。

#### tune.lua.maxmem
プロセスごとにLuaが使用できるRAMの最大量をメガバイトで設定する。デフォルトではゼロで、これは無制限を意味する。スクリプトのバグがシステムのメモリ不足につながらないことを確実にするために制限を設定することが重要である。

#### tune.lua.service-timeout
これはLuaサービスの実行タイムアウトである。無限ループを防ぎ、Luaで過度に時間を費やすことを防ぐのに有用である。このタイムアウトは純粋なLuaランタイムのみをカウントする。Luaがスリープを行う場合、スリープは考慮されない。デフォルトタイムアウトは4秒である。

#### tune.lua.session-timeout
これはLuaセッションの実行タイムアウトである。無限ループを防ぎ、Luaで過度に時間を費やすことを防ぐのに有用である。このタイムアウトは純粋なLuaランタイムのみをカウントする。Luaがスリープを行う場合、スリープは考慮されない。デフォルトタイムアウトは4秒である。

#### tune.lua.task-timeout
目的は「tune.lua.session-timeout」と同じであるが、このタイムアウトはタスク専用である。デフォルトでは、タスクがHAProxyの生涯の間生き続ける可能性があるため、このタイムアウトは設定されていない。例えば、サーバーをチェックするために使用されるタスク。

#### tune.max-checks-per-thread
スレッドがアクティブにヘルスチェックを実行するアクティブチェックの数を設定する。この数を超えると、スレッドはアクティブに負荷の少ないスレッドを探してヘルスチェックを実行するか、そのスレッドで実行されているアクティブチェックの数が減少するまでキューに入れる。デフォルト値はゼロで、そのような制限が設定されていないことを意味する。多くのスレッドで非常に多くの高価なチェックを実行する特定の環境で、負荷が不均等に現れ、ヘルスチェックが起動時にランダムにタイムアウトする可能性がある場合に必要になる場合がある。これは通常、古いものよりヘルスチェックで約20倍CPU集約的であるOpenSSL 3.0を使用する場合に発生する。これにより、すべてのスレッド間でヘルスチェック作業を均等化しようとする結果になる。設定の大部分はこのパラメータに触れる必要がない。チェックの実行が遅い場合、低すぎる値がヘルスチェックを大幅に遅くする可能性があることに注意すること。

#### tune.maxaccept
プロセスが他の作業に切り替える前に連続して受け入れることができる最大接続数を設定する。単一プロセスモードでは、高い数値は高接続率でより良いパフォーマンスを与える傾向があったが、マルチキューではもはやそうではない。この値は各リスナーに個別に適用されるため、リスナーがバインドされているプロセスの数が考慮される。この値はデフォルトで4で、最良の結果を示した。古代の設定から大幅に高い値が継承された場合、パフォーマンスを向上させ、応答時間を短縮するため、削除する価値がある可能性がある。マルチプロセスモードでは、リスナーがバインドされているプロセスの数の2倍で除算される。この値を-1に設定すると、制限が完全に無効になる。通常、この値を調整する必要はない。

#### tune.maxpollevents
ポーリングシステムへの呼び出しで一度に処理できるイベントの最大量を設定する。デフォルト値はオペレーティングシステムに適応される。200未満に減らすと、ネットワーク帯域幅を犠牲にしてレイテンシーがわずかに減少し、200を超えて増やすと、レイテンシーをわずかに増加した帯域幅と交換する傾向があることが注目されている。

#### tune.maxrewrite
予約バッファスペースをこのサイズ（バイト単位）に設定する。予約スペースはヘッダーの書き換えまたは追加に使用される。ソケットでの最初の読み取りは、bufsize-maxrewriteを超えて満たされることはない。歴史的に、bufsizeの半分にデフォルト設定されてきたが、追加するヘッダーが大量にあることはまれであるため、これはあまり意味がない。高すぎる設定は大きなリクエストまたはレスポンスの処理を防ぐ。低すぎる設定は、既に大きなリクエストまたはPOSTリクエストへの新しいヘッダーの追加を防ぐ。一般的に、約1024に設定することが賢明である。bufsizeの半分より大きい場合、自動的に調整される。これは、bufsizeを変更する際に心配する必要がないことを意味する。

#### tune.max-rules-at-once
ルールセット評価関数で一度に評価できるルールの最大数を設定する。ただし、yieldをサポートするものに限る。実際、例えば「tcp-request content」や「http-request」ルールの大量の設定を持つ設定を見ることは珍しくない。大量のルールとCPU要求の高いアクション（例：コンテンツで動作するアクション）の組み合わせは、評価が中断されない場合、特定のルールセットからのすべてのルールが同じポーリングループの下で評価されるため、スレッド競合を作成する可能性がある。このオプションは、コンテンツ指向のルールセット（コンテンツ検査により既にyieldをサポートしているもの）について、同じポーリングループの下で&lt;number&gt;を超えるルールが実行されないことを保証する。それは、評価関数にyieldを強制し、次のポーリングループで評価を続行するために戻ってくることを行う。

影響を受けるルールセットは：
 - 「tcp-request content」
 - 「tcp-response content」
 - 「http-request」
 - 「http-response」

デフォルト値は50である。

#### tune.memory.hot-size
スレッドごとのメモリ量を設定する。このメモリはローカルキャッシュでホットに保たれ、他のスレッドによって回復されることはない。このメモリへのアクセスは非常に高速（ロックレス）であり、極端なスレッド競合の下で良好なパフォーマンスレベルを維持するために十分であることが重要である。値はバイト単位で表現され、デフォルト値はビルド時にCONFIG_HAP_POOL_CACHE_SIZEで設定される。これはデフォルトで524288（512 kB）である。大きい値は、特にパフォーマンスプロファイルがメモリ割り当てが非常にストレスを受けていることを示す場合、一部の使用シナリオでパフォーマンスを向上させる可能性がある。経験によると、良い値はCPUコアあたりのL2キャッシュサイズの1倍から2倍の間にある。大きすぎる値は、CPUのL3キャッシュを非効率的に使用することによりパフォーマンスに負の影響を与え、より多くのメモリを消費する。この値を変更しないこと、または小さな増分で進めることが推奨される。スレッドごとのCPUキャッシュを完全に無効にするために、非常に小さな値を使用することは機能する可能性があるが、コマンドラインで「-dMno-cache」を使用する方が良い。

#### tune.notsent-lowat.client
#### tune.notsent-lowat.server
カーネルのソケットごとのバッファリングを調整し、バッファされたデータの量がこの値に測定されたウィンドウサイズを加えたものに等しくなった時点でソケットの送信側が満杯であることを報告する。原則は、ソケットバッファに必要な厳密な最小バイト数と、HAProxyが再び送信しようとする時までに送信されるであろうものに対応する小さなマージンを許可することである。これを低い値（通常tune.bufsizeの周辺）に設定すると、システムバッファでのメモリ消費を大幅に削減し、バッファされたデータのフラッシュによって発生するアプリケーションレベルのレイテンシーを削減できる。これは一般に、それをサポートするシステムでtune.sndbuf.clientとtune.sndbuf.clientより効果的で正確な設定を表す。これは接続ごとに適用され（設定に応じてクライアントからの接続またはサーバーへの接続）、TCP接続でのみ使用される。デフォルトはゼロで、これは無制限を意味する。これはLinuxでのみ利用可能である。

#### tune.pattern.cache-size
パターンルックアップキャッシュのサイズを&lt;number&gt;エントリに設定する。これは以前のルックアップとその結果を思い出させるLRUキャッシュである。これは、ACLとマップで遅いパターンルックアップ、すなわち「sub」、「reg」、「dir」、「dom」、「end」、「bin」マッチメソッドを使用するもの、および大文字小文字を区別しない文字列で使用される。これはパターン式に適用される。これは、特定の行で指定されたすべてのパターンの中でルックアップの結果を記憶できることを意味する。

（設定ファイルから読み込まれたものを含む）。HTTPアクションまたはCLIで更新されたエントリは自動的に無効になる。デフォルトキャッシュサイズは10000エントリに設定されており、そのフットプリントを32ビットシステムではプロセス/スレッドあたり約5 MB、64ビットシステムでは8 MBに制限する。キャッシュはスレッド/プロセスローカルである。このキャッシュでの衝突のリスクは非常に低く、キャッシュサイズを2^64で割った順序である。一般的に、デフォルトキャッシュサイズ10000エントリで1秒あたり10000リクエストの場合、ブルートフォース攻撃が60年後に単一の衝突を引き起こす可能性は1%、6年後は0.1%である。これは、老化したコンポーネントによるメモリ破損のリスクよりもはるかに低いと見なされる。これが受け入れられない場合、このパラメータを0に設定することによりキャッシュを無効にできる。

#### tune.peers.max-updates-at-once
HAProxyがメッセージを送信する際に一度に処理しようとするスティックテーブル更新の最大数を設定する。これらの更新のデータを取得するには、高くスレッド化されたマシンでバインドされていない場合CPU集約的である可能性があるロック操作が必要である。また、古いプロセスと新しいプロセス間の初期バッチ転送中のトラフィックレイテンシーを増加させる可能性がある。逆に、低い値も高いCPUオーバーヘッドを引き起こす可能性があり、完了に時間がかかる。デフォルト値は200で、変更しないことが推奨される。

#### tune.pipesize
カーネルパイプバッファサイズをこのサイズ（バイト単位）に設定する。デフォルトでは、パイプはシステムのデフォルトサイズである。しかし、TCPスプライシングを使用する場合、パイプサイズを増やすことでパフォーマンスが向上する場合がある。特に、パイプが満たされておらず、splice()への多くの呼び出しが実行されることが疑われる場合である。これはカーネルのメモリフットプリントに影響を与えるため、影響が理解されていない場合は変更すべきではない。

#### tune.pool-high-fd-ratio
HAProxyがグローバルに使用できるファイル記述子の最大数に対するファイル記述子の最大数（パーセンテージ）を設定する。これは、接続を再利用できず、新しい接続を作成する必要がある場合に、アイドル接続を殺し始める前に設定される。デフォルトは25（ファイル記述子の4分の1）で、これは大まかに言って、最大フロント接続の半分が背後にアイドル接続を保持できることを意味する。一般的なケースで接続再利用をターゲットにする場合、これ以上のものはおそらく意味がない。

#### tune.pool-low-fd-ratio
HAProxyがグローバルに使用できるファイル記述子の最大数に対するファイル記述子の最大数（パーセンテージ）を設定する。これは、アイドルプールに接続を入れることを停止する前に設定される。デフォルトは20である。

#### tune.pt.zero-copy-forwarding
パススルーマルチプレクサーのデータのゼロコピーフォワーディングを有効（'on'）または無効（'off'）にする。使用するには、カーネルスプライシングも設定される必要がある。デフォルトで有効である。

#### tune.quic.cc-hystart
QUIC接続で使用されるHyStart++（RFC 9406）アルゴリズムを有効（'on'）または無効（'off'）にする。これは、高パケット損失を引き起こす可能性がある輻輳制御アルゴリズムのスロースタート段階の代替として使用される。デフォルトで無効である。

#### tune.quic.cc.cubic.min-losses
Cubic輻輳制御アルゴリズムが損失イベントを本当に考慮するために必要な失われたパケットの数を定義する。通常、任意の損失イベントは輻輳の結果と見なされ、Cubicがより小さなウィンドウから再開するのに十分である。しかし、実験は、損失が輻輳によって全く引き起こされない様々な原因がある可能性があることを示している。これらは単に偽の損失として分類でき、ウィンドウの調整は効果がなく、通信を遅くするだけである。貧弱な無線信号、順序外配信、クライアントでの高CPU使用率によるランダムな遅延、およびシステムタイマーの不正確さが、これの一般的な原因の一部である可能性がある。この設定により、2つのACK間で蓄積された損失の最小数を変更することにより、Cubicを偽の損失に対して少し寛容にすることができる。これは損失イベントと見なされるために必要である。デフォルトは1である。実験的に重要な利点が観察されているが、常に再送信で浪費される帯域幅の悪化、および輻輳リンクの飽和のリスクの増加を伴う。値2は短い期間使用して一部のメトリクスを比較するために使用できる。状況の専門家による事前分析なしに2を超えることは決してない。デフォルトと最小値は1である。常に1を使用すること。

#### tune.quic.disable-tx-pacing
QUIC発信のペーシングサポートを無効にする。ペーシングの目的は、データの発信を滑らかにしてネットワーク損失を減らすことである。ほとんどのシナリオでは、再送信を避けることにより、ネットワークスループットを大幅に改善する。しかし、非常に高い帯域幅/低レイテンシー特性を持つネットワークで、不要な遅延を防ぎ、CPU消費を削減するために、それを非アクティブ化することが有用である場合がある。

「quic-cc-algo」bindオプションも参照すること。

#### tune.quic.disable-udp-gso
UDP GSO発信を無効にする。このカーネル機能により、単一のシステムコールを介して複数のデータグラムを発信できる。これは大きな転送により効率的である。開発者の提案で、発信で問題が疑われる場合に無効にすることが有用である場合がある。

#### tune.quic.frontend.glitches-threshold
フロントエンド接続でのグリッチの数の閾値を設定し、その接続が自動的に殺される。これにより、それらのための明示的なルールを書くことなく、不適切に動作する接続を自動的に殺すことができる。デフォルト値はゼロで、閾値が設定されていないことを示し、イベントが接続を閉じる原因となることはない。一部のQUICクライアントが長期間の接続で時々いくつかのグリッチを引き起こす可能性があるため、ここでのゼロ以外の値は、わずかに問題のあるクライアントに影響を与えることなく効果的であるために、おそらく数百または数千であるべきであることに注意すること。また、「tune.glitches.kill.cpu-usage」を使用することにより、CPU使用率が特定のレベルを超えた場合のみ接続を殺すことも可能である。

#### tune.quic.frontend.max-data-size
QUICフロントエンド接続で飛行中のデータバイト数のハード制限である。これはinitial_max_dataトランスポートパラメータの値として再利用される。これは、レイテンシーとピアあたりの接続メモリ消費に直接影響する。デフォルトでは、値は0に設定されており、これはmax-streams-bidiとbufsizeの積として自動的に生成される必要があることを示す。例えば、高レイテンシーネットワーク上の大規模アップロードに依存するバックエンドアプリケーションの場合、これを増やすことが有用である場合がある。

#### tune.quic.frontend.max-idle-timeout
フロントエンドのQUIC max_idle_timeoutトランスポートパラメータをミリ秒単位で設定する。これは、接続が無音で閉じる期間を決定する。これは、2つのエンドポイントによって発表された2つのmax_idle_timeout値から導出される有効期間の間、非アクティブのままである場合である：
  - 両方がnullでない場合、2つの値の最小値
  - それらの1つのみがnullでない場合、最大値
  - 両方の値がnullの場合、この機能は無効になる

デフォルト値は30000である。

#### tune.quic.frontend.max-streams-bidi
フロントエンドのQUIC initial_max_streams_bidiトランスポートパラメータを設定する。これは、リモートピアが開くことを許可される双方向ストリームの初期最大数である。これは同時クライアントリクエストの数を決定する。

デフォルト値は100である。これを減らす場合、受信でのストリームのバッファリング機能を制限し、アップロードスループットが悪い結果になる可能性があることに注意すること。tune.quic.frontend.max-data-size設定を増やすことにより修正できる。

#### tune.quic.frontend.max-tx-mem
トランスポート層でのQUICスタックが発信用に使用できるメモリの最大量を設定する。これは飛行中のバイトとマルチプレクサー出力バッファの両方の制限として機能する。スレッド競合を防ぐために、この制限は厳密に強制されないことに注意すること。そのため、一部の機会に超過する可能性がある。また、各接続は常に少なくとも2データグラムのウィンドウを使用できるため、適切なmaxconnが併用されるべきである。

#### tune.quic.frontend.stream-data-ratio
各ストリームでの飛行中のデータバイト数のハード制限を設定する。これは「tune.quic.frontend.max-data-size」設定に対するパーセンテージとして表現され、結果はbufsizeに切り上げられる。

デフォルト値は90である。これは、アップロードが1つまたは少数のストリームでのみ実行され、残りがダウンロード専用に使用される最も頻繁なWebシナリオに適している。max-data-size接続制限が妥当なレベルに保たれる場合、開かれたストリームの一部のみが最大容量に割り当てられることを確実にする。

多くのアップロードストリームを並行して使用し、これらのストリーム間の不公平性に苦しむアプリケーションの場合、この比率を減らすことで、不公平性を増加させ、ストリームごとの帯域幅を削減することができる。

#### tune.quic.frontend.default-max-window-size
単一QUIC接続の輻輳制御のデフォルト最大ウィンドウサイズを設定する。値は整数で書かれ、オプションのサフィックス'k'、'm'または'g'を持つ必要がある。10kから4gの間でなければならない。

QUICマルチプレクサーはまた、データ発信で新しいストリームバッファを割り当てできるかどうかを決定するために現在の輻輳ウィンドウサイズを使用する。そのため、最大輻輳ウィンドウサイズはまた、このアロケーターの制限としても機能する。

デフォルト値は480kである。

「quic-cc-algo」bindオプションも参照すること。

#### tune.quic.max-frame-loss
単一QUICフレームが失われたとマークされる制限を設定する。これを超えると、接続は失敗していると見なされ、即座に閉じられる。

デフォルト値は10である。

#### tune.quic.reorder-ratio
計算されたパケット並び替え閾値に適用される比率。小さすぎる場合、高パケット損失検出をトリガーする可能性がある。

デフォルト値は50である。

#### tune.quic.retry-threshold
この数の半開き接続に達すると、設定されたすべてのQUICリスナーのRetry機能が動的に有効になる。半開き接続は、ハンドシェイクが既に正常に完了または失敗していない接続である。機能的であるために、この設定にはクラスターシークレットが設定される必要がある。そうでなければ静かに無視される（「cluster-secret」設定を参照）。QUIC Retryの使用が強制された場合（「quic-force-retry」を参照）、この設定も静かに無視される。

デフォルト値は100である。

QUIC retryについての詳細はhttps://www.rfc-editor.org/rfc/rfc9000.html#section-8.1.2を参照すること。

#### tune.quic.socket-owner
QUIC接続が受信/送信操作にソケットを使用する方法をグローバルに指定する。接続はリスナーソケットを共有するか、各接続が独自のソケットを割り当てることができる。

デフォルト「connection」値が設定されている場合、すべてのQUIC接続によって専用ソケットが割り当てられる。このオプションは、大量のQUICトラフィックで最高のパフォーマンスを達成するために推奨されるものである。これはまた、QUIC接続とsendto()操作中の一時的なエラーのケースでデータ損失なしにソフトストップが適切に実行されることを確実にする唯一の方法である。しかし、これはUDPネットワークスタックからのいくつかの高度な機能に依存する。プラットフォームが互換性がないと見なされる場合、haproxyは起動時に自動的に「listener」モードに切り替わる。特権ポートで実行されるQUICリスナーは、uid 0として実行するか、ターゲットuidがそのようなポートにバインドすることを許可するOS固有の調整（システム機能など）を必要とする場合があることに注意すること。「setcap」グローバルディレクティブも参照すること。

「listener」値は、QUIC転送が共有リスナーソケットで発生することを示す。このオプションは、小さいトラフィックの良い妥協案である場合がある。FD消費を減らすことを許可するためである。しかし、リスナーが多くのスレッド間で共有されるか、大量のQUIC接続を同時に使用できる場合、パフォーマンスは最適ではなく、より高いCPU使用量が原因である。

この設定は各「quic-socket」bindオプションと組み合わせて適用される。「connection」モードがグローバルチューニングで使用される場合、bindオプションが「listener」に設定されていない限り、各リスナーでアクティブになる。しかし、「listener」がグローバルで使用される場合、個別の設定に関係なく、すべてのリスナーインスタンスで強制される。

#### tune.quic.zero-copy-fwd-send
QUICマルチプレクサーのデータのゼロコピー送信を有効（'on'）または無効（'off'）にする。デフォルトで有効である。

#### tune.renice.runtime
この設定オプションは-20から19の間の値を取る。man 2 setpriorityで文書化されているスケジューリング優先度を適用する。この優先度は設定解析の後に適用される。これは、設定解析を行うプロセス（tune.renice.startup）より高い優先度を設定するために通常設定される。

#### tune.renice.startup
この設定オプションは-20から19の間の値を取る。man 2 setpriorityで文書化されているスケジューリング優先度を適用する。これは設定の残りを適用する前に適用される。設定解析の優先度を下げたい場合に有用である場合がある。これは、スタンドアロンプロセスまたはワーカーで設定解析の前に適用される。設定が解析されると、tune.renice.runtimeが使用されない限り、前の優先度が復元される。

#### tune.rcvbuf.backend
#### tune.rcvbuf.frontend
非接続ソケットでのカーネルソケット受信バッファサイズをこのサイズに強制する。これはフロントエンドでのQUIC in listener modeとlog-forwardに使用できる。デフォルトシステムバッファは時々、大量の集約トラフィックを受信するソケットに対して小さすぎる場合がある。

これにより、一部の損失と可能性として再送信（QUICの場合）が引き起こされ、重いトラフィック下での接続確立が遅くなる可能性がある。値はバイト単位で表現され、各ソケットに適用される。listener modeでは、ソケットはすべての接続間で共有され、ソケットの総数は「bind」行の「shards」値に依存する。良い値はない。良い値は接続あたりの期待サイズに期待接続数を掛けたものに対応する。カーネルは大きい値をトリムする場合がある。「tune.rcvbuf.client」と「tune.rcvbuf.server」で接続ソケットの対応するもの、および送信設定の「tune.sndbuf.backend」と「tune.sndbuf.frontend」も参照すること。

#### tune.rcvbuf.client
#### tune.rcvbuf.server
クライアント側またはサーバー側でのカーネルソケット受信バッファサイズを指定された値（バイト単位）に強制する。この値はすべてのTCP/HTTPフロントエンドとバックエンドに適用される。通常、これは決して設定されるべきではなく、デフォルトサイズ（0）はカーネルが利用可能なメモリの量に応じてこの値を自動調整することを許可する。しかし、時々、非常に低い値（例：4096）に設定して、受信データの過度に大量のバッファリングを防ぐことによりカーネルメモリを節約するのに役立つ場合がある。低い値はCPU使用量を大幅に増加させることに注意すること。

#### tune.recv_enough
短い読み取りがソケットバッファの終わりを示すことを検出するためにHAProxyが使用するヒントの1つを設定する。読み取りが&lt;recv_enough&gt;バイトより多く返すことである。これはデフォルトで10136（1448の7セグメント）に設定される。このデフォルト値は、telnetやSSHセッションなどの多くの短いメッセージを含むワークロードをより良く処理するために、この設定により変更できる場合がある。

#### tune.ring.queues
リングバッファの前の書き込みキューの数を設定する。これは、デバッグセッション中のトレースのCPU使用量に影響を与える可能性がある。低すぎる値または大きすぎる値の両方が重要な効果を持つ可能性がある。良い値は開発者によって実験的に決定され、特定の問題に対処するために指示されない限り、変更する理由はないはずである。そのような設定は、最適値が時間とともに進化する可能性があるため、バージョンアップグレード全体で残されるべきではない。

#### tune.runqueue-depth
タスクを実行する際に一度に処理できるタスクの最大量を設定する。デフォルト値はスレッド数に依存するが、35から280の間で、最高のリクエストレートと最低のレイテンシーを示す傾向がある。それを増やすと、I/Oを扱う際にレイテンシーが発生する可能性がある。小さすぎると、余分なオーバーヘッドが発生する可能性がある。より高いスレッド数は低い値から恩恵を受ける。はるかに大きい値で実験する際は、tune.sched.low-latencyを有効にし、可能であればtune.fd.edge-triggeredを有効にして、レイテンシーを可能な限り最低に制限することが有用である場合がある。

#### tune.sched.low-latency
低レイテンシータスクスケジューラーを有効（'on'）または無効（'off'）にする。デフォルトでは、HAProxyは一度に1つのクラスでタスクを処理する。これが最も効率的であるためである。しかし、tune.runqueue-depthの大きい値で実行する場合、これはリクエストまたは接続レイテンシーに測定可能な効果を持つ可能性がある。この低レイテンシー設定が有効になっている場合、より低い優先度クラスのタスクが存在する場合、常に他のものより前に実行される。これにより、大量のトラフィックの真ん中で新しいリクエストまたは接続が経験する最大レイテンシーを下げることができる。この大量のトラフィックへのより高い影響を犠牲にする。通常の使用では、これをオフのままにしておく方が良い。デフォルト値はオフである。

#### tune.sndbuf.backend
#### tune.sndbuf.frontend
非接続ソケットでのカーネルソケット送信バッファサイズをこのサイズに強制する。これはバックエンド側でのUNIXソケットとUDPログ、およびフロントエンド側でのQUIC in listener modeに使用できる。デフォルトシステムバッファは時々、多くの接続（またはログ送信者）間で共有されるソケットに対して小さすぎる場合がある。これにより、一部の損失と可能性として再送信が引き起こされ、高トラフィック下での新しい接続確立が遅くなる。値はバイト単位で表現され、各ソケットに適用される。listener modeでは、ソケットはすべての接続間で共有され、ソケットの総数は「bind」行の「shards」値に依存する。良い値はない。良い値は接続あたりの期待サイズに期待接続数を掛けたものに対応する。カーネルは大きい値をトリムする場合がある。「tune.sndbuf.client」と「tune.sndbuf.server」で接続ソケットの対応するもの、および送信設定の「tune.rcvbuf.backend」と「tune.rcvbuf.frontend」も参照すること。

#### tune.sndbuf.client
#### tune.sndbuf.server
クライアント側またはサーバー側でのカーネルソケット送信バッファサイズを指定された値（バイト単位）に強制する。この値はすべてのTCP/HTTPフロントエンドとバックエンドに適用される。通常、これは決して設定されるべきではなく、デフォルトサイズ（0）はカーネルが利用可能なメモリの量に応じてこの値を自動調整することを許可する。しかし、時々、非常に低い値（例：4096）に設定して、受信データの過度に大量のバッファリングを防ぐことによりカーネルメモリを節約するのに役立つ場合がある。低い値はCPU使用量を大幅に増加させることに注意すること。もう1つのユースケースは、カーネルがHAProxyに再び通知する前にバッファの大部分が読み取られるのを待つことにより、極端に遅いクライアントによる書き込みタイムアウトを防ぐことである。tune.notsent-lowat.clientとtune.notsent-lowat.serverも参照すること。これらは、パフォーマンスを損なうことなく、Linuxでのメモリ使用量と応答性をより細かく制御するためのより効果的で正確な設定である。

#### tune.ssl.cachesize
グローバルSSLセッションキャッシュのサイズをブロック数で設定する。ブロックは、ピア証明書なしでエンコードされたセッションを含むのに十分に大きい。ピア証明書を持つエンコードされたセッションは、ピア証明書のサイズに応じて複数のブロックに格納される。ブロックは約200バイトのメモリを使用する（`shctx_init`関数で使用される`sizeof(struct sh_ssl_sess_hdr) + SHSESS_BLOCK_MIN_SIZE`計算に基づく）。デフォルト値はビルド時に強制される可能性があり、そうでない場合はデフォルトで20000になる。キャッシュが満杯になると、最もアイドルなエントリがパージされ、再割り当てされる。高い値は、そのようなパージの発生を減らし、すべてのユーザーが可能な限り長くセッションを保持することを確実にすることにより、CPU集約的なSSLハンドシェイクの数を減らす。すべてのエントリは起動時に事前割り当てされる。この値を0に設定すると、SSLセッションキャッシュが無効になる。

#### tune.ssl.capture-buffer-size
クライアントhello暗号リスト、拡張リスト、楕円曲線リスト、楕円曲線ポイントフォーマットのキャプチャに使用されるバッファの最大サイズを設定する。値が0（デフォルト値）の場合、キャプチャは無効になる。そうでなければ、各SSL/TLS接続に対してバッファが割り当てられる。

#### tune.ssl.capture-cipherlist-size
クライアントhello暗号リスト、拡張リスト、楕円曲線リスト、楕円曲線ポイントフォーマットのキャプチャに使用されるバッファの最大サイズを設定する。値が0（デフォルト値）の場合、キャプチャは無効になる。そうでなければ、各SSL/TLS接続に対してバッファが割り当てられる。

#### tune.ssl.default-dh-param
DHE鍵交換の場合の一時的/一時的なDiffie-Hellman鍵の生成に使用されるDiffie-Hellmanパラメータの最大サイズを設定する。最終サイズは、サーバーのRSA（またはDSA）鍵のサイズに一致しようとする（例：2048ビットRSA鍵の2048ビット一時DH鍵）。しかし、この最大値を超えることはない。1024またはそれ以上の値のみが許可される。高い値はCPU負荷を増加させ、1024ビットより大きい値はJava 7以前のクライアントによってサポートされない。証明書ファイルで直接、またはssl-dh-param-fileパラメータを使用して静的Diffie-Hellmanパラメータが供給される場合、この値は使用されない。default-dh-paramもssl-dh-param-fileも定義されておらず、特定のフロントエンドのサーバーのPEMファイルが独自のDHパラメータを指定していない場合、そのフロントエンドでDHE暗号は利用できない。

#### tune.ssl.force-private-cache
すべてのプロセス間でのSSLセッションキャッシュの共有を無効にする。これは通常使用されるべきではない。

クライアントがランダムなプロセスにヒットするため、多くの再ネゴシエーションを強制するためである。しかし、SSLキャッシュ同期方法のいずれも使用できない一部のオペレーティングシステムで必要になる場合がある。この場合、SSL層の前にハッシュベースのロードバランシングの最初の層を追加することにより、セッション共有の欠如の影響を制限できる場合がある。

#### tune.ssl.hard-maxrecord
任意の時点でSSL_write()に渡されるバイトの最大量を設定する。デフォルト値0は制限がないことを意味する。tune.ssl.maxrecordとは対照的に、この設定は動的に調整されない。小さいレコードはスループットを減少させる可能性があるが、低フットプリントクライアントを扱う際に必要になる場合がある。

#### tune.ssl.keylog
TLS鍵のログ記録をアクティブにする。これは注意して使用されるべきである。SSLセッションごとにメモリをより多く消費し、パフォーマンスを低下させる可能性があるためである。デフォルトで無効である。

これらのサンプルフェッチは、wiresharkでトラフィックを解読するために必要なSSLKEYLOGFILEを生成するために使用されるべきである。

https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format

SSLKEYLOGは、この方法でフォーマットされた一連の行である：

  &lt;Label&gt; &lt;space&gt; &lt;ClientRandom&gt; &lt;space&gt; &lt;Secret&gt;

ClientRandomは%[ssl_fc_client_random,hex]サンプルフェッチによって提供され、secretとLabelは以下の配列で見つけることができる。この配列のすべてのラベルを持つSSLKEYLOGFILEを生成する必要がある。

以下のサンプルフェッチは16進文字列で、変換する必要がない。

SSLKEYLOGFILE Label             |  Secrets用のサンプルフェッチ
--------------------------------|-----------------------------------------
CLIENT_EARLY_TRAFFIC_SECRET     |  %[ssl_xx_client_early_traffic_secret]
CLIENT_HANDSHAKE_TRAFFIC_SECRET |  %[ssl_xx_client_handshake_traffic_secret]
SERVER_HANDSHAKE_TRAFFIC_SECRET |  %[ssl_xx_server_handshake_traffic_secret]
CLIENT_TRAFFIC_SECRET_0         |  %[ssl_xx_client_traffic_secret_0]
SERVER_TRAFFIC_SECRET_0         |  %[ssl_xx_server_traffic_secret_0]
EXPORTER_SECRET                 |  %[ssl_xx_exporter_secret]
EARLY_EXPORTER_SECRET           |  %[ssl_xx_early_exporter_secret]

これらのフェッチはフロントエンド（fc）またはバックエンド（bc）側に存在する。「xx」を「fc」または「bc」に置き換えて正しい側を使用すること。

これはOpenSSL 1.1.1でのみ利用可能で、TLS1.3セッションで有用である。

TLS &lt; 1.3でSSLKEYLOGFILEの内容を生成したい場合、この行のみが必要である：

「CLIENT_RANDOM %[ssl_fc_client_random,hex] %[ssl_fc_session_key,hex]」

完全なkeylogは、syslogには理想的ではないが、この方法でlog-formatで生成できる：

  log-format "CLIENT_EARLY_TRAFFIC_SECRET %[ssl_bc_client_random,hex] %[ssl_bc_client_early_traffic_secret]\n
              CLIENT_HANDSHAKE_TRAFFIC_SECRET %[ssl_bc_client_random,hex] %[ssl_bc_client_handshake_traffic_secret]\n
              SERVER_HANDSHAKE_TRAFFIC_SECRET %[ssl_bc_client_random,hex] %[ssl_bc_server_handshake_traffic_secret]\n
              CLIENT_TRAFFIC_SECRET_0 %[ssl_bc_client_random,hex] %[ssl_bc_client_traffic_secret_0]\n
              SERVER_TRAFFIC_SECRET_0 %[ssl_bc_client_random,hex] %[ssl_bc_server_traffic_secret_0]\n
              EXPORTER_SECRET %[ssl_bc_client_random,hex] %[ssl_bc_exporter_secret]\n
              EARLY_EXPORTER_SECRET %[ssl_bc_client_random,hex] %[ssl_bc_early_exporter_secret]"

#### tune.ssl.lifetime
キャッシュされたSSLセッションが有効である可能性がある期間を設定する。この時間は秒単位で表現され、デフォルトで300（5分）である。セッションがその期間続くことを保証しないことを理解することが重要である。キャッシュが満杯であるため、設定された寿命に関係なく、最もアイドルなセッションがパージされる可能性があるためである。この設定の真の有用性は、セッションが長すぎる間使用されることを防ぐことである。

#### tune.ssl.maxrecord
データ転送の開始時にSSL_write()に渡されるバイトの最大量を設定する。デフォルト値0は制限がないことを意味する。SSL/TLS上で、クライアントは完全なレコードを受信した後にのみデータを解読できる。大きいレコードでは、クライアントが処理を開始する前に最大16kBのデータをダウンロードする必要があることを意味する。値を制限すると、高レイテンシーまたは低帯域幅ネットワーク上のブラウザでのページ読み込み時間が改善できる場合がある。1つまたは2つのTCPセグメント（一般にTCPタイムスタンプが有効なイーサネット上で1448バイト、タイムスタンプが無効な場合1460）に収まる最適値を見つけることが推奨される。SSL/TLSがオーバーヘッドを追加することを考慮すること。1419と2859の典型的な値はテスト中に良い結果を与えた。「strace -e trace=write」を使用して最良の値を見つけること。HAProxyはアイドルストリームが検出された後に自動的にこの設定に切り替わる（上記のtune.idletimerを参照）。tune.ssl.hard-maxrecordも参照すること。

#### tune.ssl.ssl-ctx-cache-size
生成された証明書を格納するために使用されるキャッシュのサイズを&lt;number&gt;エントリに設定する。これはLRUキャッシュである。SSL証明書を動的に生成することは高価であるため、キャッシュされる。デフォルトキャッシュサイズは1000エントリに設定される。

#### tune.stick-counters
「track-sc*」アクションを介して「tcp-request」または「http-request」ルールで接続またはリクエストによって同時に追跡できるスティックカウンターの数を設定する。デフォルト値はビルド時にMAX_SESS_STK_CTRマクロによって設定され、デフォルトで3である。この設定により、値を変更し、ビルド時に渡されたものを無視することができる。この値を増やすことは、haproxyへの複雑な設定の移植時に必要になる場合があるが、ユーザーはコストに対して警告される。各エントリは接続ごとに16バイト、リクエストごとに16バイトを取り、使用されない場合でもすべてのリクエストに対して割り当てられ、ゼロ化される必要がある。そのため、10の値はリクエストごとのメモリ消費を320バイト膨らませ、このメモリが各リクエストに対して消去される原因となる。これは測定可能なCPU影響を持つ。逆に、「track-sc」ルールが使用されない場合、値を下げることができる（0は有効でスティックカウンターを完全に無効にする）。

#### tune.takeover-other-tg-connections
デフォルトでは、他のスレッドグループからのアイドル接続を使用しようとはしない。しかし、これは変更できる。有効な値は：「none」（デフォルト）、使用される場合、他のスレッドグループからのアイドル接続を使用しようとはしない。「restricted」、逆httpなどの新しい接続を作成できないプロトコルを使用している場合、およびstrict-maxconnを使用している場合にのみ、他のスレッドからアイドル接続を取得しようとする。「full」、常に他のスレッドグループでアイドル接続を探す。

他のスレッドグループからの接続の使用はパフォーマンスペナルティを引き起こす可能性があることに注意すること。そのため、本当に必要でない限り使用されるべきではない。

#### tune.vars.global-max-size
#### tune.vars.proc-max-size
#### tune.vars.reqres-max-size
#### tune.vars.sess-max-size
#### tune.vars.txn-max-size
これら5つのチューンは、変数システムによって使用されるメモリの最大量を管理するのに役立つ。「global」はすべてのスコープで利用可能なメモリの全体的な量を制限する。「proc」はプロセススコープのメモリを制限し、「sess」はセッションスコープのメモリを制限し、「txn」はトランザクションスコープのメモリを制限し、「reqres」は各リクエストまたはレスポンス処理のメモリを制限する。

メモリアカウンティングは階層的である。より粗い粒度の制限はより細かい粒度の制限を含むことを意味する：「proc」は「sess」を含み、「sess」は「txn」を含み、「txn」は「reqres」を含む。

例えば、「tune.vars.sess-max-size」が100に制限されている場合、「tune.vars.txn-max-size」と「tune.vars.reqres-max-size」も100を超えることはできない。100バイトを含む変数「txn.var」を作成する場合、利用可能なスペースがすべて消費される。

実行時に制限を超えてもエラーメッセージは表示されないが、値が切り詰められたり破損したりする可能性があることに注意すること。そのため、すべての変数を格納するために必要なスペースの量を正確に計画することを確実にすること。

#### tune.zlib.memlevel
各ストリームのzlib初期化のmemLevelパラメータを設定する。内部圧縮状態のために割り当てられるべきメモリの量を定義する。1の値は最小メモリを使用するが遅く、圧縮比を減らす。9の値は最適な速度のために最大メモリを使用する。1から9の間の値であることができる。デフォルト値は8である。

#### tune.zlib.windowsize
各ストリームのzlib初期化のパラメータとしてウィンドウサイズ（履歴バッファのサイズ）を設定する。このパラメータの大きい値は、メモリ使用量を犠牲にしてより良い圧縮をもたらす。8から15の間の値であることができる。デフォルト値は15である。
### 3.3 Debugging

#### anonkey
グローバル匿名化キーを&lt;key&gt;に設定する。&lt;key&gt;は0から4294967295の間の32ビット数でなければならない。これは匿名化モードが有効になっている場合、CLIコマンドがデフォルトで使用するキーである。このキーはまた、CLIコマンド「set anon global-key」から実行時に設定することもできる。管理マニュアルのコマンドライン引数「-dC」も参照。

#### debug.counters
コード内のイベントカウンターの更新を有効（'on'）または無効（'off'）にする。これらはCLIコマンド「debug counters」のタイプ「CNT」の下で報告されるカウンターである。これらのカウンターは、コードがDEBUG_COUNTERSを1以上の値に設定してビルドされた場合にのみ利用可能である。値1では、カウンターはデフォルトで更新されない（「debug.counters off」）。値2では、デフォルトで更新される（「debug.counters on」）。開発者が要求しない限り、または異常な量のCPUを消費していると疑われる場合（その場合、開発者への報告が必要で、カウンターのダンプが必要）、この設定を変更する理由は通常ない。また、「debug counters」CLIコマンドを使用して実行時にこのステータスを変更することもできる。管理マニュアルを参照してください。

#### force-cfg-parser-pause
このコマンドは設定パーサーを&lt;timeout&gt;ミリ秒間一時停止する。これは開発や、特に非常に長いリロードをシミュレートするためのinitスクリプトのタイムアウトのテストに有用である。expose-experimental-directivesが設定されている必要がある。

&lt;timeout&gt;はデフォルトでミリ秒単位で指定されるタイムアウト値であるが、この文書の冒頭で説明されているように、数値に単位が接尾辞として付いている場合、他の任意の単位でもよい。

例：
```
global
    expose-experimental-directives
    force-cfg-parser-pause 10s
```

#### quick-exit
リロード時に古いプロセスの終了を加速する。これはメモリオブジェクトとリスナーの解放をスキップすることにより、これらすべてがプロセスの死でオペレーティングシステムによって回収されるためである。利得は限定的である（最大で巨大な設定に対して数百ミリ秒のオーダー）。実際の主なターゲット使用法は、deinit()コードでバグが発見された場合である。これにより、それをバイパスすることができる。開発者によって指示されない限り、これを使用することは推奨されない。

#### quiet
起動中にメッセージを表示しない。これはコマンドライン引数「-q」と同等である。

#### warn-blocked-traffic-after
トラフィックをブロックしている詰まったタスクが標準エラー出力に警告を発信するまでの遅延を調整することを許可する。遅延はミリ秒で表現され、デフォルトは100ミリ秒である。許可される値は1ミリ秒から1000ミリ秒まで含む必要がある。低い値は警告を頻繁に引き起こし、高い値はめったに引き起こさない。ウォッチドッグは、1秒間に2回応答に失敗する暴走タスクを殺すため、1000ミリ秒の警告遅延は通常警告を引き起こさない。設定異常を検出するために、10から100ミリ秒の間の値に留まることが推奨される。これにより、ユーザーの体験が劣化し、長い応答時間やインタラクティブセッションでのぎこちなさを引き起こす可能性がある。例えば、重い計算を行う不適切に設計されたLuaサンプルフェッチ関数、または非常に高い評価コストを持つ非常に大きなmap_regまたはmap_regmマップファイルがそのような問題を引き起こす可能性がある。比較のために、TLSハンドシェイクは1〜2ミリ秒を消費でき、16kB HTTPレスポンスバッファの圧縮は約1ミリ秒である。出力には、問題のあるタスクのスレッドダンプが含まれ、バックトレースと時間が費やされている場所を理解するのに役立つコンテキストが含まれる。

#### zero-warning
このオプションが設定されている場合、設定の処理と適用中に警告が発信された場合、HAProxyは起動を拒否する。これは、パラメータの悪い組み合わせに関する警告、設定できなかった非常に高い制限に関する警告などが、起動中にエラーでプロセスを終了させることを意味する。いくつかの後期起動警告は、このオプションでキャッチできない。例えば、「daemon」または「master-worker」モードでグループIDを変更する際の補助グループの削除の失敗、またはfork()後のプロセスのダンプ可能マークの失敗などである。このオプションは実行時に発信された警告をキャッチしない。頻繁に変更されない設定では、このオプションを設定することが強く推奨される。これにより、微妙な間違いを検出し、設定をクリーンで前方互換性のある状態に保つことができる。「haproxy -c」もそのような場合にエラーを報告することに注意すること。このオプションはコマンドライン引数「-dW」と同等である。
### 3.4 HTTPClient tuning

HTTPClientは内部HTTPライブラリであり、様々なサブシステムで使用できる。例えばLUAスクリプトで使用される。HTTPClientはデータパスでは使用されない。つまり、HAProxyを通過するHTTPトラフィックとは何の関係もない。

#### httpclient.resolvers.disabled
httpclientのDNS解決を無効にする。「default」resolversセクションの作成を防ぐ。

デフォルト値はoffである。

#### httpclient.resolvers.id
このオプションは、httpclientが解決を試みるresolversセクションを定義する。

デフォルトオプションは「default」resolvers IDである。デフォルトでは、このオプションが使用されていない場合、セクションが見つからない場合は単純に解決を無効にする。

しかし、このオプションが明示的に有効になっている場合、読み込みに失敗すると設定エラーが引き起こされる。

#### httpclient.resolvers.prefer
このオプションは、解決時にどのIPファミリーを選択したいかを選択することを許可する。これはIPv6がネットワークで利用できない場合に便利である。デフォルトオプションは「ipv6」である。

#### httpclient.retries
このオプションは、リクエストが失敗した場合のhttpclientの再試行試行回数を設定することを許可する。これはバックエンドの「retries」キーワードと同じことを行う。

デフォルト値は3である。

#### httpclient.ssl.ca-file
このオプションは、サーバー証明書を検証するために使用されるca-fileを定義する。これはサーバー行の「ca-file」オプションと同じパラメータを取る。

デフォルトでは、このオプションが使用されていない場合、値は「@system-ca」であり、システムのCAを読み込もうとする。失敗した場合、httpclientのSSLは無効になる。

しかし、このオプションが明示的に有効になっている場合、失敗すると設定エラーが引き起こされる。

#### httpclient.ssl.verify
サーバー行のverifyオプションと同じように動作する。'none'に指定された場合、サーバー証明書は検証されない。デフォルトオプションは「required」である。

デフォルトでは、このオプションが使用されていない場合、値は「required」である。失敗した場合、httpclientのSSLは無効になる。

しかし、このオプションが明示的に有効になっている場合、失敗すると設定エラーが引き起こされる。

#### httpclient.timeout.connect
デフォルトでhttpclientの接続試行を待機する最大時間を設定する。

引数：
&lt;timeout&gt;はデフォルトでミリ秒単位で指定されるタイムアウト値であるが、この文書の冒頭で説明されているように、数値に単位が接尾辞として付いている場合、他の任意の単位でもよい。

デフォルト値は5000msである。
## 04. 

詳細については、セクション4の「errorfile」キーワードを参照してください。

**例：**

```http-errors website-1
    errorfile 400 /etc/haproxy/errorfiles/site1/400.http
    errorfile 404 /etc/haproxy/errorfiles/site1/404.http
    errorfile 408 /dev/null  # Chrome pre-connectバグの回避策

http-errors website-2
    errorfile 400 /etc/haproxy/errorfiles/site2/400.http
    errorfile 404 /etc/haproxy/errorfiles/site2/404.http
    errorfile 408 /dev/null  # Chrome pre-connectバグの回避策
```
### 4.1 Proxy keywords matrix

以下のキーワードリストがサポートされている。それらの大部分は限られたセクションタイプでのみ使用される可能性がある。それらの一部は「非推奨」とマークされている。これは古い構文から継承されたもので、混乱を招く可能性があるか、機能的に制限されており、それらを置き換える新しい推奨キーワードが存在するためである。「(*)」でマークされたキーワードは「no」プレフィックスを使用してオプションで反転させることができる。例：「no option contstats」。これは、オプションがデフォルトで有効になっており、特定のインスタンスで無効にする必要がある場合に意味がある。そのようなオプションは、前の「defaults」セクションで指定された内容に関係なく、デフォルト設定を復元するために「default」プレフィックスも付けることができる。「(!)」でマークされたdefaultsセクションでサポートされるキーワードは、名前付きdefaultsセクションでのみサポートされ、匿名のものではサポートされない。

注意：一部の危険で推奨されないディレクティブは、意図的に以下のマトリックスにリストされていない。これは意図的なものである。これらのディレクティブは文書化されている。しかし、以下にリストしないことで、誰もがそれを使用することを思いとどまらせるもう一つの方法である。

| keyword | defaults | frontend | listen | backend |
|---------|----------|----------|---------|---------|
| [acl](#4-acl) | ✓ (!) | ✓ | ✓ | ✓ |
| [backlog](#4-backlog) | ✓ | ✓ | ✓ |  |
| [balance](#4-balance) | ✓ |  | ✓ | ✓ |
| [bind](#4-bind) |  | ✓ | ✓ |  |
| [capture cookie](#4-capture%20cookie) |  | ✓ | ✓ |  |
| [capture request header](#4-capture%20request%20header) |  | ✓ | ✓ |  |
| [capture response header](#4-capture%20response%20header) |  | ✓ | ✓ |  |
| [clitcpka-cnt](#4-clitcpka-cnt) | ✓ | ✓ | ✓ |  |
| [clitcpka-idle](#4-clitcpka-idle) | ✓ | ✓ | ✓ |  |
| [clitcpka-intvl](#4-clitcpka-intvl) | ✓ | ✓ | ✓ |  |
| [compression](#4-compression) | ✓ | ✓ | ✓ | ✓ |
| [cookie](#4-cookie) | ✓ |  | ✓ | ✓ |
| [crt](#4-crt) |  | ✓ | ✓ |  |
| [declare capture](#4-declare%20capture) |  | ✓ | ✓ |  |
| [default-server](#4-default-server) | ✓ |  | ✓ | ✓ |
| [default_backend](#4-default_backend) | ✓ | ✓ | ✓ |  |
| [description](#4-description) |  | ✓ | ✓ | ✓ |
| [disabled](#4-disabled) | ✓ | ✓ | ✓ | ✓ |
| [dispatch](#4-dispatch) |  |  | ✓ | ✓ |
| [email-alert from](#4-email-alert%20from) | ✓ | ✓ | ✓ | ✓ |
| [email-alert level](#4-email-alert%20level) | ✓ | ✓ | ✓ | ✓ |
| [email-alert mailers](#4-email-alert%20mailers) | ✓ | ✓ | ✓ | ✓ |
| [email-alert myhostname](#4-email-alert%20myhostname) | ✓ | ✓ | ✓ | ✓ |
| [email-alert to](#4-email-alert%20to) | ✓ | ✓ | ✓ | ✓ |
| [enabled](#4-enabled) | ✓ | ✓ | ✓ | ✓ |
| [errorfile](#4-errorfile) | ✓ | ✓ | ✓ | ✓ |
| [errorfiles](#4-errorfiles) | ✓ | ✓ | ✓ | ✓ |
| [errorloc](#4-errorloc) | ✓ | ✓ | ✓ | ✓ |
| [errorloc302](#4-errorloc302) | ✓ | ✓ | ✓ | ✓ |
| [errorloc303](#4-errorloc303) | ✓ | ✓ | ✓ | ✓ |
| [error-log-format](#4-error-log-format) | ✓ | ✓ | ✓ |  |
| [force-persist](#4-force-persist) |  |  | ✓ | ✓ |
| [filter](#4-filter) |  | ✓ | ✓ | ✓ |
| [fullconn](#4-fullconn) | ✓ |  | ✓ | ✓ |
| [guid](#4-guid) |  | ✓ | ✓ | ✓ |
| [hash-balance-factor](#4-hash-balance-factor) | ✓ |  | ✓ | ✓ |
| [hash-preserve-affinity](#4-hash-preserve-affinity) | ✓ |  | ✓ | ✓ |
| [hash-type](#4-hash-type) | ✓ |  | ✓ | ✓ |
| [http-after-response](#4-http-after-response) | ✓ (!) | ✓ | ✓ | ✓ |
| [http-check comment](#4-http-check%20comment) | ✓ |  | ✓ | ✓ |
| [http-check connect](#4-http-check%20connect) | ✓ |  | ✓ | ✓ |
| [http-check disable-on-404](#4-http-check%20disable-on-404) | ✓ |  | ✓ | ✓ |
| [http-check expect](#4-http-check%20expect) | ✓ |  | ✓ | ✓ |
| [http-check send](#4-http-check%20send) | ✓ |  | ✓ | ✓ |
| [http-check send-state](#4-http-check%20send-state) | ✓ |  | ✓ | ✓ |
| [http-check set-var](#4-http-check%20set-var) | ✓ |  | ✓ | ✓ |
| [http-check unset-var](#4-http-check%20unset-var) | ✓ |  | ✓ | ✓ |
| [http-error](#4-http-error) | ✓ | ✓ | ✓ | ✓ |
| [http-request](#4-http-request) | ✓ (!) | ✓ | ✓ | ✓ |
| [http-response](#4-http-response) | ✓ (!) | ✓ | ✓ | ✓ |
| [http-reuse](#4-http-reuse) | ✓ |  | ✓ | ✓ |
| [http-send-name-header](#4-http-send-name-header) | ✓ |  | ✓ | ✓ |
| [id](#4-id) |  | ✓ | ✓ | ✓ |
| [ignore-persist](#4-ignore-persist) |  |  | ✓ | ✓ |
| [load-server-state-from-file](#4-load-server-state-from-file) | ✓ |  | ✓ | ✓ |
| [log](#4-log) (*) | ✓ | ✓ | ✓ | ✓ |
| [log-format](#4-log-format) | ✓ | ✓ | ✓ |  |
| [log-format-sd](#4-log-format-sd) | ✓ | ✓ | ✓ |  |
| [log-tag](#4-log-tag) | ✓ | ✓ | ✓ | ✓ |
| [log-steps](#4-log-steps) | ✓ | ✓ | ✓ |  |
| [max-keep-alive-queue](#4-max-keep-alive-queue) | ✓ |  | ✓ | ✓ |
| [max-session-srv-conns](#4-max-session-srv-conns) | ✓ | ✓ | ✓ |  |
| [maxconn](#4-maxconn) | ✓ | ✓ | ✓ |  |
| [mode](#4-mode) | ✓ | ✓ | ✓ | ✓ |
| [monitor fail](#4-monitor%20fail) |  | ✓ | ✓ |  |
| [monitor-uri](#4-monitor-uri) | ✓ | ✓ | ✓ |  |
| [option abortonclose](#4-option%20abortonclose) (*) | ✓ |  | ✓ | ✓ |
| [option allbackups](#4-option%20allbackups) (*) | ✓ |  | ✓ | ✓ |
| [option checkcache](#4-option%20checkcache) (*) | ✓ |  | ✓ | ✓ |
| [option clitcpka](#4-option%20clitcpka) (*) | ✓ | ✓ | ✓ |  |
| [option contstats](#4-option%20contstats) (*) | ✓ | ✓ | ✓ |  |
| [option disable-h2-upgrade](#4-option%20disable-h2-upgrade) (*) | ✓ | ✓ | ✓ |  |
| [option dontlog-normal](#4-option%20dontlog-normal) (*) | ✓ | ✓ | ✓ |  |
| [option dontlognull](#4-option%20dontlognull) (*) | ✓ | ✓ | ✓ |  |
| [option forwardfor](#4-option%20forwardfor) | ✓ | ✓ | ✓ | ✓ |
| [option forwarded](#4-option%20forwarded) (*) | ✓ |  | ✓ | ✓ |
| [option h1-case-adjust-bogus-client](#4-option%20h1-case-adjust-bogus-client) (*) | ✓ | ✓ | ✓ |  |
| [option h1-case-adjust-bogus-server](#4-option%20h1-case-adjust-bogus-server) (*) | ✓ |  | ✓ | ✓ |
| [option http-buffer-request](#4-option%20http-buffer-request) (*) | ✓ | ✓ | ✓ | ✓ |
| [option http-drop-request-trailers](#4-option%20http-drop-request-trailers) (*) | ✓ |  |  | ✓ |
| [option http-drop-response-trailers](#4-option%20http-drop-response-trailers) (*) | ✓ |  | ✓ |  |
| [option http-ignore-probes](#4-option%20http-ignore-probes) (*) | ✓ | ✓ | ✓ |  |
| [option http-keep-alive](#4-option%20http-keep-alive) (*) | ✓ | ✓ | ✓ | ✓ |
| [option http-no-delay](#4-option%20http-no-delay) (*) | ✓ | ✓ | ✓ | ✓ |
| [option http-pretend-keepalive](#4-option%20http-pretend-keepalive) (*) | ✓ |  | ✓ | ✓ |
| [option http-restrict-req-hdr-names](#4-option%20http-restrict-req-hdr-names) | ✓ | ✓ | ✓ | ✓ |
| [option http-server-close](#4-option%20http-server-close) (*) | ✓ | ✓ | ✓ | ✓ |
| [option http-use-proxy-header](#4-option%20http-use-proxy-header) (*) | ✓ | ✓ | ✓ |  |
| [option httpchk](#4-option%20httpchk) | ✓ |  | ✓ | ✓ |
| [option httpclose](#4-option%20httpclose) (*) | ✓ | ✓ | ✓ | ✓ |
| [option httplog](#4-option%20httplog) | ✓ | ✓ | ✓ |  |
| [option httpslog](#4-option%20httpslog) | ✓ | ✓ | ✓ |  |
| [option independent-streams](#4-option%20independent-streams) (*) | ✓ | ✓ | ✓ | ✓ |
| [option ldap-check](#4-option%20ldap-check) | ✓ |  | ✓ | ✓ |
| [option external-check](#4-option%20external-check) | ✓ |  | ✓ | ✓ |
| [option log-health-checks](#4-option%20log-health-checks) (*) | ✓ |  | ✓ | ✓ |
| [option log-separate-errors](#4-option%20log-separate-errors) (*) | ✓ | ✓ | ✓ |  |
| [option logasap](#4-option%20logasap) (*) | ✓ | ✓ | ✓ |  |
| [option mysql-check](#4-option%20mysql-check) | ✓ |  | ✓ | ✓ |
| [option nolinger](#4-option%20nolinger) (*) | ✓ | ✓ | ✓ | ✓ |
| [option originalto](#4-option%20originalto) | ✓ | ✓ | ✓ | ✓ |
| [option persist](#4-option%20persist) (*) | ✓ |  | ✓ | ✓ |
| [option pgsql-check](#4-option%20pgsql-check) | ✓ |  | ✓ | ✓ |
| [option prefer-last-server](#4-option%20prefer-last-server) (*) | ✓ |  | ✓ | ✓ |
| [option redispatch](#4-option%20redispatch) (*) | ✓ |  | ✓ | ✓ |
| [option redis-check](#4-option%20redis-check) | ✓ |  | ✓ | ✓ |
| [option smtpchk](#4-option%20smtpchk) | ✓ |  | ✓ | ✓ |
| [option socket-stats](#4-option%20socket-stats) (*) | ✓ | ✓ | ✓ |  |
| [option splice-auto](#4-option%20splice-auto) (*) | ✓ | ✓ | ✓ | ✓ |
| [option splice-request](#4-option%20splice-request) (*) | ✓ | ✓ | ✓ | ✓ |
| [option splice-response](#4-option%20splice-response) (*) | ✓ | ✓ | ✓ | ✓ |
| [option spop-check](#4-option%20spop-check) | ✓ |  | ✓ | ✓ |
| [option srvtcpka](#4-option%20srvtcpka) (*) | ✓ |  | ✓ | ✓ |
| [option ssl-hello-chk](#4-option%20ssl-hello-chk) | ✓ |  | ✓ | ✓ |
| [option tcp-check](#4-option%20tcp-check) | ✓ |  | ✓ | ✓ |
| [option tcp-smart-accept](#4-option%20tcp-smart-accept) (*) | ✓ | ✓ | ✓ |  |
| [option tcp-smart-connect](#4-option%20tcp-smart-connect) (*) | ✓ |  | ✓ | ✓ |
| [option tcpka](#4-option%20tcpka) | ✓ | ✓ | ✓ | ✓ |
| [option tcplog](#4-option%20tcplog) | ✓ | ✓ | ✓ |  |
| [option transparent](#4-option%20transparent) (*) | ✓ |  | ✓ | ✓ |
| [option idle-close-on-response](#4-option%20idle-close-on-response) (*) | ✓ | ✓ | ✓ |  |
| [external-check command](#4-external-check%20command) | ✓ |  | ✓ | ✓ |
| [external-check path](#4-external-check%20path) | ✓ |  | ✓ | ✓ |
| [persist rdp-cookie](#4-persist%20rdp-cookie) | ✓ |  | ✓ | ✓ |
| [quic-initial](#4-quic-initial) | ✓ (!) | ✓ | ✓ |  |
| [rate-limit sessions](#4-rate-limit%20sessions) | ✓ | ✓ | ✓ |  |
| [redirect](#4-redirect) |  | ✓ | ✓ | ✓ |
| [retries](#4-retries) | ✓ |  | ✓ | ✓ |
| [retry-on](#4-retry-on) | ✓ |  | ✓ | ✓ |
| [server](#4-server) |  |  | ✓ | ✓ |
| [server-state-file-name](#4-server-state-file-name) | ✓ |  | ✓ | ✓ |
| [server-template](#4-server-template) |  |  | ✓ | ✓ |
| [source](#4-source) | ✓ |  | ✓ | ✓ |
| [srvtcpka-cnt](#4-srvtcpka-cnt) | ✓ |  | ✓ | ✓ |
| [srvtcpka-idle](#4-srvtcpka-idle) | ✓ |  | ✓ | ✓ |
| [srvtcpka-intvl](#4-srvtcpka-intvl) | ✓ |  | ✓ | ✓ |
| [stats admin](#4-stats%20admin) |  | ✓ | ✓ | ✓ |
| [stats auth](#4-stats%20auth) | ✓ | ✓ | ✓ | ✓ |
| [stats enable](#4-stats%20enable) | ✓ | ✓ | ✓ | ✓ |
| [stats hide-version](#4-stats%20hide-version) | ✓ | ✓ | ✓ | ✓ |
| [stats http-request](#4-stats%20http-request) |  | ✓ | ✓ | ✓ |
| [stats realm](#4-stats%20realm) | ✓ | ✓ | ✓ | ✓ |
| [stats refresh](#4-stats%20refresh) | ✓ | ✓ | ✓ | ✓ |
| [stats scope](#4-stats%20scope) | ✓ | ✓ | ✓ | ✓ |
| [stats show-desc](#4-stats%20show-desc) | ✓ | ✓ | ✓ | ✓ |
| [stats show-legends](#4-stats%20show-legends) | ✓ | ✓ | ✓ | ✓ |
| [stats show-node](#4-stats%20show-node) | ✓ | ✓ | ✓ | ✓ |
| [stats uri](#4-stats%20uri) | ✓ | ✓ | ✓ | ✓ |
| [stick match](#4-stick%20match) |  |  | ✓ | ✓ |
| [stick on](#4-stick%20on) |  |  | ✓ | ✓ |
| [stick store-request](#4-stick%20store-request) |  |  | ✓ | ✓ |
| [stick store-response](#4-stick%20store-response) |  |  | ✓ | ✓ |
| [stick-table](#4-stick-table) |  | ✓ | ✓ | ✓ |
| [tcp-check comment](#4-tcp-check%20comment) | ✓ |  | ✓ | ✓ |
| [tcp-check connect](#4-tcp-check%20connect) | ✓ |  | ✓ | ✓ |
| [tcp-check expect](#4-tcp-check%20expect) | ✓ |  | ✓ | ✓ |
| [tcp-check send](#4-tcp-check%20send) | ✓ |  | ✓ | ✓ |
| [tcp-check send-lf](#4-tcp-check%20send-lf) | ✓ |  | ✓ | ✓ |
| [tcp-check send-binary](#4-tcp-check%20send-binary) | ✓ |  | ✓ | ✓ |
| [tcp-check send-binary-lf](#4-tcp-check%20send-binary-lf) | ✓ |  | ✓ | ✓ |
| [tcp-check set-var](#4-tcp-check%20set-var) | ✓ |  | ✓ | ✓ |
| [tcp-check unset-var](#4-tcp-check%20unset-var) | ✓ |  | ✓ | ✓ |
| [tcp-request connection](#4-tcp-request%20connection) | ✓ (!) | ✓ | ✓ |  |
| [tcp-request content](#4-tcp-request%20content) | ✓ (!) | ✓ | ✓ | ✓ |
| [tcp-request inspect-delay](#4-tcp-request%20inspect-delay) | ✓ (!) | ✓ | ✓ | ✓ |
| [tcp-request session](#4-tcp-request%20session) | ✓ (!) | ✓ | ✓ |  |
| [tcp-response content](#4-tcp-response%20content) | ✓ (!) |  | ✓ | ✓ |
| [tcp-response inspect-delay](#4-tcp-response%20inspect-delay) | ✓ (!) |  | ✓ | ✓ |
| [timeout check](#4-timeout%20check) | ✓ |  | ✓ | ✓ |
| [timeout client](#4-timeout%20client) | ✓ | ✓ | ✓ |  |
| [timeout client-fin](#4-timeout%20client-fin) | ✓ | ✓ | ✓ |  |
| [timeout client-hs](#4-timeout%20client-hs) | ✓ | ✓ | ✓ |  |
| [timeout connect](#4-timeout%20connect) | ✓ |  | ✓ | ✓ |
| [timeout http-keep-alive](#4-timeout%20http-keep-alive) | ✓ | ✓ | ✓ | ✓ |
| [timeout http-request](#4-timeout%20http-request) | ✓ | ✓ | ✓ | ✓ |
| [timeout queue](#4-timeout%20queue) | ✓ |  | ✓ | ✓ |
| [timeout server](#4-timeout%20server) | ✓ |  | ✓ | ✓ |
| [timeout server-fin](#4-timeout%20server-fin) | ✓ |  | ✓ | ✓ |
| [timeout tarpit](#4-timeout%20tarpit) | ✓ | ✓ | ✓ | ✓ |
| [timeout tunnel](#4-timeout%20tunnel) | ✓ |  | ✓ | ✓ |
| [transparent](#4-transparent) (*) (非推奨) | ✓ |  | ✓ | ✓ |
| [unique-id-format](#4-unique-id-format) | ✓ | ✓ | ✓ |  |
| [unique-id-header](#4-unique-id-header) | ✓ | ✓ | ✓ |  |
| [use_backend](#4-use_backend) |  | ✓ | ✓ |  |
| [use-fcgi-app](#4-use-fcgi-app) |  |  | ✓ | ✓ |
| [use-server](#4-use-server) |  |  | ✓ | ✓ |
### 4.2 

詳細については、セクション4.2の「log」キーワードを参照してください。これはオプション設定である。デフォルトではSTDERRメッセージは無視される。

**pass-header** `&lt;name&gt;` [ `{ if | unless }` `&lt;condition&gt;` ]

リクエストヘッダーの名前を指定する。このヘッダーはFastCGIアプリケーションに渡される。オプションでACLベースの条件が続く場合があり、その場合、条件が真の場合にのみ評価される。

ほとんどのリクエストヘッダーは既にFastCGIアプリケーションで利用可能であり、「HTTP_」プレフィックスが付いている。したがって、このディレクティブは意図的に省略されたヘッダーを渡すためにのみ必要である。現在、「Authorization」、「Proxy-Authorization」、およびホップバイホップヘッダーは省略されている。

「Content-type」と「Content-length」ヘッダーは既にパラメータに変換されているため、FastCGIアプリケーションに渡されることはないことに注意すること。

**path-info** `&lt;regex&gt;`

URLデコードされたパスからスクリプト名とパス情報を抽出するための正規表現を定義する。したがって、`&lt;regex&gt;`は2つのキャプチャを持つことができる：最初のものはスクリプト名をキャプチャし、2番目のものはパス情報をキャプチャする。最初のものは必須であり、2番目のものはオプションである。この方法により、パス情報を無視してパスからスクリプト名を抽出することが可能である。これはオプション設定である。定義されていない場合、パスに対してマッチングは実行されず、FastCGIパラメータPATH_INFOとPATH_TRANSLATEDは設定されない。

セキュリティ上の理由から、この正規表現が定義されている場合、URLデコードされたパスから改行文字とnull文字は禁止されている。この制限の理由は、そうでなければマッチングが常に失敗するためである（HAProxyで正規表現が実行される方法の制限による）。したがって、URLデコードされたパスでこれらの2つの文字のいずれかが見つかった場合、クライアントにエラーが返される。ここでは最小驚きの原則が適用される。

**例：**

```path-info ^(/.+\.php)(/.*)?$ # スクリプト名とパス情報の両方が設定される可能性がある
path-info ^(/.+\.php)        # パス情報は無視される
```

**option get-values**

接続管理に関する変数の取得を有効または無効にする。

HAProxyは接続確立時にFCGI_GET_VALUESレコードを送信して、以下の変数の値を取得することができる：

* FCGI_MAX_REQS     このアプリケーションが受け入れる最大同時リクエスト数。
* FCGI_MPXS_CONNS   「0」はこのアプリケーションが接続の多重化をサポートしない場合、「1」はサポートする場合。

一部のFastCGIアプリケーションはこの機能をサポートしていない。他のアプリケーションは応答を送信した直後に接続を閉じる。したがって、デフォルトではこのオプションは無効になっている。

FastCGIアプリケーションが受け入れる最大同時リクエスト数は接続変数であることに注意すること。これは接続あたりのストリーム数のみを制限する。アプリケーションのグローバル負荷を制限する必要がある場合、「maxconn」と「pool-max-conn」サーバーパラメータを設定する必要がある。さらに、アプリケーションが接続多重化をサポートしていない場合、最大同時リクエスト数は自動的に1に設定される。

**option keep-conn**

FastCGIアプリケーションに応答送信後の接続を開いたままにするかどうかを指示する。

無効にされている場合、FastCGIアプリケーションはこのリクエストに応答した後に接続を閉じる。デフォルトでは、このオプションは有効になっている。

**option max-reqs** `&lt;reqs&gt;`

このアプリケーションが受け入れる最大同時リクエスト数を定義する。

このオプションは、接続確立時に変数FCGI_MAX_REQSが取得された場合に上書きされる可能性がある。さらに、アプリケーションが接続多重化をサポートしていない場合、このオプションは無視される。デフォルトでは1に設定されている。

**option mpxs-conns**

接続多重化のサポートを有効または無効にする。

このオプションは、接続確立時に変数FCGI_MPXS_CONNSが取得された場合に上書きされる可能性がある。デフォルトでは無効になっている。

**set-param** `&lt;name&gt;` `&lt;fmt&gt;` [ `{ if | unless }` `&lt;condition&gt;` ]

このアプリケーションに渡されるべきFastCGIパラメータを設定する。その値は`&lt;fmt&gt;`で定義され、カスタムログ形式ルールに従う必要がある（セクション8.2.6「カスタムログ形式」を参照）。オプションでACLベースの条件が続く場合があり、その場合、条件が真の場合にのみ評価される。

このディレクティブにより、デフォルトのFastCGIパラメータの値を上書きすることが可能である。値が空の文字列に評価される場合、ルールは無視される。これらのディレクティブは宣言順序で評価される。

**例：**

```# PHPのみ、PHPが--enable-force-cgi-redirectでビルドされた場合に必要
set-param REDIRECT_STATUS 200

set-param PHP_AUTH_DIGEST %[req.hdr(Authorization)]
```

### 4.1.2 Proxy section

**use-fcgi-app** `&lt;name&gt;`

バックエンドで使用するFastCGIアプリケーションを定義する。

**引数：**
`&lt;name&gt;`    使用するFastCGIアプリケーションの名前。

このキーワードは、バックエンド機能を持つHTTPプロキシと、少なくとも1つのFastCGIサーバーでのみ利用可能である。しかし、FastCGIサーバーはHTTPサーバーと混在させることができる。ただし、そうする正当な理由がない限り、推奨されない。
### 4.3 

「http-response」ルールセット（セクション4.3を参照）から参照できるカスタムログ形式（セクション8.2.6を参照）で、HTTPヘッダーをキャプチャする推奨方法である。

また、http-requestルールと変数に先行するレガシーメソッドも存在する。これはログ形式の調整を必要とせず、ログ記録とHTTPトランザクション全体にリクエスト情報を伝達する人工的な方法として長い間使用されてきた。これは古い「capture」ルールセットを使用する。これがこのセクションで説明されている内容である。

レガシーヘッダーキャプチャは、フロントエンドの「capture request header」と「capture response header」ステートメントを使用して実行される。それらの詳細については参照すること。
### 4.4 Alphabetically sorted actions reference

このセクションは、各アクションとその使用方法の詳細な説明を提供する。
## 5. Peers設定オプション

**参照:** "server"（peers宣言、rings、アルファベット順ソートされたキーワードリファレンスで利用可能）およびサーバーオプションについての[セクション5](#5)

### enabled

これは、以前に"disabled"キーワードによって無効化されたpeersセクションを再度有効化する。

### log

**log** &lt;target&gt; [len &lt;length&gt;] [format &lt;format&gt;] [sample &lt;ranges&gt;:&lt;sample_size&gt;]  
    &lt;facility&gt; [&lt;level&gt; [&lt;minlevel&gt;]]

"peers"セクションは、プロキシと同様に"log"キーワードをサポートしており、peersリスナーに関する情報をログに記録する。詳細については、プロキシの"log"オプションを参照すること。

### peer

**peer** &lt;peername&gt; [&lt;address&gt;]:port [param*]

**peer** &lt;peername&gt; /&lt;path&gt; [param*]

peersセクション内でピアを定義する。

&lt;peername&gt;がローカルピア名（デフォルトではホスト名、または"-L"コマンドラインオプションまたは"localpeer"グローバル設定で強制）に設定されている場合、HAProxyは提供されたアドレスで着信リモートピア接続を待ち受ける。そうでない場合、アドレスはリモートピアに参加するために接続する場所を定義し、&lt;peername&gt;はプロトコルレベルでサーバー側のリモートピアを識別し検証するために使用される。

ソフトリスタート中、ローカルピアアドレスは古いインスタンスによって新しいインスタンスに接続し、完全な複製（学習プロセス）を開始するために使用される。

すべてのピアで完全に同じpeers宣言を持ち、ローカルピア名の変更には"-L"コマンドライン引数または"localpeer"グローバル設定のみに依存することを強く推奨する。これにより、すべてのピア間で一貫した設定ファイルの保守が容易になる。

アドレスで一部の環境変数を参照したい場合がある。
### 5.1 バッファ内容からのサンプル取得（レイヤー6）

RFC4492で定義された拡張機能、SSL ClientHelloメッセージ内の[セクション5.1](#5.1)。これは、ECC互換クライアントにEC証明書を提示し、他のすべてのクライアントにRSAを使用するために使用できる。同じIPアドレスで。これは、リクエストバッファで見つかった生の内容にのみ適用され、SSLデータレイヤーを介して復号化された内容には適用されないことに注意すること。そのため、これは"ssl"オプションを持つ"bind"行では動作しない。

#### req.ssl_hello_type

**req.ssl_hello_type** : integer

**req_ssl_hello_type** : integer (非推奨)

バッファが完全なSSL（v3以上）クライアントhelloメッセージとして解析されるデータを含む場合、リクエストバッファで見つかったSSL helloメッセージのタイプを含む整数値を返す。これは、リクエストバッファで見つかった生の内容にのみ適用され、SSLデータレイヤーを介して復号化された内容には適用されないことに注意すること。そのため、これは"ssl"オプションを持つ"bind"行では動作しない。これは主にACLで、スティッキネスに使用可能なSSLセッションIDを含むと想定されるSSL helloメッセージの存在を検出するために使用される。

#### req.ssl_keyshare_groups binary

**req.ssl_keyshare_groups binary**

TLS ClientHelloで報告されたクライアントがサポートする鍵交換の暗号パラメータのリストのバイナリ形式を返す。TLS v1.3では、keyshareはClientHelloメッセージの一部であり、最終的なクライアントhello拡張である。これは、リクエストバッファで見つかった生の内容にのみ適用され、SSLデータレイヤーを介して復号化された内容には適用されないことに注意すること。そのため、これは"ssl"オプションを持つ"bind"行では動作しない。

**例:**

```bash
# 最大5秒間クライアントhelloを待機
tcp-request inspect-delay 5s
tcp-request content accept if { req.ssl_hello_type 1 }
use-server fe3 if { req.ssl_keyshare_groups,be2hex(:,2),lower -m sub 001d  }
server fe3  ${htst_fe3_addr}:${htst_fe3_port}
```

#### req.ssl_sigalgs binary

**req.ssl_sigalgs binary**

TLS ClientHelloで報告されたクライアントがサポートする署名アルゴリズムのリストのバイナリ形式を返す。これはクライアントhello拡張として利用可能である。これは、リクエストバッファで見つかった生の内容にのみ適用され、SSLデータレイヤーを介して復号化された内容には適用されないことに注意すること。そのため、これは"ssl"オプションを持つ"bind"行では動作しない。"ssl_fc_sigalgs_bin"を参照すること。これは"ssl"オプションが指定されている場合に使用できるSSL bind相当である。

**例:**

```bash
# 最大5秒間クライアントhelloを待機
tcp-request inspect-delay 5s
tcp-request content accept if { req.ssl_hello_type 1 }
use-server fe4 if { req.ssl_sigalgs,be2hex(:,2),lower -m sub 0403:0805 }
server fe4  ${htst_fe4_addr}:${htst_fe4_port}
```

#### req.ssl_sni

**req.ssl_sni** : string

**req_ssl_sni** : string (非推奨)

リクエストバッファを通過するTLSストリームでクライアントによって送信されたServer Name TLS拡張の値を含む文字列を返す。バッファが完全なSSL（v3以上）クライアントhelloメッセージとして解析されるデータを含む場合。これは、リクエストバッファで見つかった生の内容にのみ適用され、SSLデータレイヤーを介して復号化された内容には適用されないことに注意すること。そのため、これは"ssl"オプションを持つ"bind"行では動作しない。これは実際の暗黙的TLSベースプロトコル（HTTPS（443）、IMAPS（993）、SMTPS（465）など）でのみ動作する。しかし、明示的TLSベースプロトコル（SMTP（25/587）やIMAP（143）など）では動作しない。SNIは通常、クライアントが接続しようとするホストの名前を含む（最近のブラウザの場合）。SNIは、クライアントがSSL/TLSを使用している場合に特定のホストへのアクセスを許可または拒否するのに役立つ。このテストはTCPリクエスト内容検査で使用するために設計されている。内容切り替えが必要な場合、以下の例のように、まず完全なクライアントhello（タイプ1）を待機することを推奨する。"ssl_fc_sni"も参照すること。

ACL派生:
  req.ssl_sni : 完全文字列一致

**例:**

```bash
# 最大5秒間クライアントhelloを待機
tcp-request inspect-delay 5s
tcp-request content accept if { req.ssl_hello_type 1 }
use_backend bk_allow if { req.ssl_sni -f allowed_sites }
default_backend bk_sorry_page
```

#### req.ssl_st_ext

**req.ssl_st_ext** : integer

クライアントがSessionTicket TLS拡張（RFC5077）を送信しなかった場合、0を返す
クライアントがSessionTicket TLS拡張を送信した場合、1を返す
クライアントが非ゼロ長のTLS SessionTicketも送信した場合、2を返す

これは、リクエストバッファで見つかった生の内容にのみ適用され、SSLデータレイヤーを介して復号化された内容には適用されないことに注意すること。そのため、これは"ssl"オプションを持つ"bind"行では動作しない。これは例えば、クライアントがSessionTicketを送信したかどうかを検出し、それに応じてスティックするために使用できる。SessionTicketがない場合、SessionIDでスティックするか、SessionTicketが使用されている場合にサーバー側の状態がないためスティックしない。

#### req.ssl_supported_groups binary

**req.ssl_supported_groups binary**

TLS ClientHelloで報告され、鍵交換に使用されるクライアントがサポートするグループのリストのバイナリ形式を返す。これには楕円曲線と非EC鍵交換の両方が含まれる。これは、リクエストバッファで見つかった生の内容にのみ適用され、SSLデータレイヤーを介して復号化された内容には適用されないことに注意すること。そのため、これは"ssl"オプションを持つ"bind"行では動作しない。"ssl_fc_eclist_bin"を参照すること。これは"ssl"オプションが指定されている場合に使用できるSSL bind相当である。

**例:**

```bash
# 最大5秒間クライアントhelloを待機
tcp-request inspect-delay 5s
tcp-request content accept if { req.ssl_hello_type 1 }
use-server fe3 if { req.ssl_supported_groups, be2hex(:,2),lower -m sub 0017 }
server fe3  ${htst_fe3_addr}:${htst_fe3_port}
```

#### req.ssl_ver

**req.ssl_ver** : integer

**req_ssl_ver** : integer (非推奨)

リクエストバッファに存在するストリームのSSL/TLSプロトコルのバージョンを含む整数値を返す。SSLv2 helloメッセージとSSLv3メッセージの両方がサポートされている。TLSv1はSSLバージョン3.1として発表される。値は、メジャーバージョンに65536を掛けて、マイナーバージョンを加えたもので構成される。これは、リクエストバッファで見つかった生の内容にのみ適用され、SSLデータレイヤーを介して復号化された内容には適用されないことに注意すること。そのため、これは"ssl"オプションを持つ"bind"行では動作しない。テストのACLバージョンは、MAJOR.MINOR形式（例：3.1）の10進表記と一致する。この取得は主にACLで使用される。

ACL派生:
  req.ssl_ver : 10進一致

#### res.len

**res.len** : integer

レスポンスバッファに存在するバイト数に対応する整数値を返す。これは主にACLで使用される。このテストがバッファが変化している限りfalseを返さないことを理解することが重要である。これは、ゼロとの等価性チェックがストリームの開始時にほぼ常に即座に一致することを意味し、より多くのデータのテストはそのデータが入ってくるのを待ち、HAProxyがより多くのデータが入ってこないことが確実な場合にのみfalseを返す。このテストはTCPレスポンス内容検査で使用するために設計されている。しかし、tcp-checkベースのexpectルールでも使用できる。

#### res.payload

**res.payload**(&lt;offset&gt;,&lt;length&gt;) : binary

これは、レスポンスバッファで&lt;offset&gt;バイト目から開始し、&lt;length&gt;バイトのバイナリブロックを抽出する。特別な場合として、&lt;length&gt;引数がゼロの場合、&lt;offset&gt;から最後までのバッファ全体が抽出される。これは、バッファ内の任意の場所で特定の内容の存在をチェックするためにACLで使用できる。また、tcp-checkベースのexpectルールでも使用できる。

#### res.payload_lv

**res.payload_lv**(&lt;offset1&gt;,&lt;length&gt;[,&lt;offset2&gt;]) : binary

これは、サイズが&lt;offset1&gt;で&lt;length&gt;バイトとして指定され、&lt;offset2&gt;が指定されている場合は&lt;offset2&gt;で開始し、そうでない場合は長さの直後で開始するバイナリブロックを抽出する。レスポンスバッファで。&lt;offset2&gt;パラメータは、'+'または'-'記号が前置されている場合、相対オフセットもサポートする。また、tcp-checkベースのexpectルールでも使用できる。

**例:**

"stick store-response"キーワードの例を参照すること。

#### res.ssl_hello_type

**res.ssl_hello_type** : integer

**rep_ssl_hello_type** : integer (非推奨)

バッファが完全なSSL（v3以上）helloメッセージとして解析されるデータを含む場合、レスポンスバッファで見つかったSSL helloメッセージのタイプを含む整数値を返す。これは、レスポンスバッファで見つかった生の内容にのみ適用され、SSLデータレイヤーを介して復号化された内容には適用されないことに注意すること。そのため、これは"ssl"オプションを持つ"server"行では動作しない。これは主にACLで、スティッキネスに使用可能なSSLセッションIDを含むと想定されるSSL helloメッセージの存在を検出するために使用される。
### 5.2 サーバーとデフォルトサーバーオプション

"server"と"default-server"キーワードは、サーバー行で引数として渡される特定の数の設定をサポートする。これらの引数が現れる順序は重要ではなく、すべてオプションである。これらの設定の一部は単語（ブール値）であるが、他の設定は設定名の直後に1つまたは複数の値を期待する。この場合、値は設定名の直後に続く必要がある。default-serverを除いて、これらの設定はすべて、使用される場合はサーバーのアドレスの後に指定する必要がある：

  server &lt;name&gt; &lt;address&gt;[:port] [settings ...]
  default-server [settings ...]

これらの設定はすべて"server"と"default-server"キーワードの両方でサポートされていることに注意すること。ただし、"id"は"server"でのみサポートされている。

現在サポートされている設定は以下の通りである。

#### addr

**addr** &lt;ipv4|ipv6&gt;

以下のコンテキストで使用可能: tcp, http, log

"addr"パラメータを使用することで、ヘルスチェックまたはエージェントチェックを実行するために異なるIPアドレスを使用することが可能になる。一部のサーバーでは、アプリケーションよりもヘルスチェックに適した複雑なテストを実行できる特定のコンポーネントにIPアドレスを専用にすることが望ましい場合がある。このパラメータは"check"パラメータが設定されていない場合は無視される。"port"パラメータも参照すること。

#### agent-check

**agent-check**

以下のコンテキストで使用可能: tcp, http, log

通常のヘルスチェックとは独立して実行される補助エージェントチェックを有効にする。エージェントヘルスチェックは、"agent-port"パラメータで設定されたポートへのTCP接続を作成し、最初に遭遇する'\r'または'\n'で終了するASCII文字列を読み取ることによって実行される。文字列は、任意の順序でスペース、タブ、またはカンマで区切られた一連の単語で構成される：

- 正の整数パーセンテージのASCII表現、例："75%"。この形式の値は、HAProxyが起動時に設定されたサーバーの初期重みに比例して重みを設定する。ゼロ重みは、サーバーに同じ効果があるため（LBファームから削除される）、統計ページで"DRAIN"として報告される。これはサーバーの重みを設定する従来の方法である。"weight:"プレフィックスで設定することが推奨される。

- "weight:"に続く正の整数または正の整数パーセンテージ、スペースなし。値が'%'記号で終わる場合、新しい重みはサーバーの初期重みに比例する。そうでない場合、値は絶対重みと見なされ、0から256の間でなければならない。静的負荷分散アルゴリズムを実行するファームの一部であるサーバーは、重みが一度設定されると変更できないため、より厳格な制限がある。したがって、これらのサーバーでは、受け入れられる値は0と100%（または0と初期重み）のみである。変更は即座に有効になるが、特定のLBアルゴリズムでは変更を考慮するために一定量のリクエストが必要である。ゼロ重みは、サーバーに同じ効果があるため（LBファームから削除される）、統計ページで"DRAIN"として報告される。

- "maxconn:"に続く整数（間にスペースなし）。この形式の値はサーバーのmaxconnを設定する。広告される最大接続数は、このヘルスチェックを使用する負荷分散器と異なるバックエンドの数で乗算する必要がある。サーバーが受信する可能性のある接続の総数を取得するため。例：maxconn:30

- "ready"という単語。これにより、サーバーの管理状態がREADYモードになり、DRAINまたはMAINT状態がキャンセルされる

- "drain"という単語。これにより、サーバーの管理状態がDRAINモードになり、永続性を介して受け入れられるものを除いて、新しい接続を受け入れなくなる

- "maint"という単語。これにより、サーバーの管理状態がMAINTモードになり、新しい接続をまったく受け入れなくなり、ヘルスチェックが停止される

- "down"、"fail"、または"stopped"という単語、オプションでシャープ（'#'）の後に説明文字列が続く。これらはすべてサーバーの動作状態をDOWNとしてマークするが、単語自体が統計ページで報告されるため、違いにより管理者は状況が予期されたものかどうかを知ることができる：サービスが意図的に停止されている可能性、アップしているように見えるが一部の有効性テストに失敗している可能性、またはダウンしているように見える可能性（例：プロセスが不足している、またはポートが応答していない）。

- "up"という単語は、ヘルスチェックもサービスがアクセス可能であることを報告している場合、サーバーの動作状態をUPに戻す

エージェントによって広告されていないパラメータは変更されない。例えば、エージェントはCPU使用率を監視するように設計され、相対重みのみを報告し、動作状態と相互作用しない場合がある。同様に、エージェントは管理者が管理状態のみを変更できる3つのラジオボタンを持つエンドユーザーインターフェースとして設計される場合がある。しかし、エージェントのみが自身のアクションを元に戻すことができることを考慮することが重要である。そのため、エージェントを使用してサーバーがDRAINモードまたはDOWN状態に設定されている場合、エージェントはサービスを再び動作状態にするために他の同等のアクションを実装する必要がある。

エージェントへの接続の失敗は、接続性が"check"パラメータで有効化された通常のヘルスチェックによってテストされるため、エラーとは見なされない。ただし、エージェントが"down"を報告した後にエージェントを停止することは、エージェントが"up"を報告する場合のみサーバーを再びアップできるため、良い考えではない。Unix統計ソケットのCLIも、必要に応じて不正なエージェントを回避するためにエージェントの結果を強制できることに注意すること。

"agent-port"パラメータの設定が必要である。"agent-inter"と"no-agent-check"パラメータも参照すること。

#### agent-send

**agent-send** &lt;string&gt;

以下のコンテキストで使用可能: tcp, http, log

このオプションが指定されている場合、HAProxyは接続時に指定された文字列（そのまま）をエージェントサーバーに送信する。例えば、バックエンド名をこの文字列にエンコードして、エージェントがバックエンドに基づいて異なる応答を送信できるようにすることができる。リクエストを改行で終了させたい場合は、'\n'を含めることを確認すること。

#### agent-inter

**agent-inter** &lt;delay&gt;

以下のコンテキストで使用可能: tcp, http, log

"agent-inter"パラメータは、2つのエージェントチェック間の間隔を&lt;delay&gt;ミリ秒に設定する。指定されていない場合、遅延はデフォルトで2000msになる。

他の時間ベースパラメータと同様に、{ us, ms, s, m, h, d }の他の明示的な単位で入力できる。"agent-inter"パラメータは、"timeout check"が設定されていない場合、エージェントチェックのタイムアウトとしても機能する。複数のサーバーが同じハードウェアでホストされている場合の"共振"効果を減らすために、すべてのサーバーのエージェントとヘルスチェックは、それらの間に小さな時間オフセットで開始される。グローバル"spread-checks"キーワードを使用して、エージェントとヘルスチェック間隔にランダムノイズを追加することも可能である。これは、多くのバックエンドが同じサーバーを使用する場合などに意味がある。

"agent-check"と"agent-port"パラメータも参照すること。

#### agent-addr

**agent-addr** &lt;addr&gt;

以下のコンテキストで使用可能: tcp, http, log

"agent-addr"パラメータはエージェントチェックのアドレスを設定する。

エージェントチェックを別のターゲットにオフロードできるため、自己認識および自己管理サービスを作成できない場合に、HAProxyで定義されたサーバーのステータスと重みを管理する単一の場所を作成できる。IPまたはホスト名の両方を指定でき、解決される。

#### agent-port

**agent-port** &lt;port&gt;

以下のコンテキストで使用可能: tcp, http, log

"agent-port"パラメータはエージェントチェックに使用されるTCPポートを設定する。

"agent-check"と"agent-inter"パラメータも参照すること。

#### allow-0rtt

**allow-0rtt**

以下のコンテキストで使用可能: tcp, http, log, peers, ring

TLS 1.3を使用する場合、サーバーに早期データを送信することを許可する。早期データは、クライアントが早期データを使用した場合、またはバックエンドが"0rtt-rejected"キーワードで"retry-on"を使用する場合にのみ送信されることに注意すること。

#### alpn

**alpn** &lt;protocols&gt;

以下のコンテキストで使用可能: tcp, http

これによりTLS ALPN拡張が有効になり、ALPNの上でサポートされているとして指定されたプロトコルリストが広告される。プロトコルリストは、カンマ区切りのプロトコル名リストで構成される。例："http/1.1,http/1.0"（引用符なし）。これには、SSLライブラリがTLS拡張のサポートを有効にしてビルドされている必要がある（haproxy -vvで確認）。ALPN拡張は初期NPN拡張を置き換える。ALPNはHTTP/2サーバーに接続するために必要である。OpenSSL 1.0.2より前のバージョンはALPNをサポートせず、現在廃止されているNPN拡張のみをサポートしていた。HTTP/2とHTTP/1.1の両方がサポートされることが期待される場合、以下のように優先順位順に両方のバージョンを広告できる：

     server 127.0.0.1:443 ssl crt pub.pem alpn h2,http/1.1

WebSocketストリームの代替ALPNを使用するには"ws"も参照すること。

#### backup

**backup**

以下のコンテキストで使用可能: tcp, http, log

"backup"がサーバー行に存在する場合、サーバーは他のすべての非バックアップサーバーが利用できない場合にのみ負荷分散で使用される。サーバーを参照する永続性クッキーを持つリクエストは常に処理される。デフォルトでは、バックエンドで"allbackups"オプションが設定されていない限り、最初の動作バックアップサーバーのみが使用される。"no-backup"と"option allbackups"オプションも参照すること。

#### ca-file

**ca-file** &lt;cafile&gt;

以下のコンテキストで使用可能: tcp, http, log, peers, ring

この設定は、OpenSSLのサポートがビルドされている場合にのみ利用可能である。サーバーの証明書を検証するために使用されるCA証明書をロードするPEMファイルを指定する。複数のCAを含むディレクトリをロードすることも可能である。この場合、HAProxyはディレクトリ内で利用可能なすべての".pem"、".crt"、".cer"、および".crl"をロードしようとする。ドットで始まるファイルは無視される。

システムの信頼されたCAを使用するために、cafileの代わりに"@system-ca"パラメータを使用できる。このディレクトリの場所は、SSL_CERT_DIR環境変数を設定することで上書きできる。

#### check

**check**

以下のコンテキストで使用可能: tcp, http, log

このオプションはサーバーでヘルスチェックを有効にする：
  - 設定されていない場合、ヘルスチェックは実行されず、サーバーは常に利用可能と見なされる。
  - 設定されており、他のチェック方法が設定されていない場合、最高の設定されたトランスポートレイヤーで接続が確立できる場合、サーバーは利用可能と見なされる。これはデフォルトでTCPを意味し、または"ssl"または"check-ssl"が設定されている場合はSSL/TLSを意味する。両方とも"send-proxy"または"check-send-proxy"が設定されている場合のPROXYプロトコルヘッダーなどの接続プレフィックスと組み合わせることができる。この動作は動的サーバーでは若干異なる。詳細については以下の段落を参照すること。
  - 設定されており、アプリケーションレベルのヘルスチェックが定義されている場合、アプリケーションレベルの交換は設定されたトランスポートレイヤーの上で実行され、すべての交換が成功した場合、サーバーは利用可能と見なされる。

デフォルトでは、ヘルスチェックはサーバーで設定されたのと同じアドレスとポートで実行され、同じカプセル化パラメータ（SSL/TLS、プロキシプロトコルヘッダーなど）を使用する。"addr"と"port"を使用して宛先アドレスを変更することが可能である。これが行われる場合、サーバーはサービスポートでチェックされず、設定されたカプセル化パラメータは再利用されないと想定される。接続ヘッダーを送信するために"check-send-proxy"を明示的に設定し、SSL/TLSを使用するために"check-ssl"を設定する必要がある。

動的サーバーのsslとPROXYプロトコルの暗黙的な設定は実行されないことに注意すること。この場合、チェックポートがオーバーライドされていない場合でも、必要な場合は"check-ssl"と"check-send-proxy"を明示的に使用する必要がある。

サーバー行で"sni"または"alpn"が設定されている場合、それらの値はヘルスチェックでは使用されず、"check-sni"または"check-alpn"を使用する必要がある。

ヘルスチェックトラフィックのデフォルトソースアドレスは、バックエンドで定義されたものと同じである。"source"キーワードで変更できる。

チェック間の間隔は"inter"キーワードを使用して設定でき、"rise"と"fall"キーワードを使用して、サーバーを利用可能または利用できないとフラグを立てるために必要な成功または失敗したヘルスチェックの数を定義できる。

オプションのアプリケーションレベルのヘルスチェックは"option httpchk"、"option mysql-check"、"option smtpchk"、"option pgsql-check"、"option ldap-check"、または"option redis-check"で設定できる。

**例:**

```bash
# シンプルなtcpチェック
backend foo
  server s1 192.168.0.1:80 check
# これはtcp接続 + tlsハンドシェイクを行う
backend foo
  server s1 192.168.0.1:443 ssl check
# シンプルなtcpチェックでチェック成功に十分
backend foo
  option tcp-check
  tcp-check connect
  server s1 192.168.0.1:443 ssl check
```

#### check-reuse-pool

**check-reuse-pool**

以下のコンテキストで使用可能: tcp, http

このオプションは、利用可能な場合、専用の接続を開く代わりに、チェックがアイドル接続を再利用することを許可する。接続はチェック完了時にプールに再挿入される。主な目的は、特定のサーバーでの接続の開始と終了の数を制限することである。

設定の簡素化のために、このオプションは、サーバー行またはカスタムtcp-check connectルールで特定のチェック接続オプションが定義されている場合、静かに無視されることに注意すること。

このオプションは、パッシブリバースHTTPゲートウェイとして動作するサーバーで自動的に有効になる。これらのサーバーでは、接続は再利用を介してのみサポートされる。

"check-pool-conn-name"も参照すること。

#### check-send-proxy

**check-send-proxy**

以下のコンテキストで使用可能: tcp, http

このオプションは、サーバーが通常のトラフィックにsend-proxyを使用するかどうかに関係なく、発信ヘルスチェックでPROXYプロトコル行の送信を強制する。デフォルトでは、PROXYプロトコルは既に通常のトラフィックで有効になっている場合、および"port"または"addr"ディレクティブが存在しない場合、ヘルスチェックで有効になる。しかし、そのようなディレクティブが存在する場合、プロトコルの使用を強制するために"check-send-proxy"オプションを使用する必要がある。詳細については"send-proxy"オプションも参照すること。

#### check-alpn

**check-alpn** &lt;protocols&gt;

以下のコンテキストで使用可能: tcp, http

ALPNで広告するプロトコルを定義する。プロトコルリストは、カンマ区切りのプロトコル名リストで構成される。例："http/1.1,http/1.0"（引用符なし）。設定されていない場合、サーバーALPNが使用される。

#### check-pool-conn-name

**check-pool-conn-name** &lt;name&gt;

以下のコンテキストで使用可能: tcp, http

チェックで接続再利用が実行される場合、設定されている場合は&lt;name&gt;を接続識別子として使用して、プール内の対応する接続と一致させる。これは"pool-conn-name"サーバーキーワードに相当する。"check-sni"も、現在のオプションが使用されていない場合のフォールバックとして使用される。

"check-reuse-pool"も参照すること。

#### check-proto

**check-proto** &lt;name&gt;

以下のコンテキストで使用可能: tcp, http

サーバーのヘルスチェック接続に使用するマルチプレクサーのプロトコルを強制する。ヘルスチェックタイプ（TCPまたはHTTP）と互換性がある必要がある。また、バックエンド側で使用可能である必要がある。利用可能なプロトコルのリストはhaproxy -vvで報告される。プロトコルのプロパティが報告される：モード（TCP/HTTP）、側（FE/BE）、マルチプレクサー名とそのフラグ。

一部のプロトコルはサーバー側でヘッドオブラインブロッキングの対象である（flag=HOL_RISK）。最後に、一部のプロトコルはアップグレードをサポートしない（flag=NO_UPG）。HTX互換性も報告される（flag=HTX）。

以下は、サーバー行の"check-proto"ディレクティブの引数として使用できるプロトコルである：

  h2   : mode=HTTP  side=FE|BE  mux=H2    flags=HTX|HOL_RISK|NO_UPG
  fcgi : mode=HTTP  side=BE     mux=FCGI  flags=HTX|HOL_RISK|NO_UPG
  h1   : mode=HTTP  side=FE|BE  mux=H1    flags=HTX|NO_UPG
  none : mode=TCP   side=FE|BE  mux=PASS  flags=NO_UPG

このオプションの背後にあるアイデアは、このサーバーに確立されたヘルスチェック接続の最適なマルチプレクサープロトコルの選択をバイパスすることである。定義されていない場合、設定されている場合はサーバーのものが使用される。

#### check-sni

**check-sni** &lt;sni&gt;

以下のコンテキストで使用可能: tcp, http, log

このオプションにより、SSL経由でヘルスチェックを実行する際に使用するSNIを指定できる。&lt;sni&gt;を設定するには文字列のみ使用可能である。プロキシトラフィックのSNIを設定したい場合は"sni"を参照すること。

#### check-ssl

**check-ssl**

以下のコンテキストで使用可能: tcp, http, log

このオプションは、サーバーが通常のトラフィックにSSLを使用するかどうかに関係なく、すべてのヘルスチェックのSSL暗号化を強制する。これは一般に、明示的な"port"または"addr"ディレクティブが指定されており、SSLヘルスチェックが継承されない場合に使用される。このオプションがチェックの下にSSLトランスポートレイヤーを挿入することを理解することが重要である。そのため、シンプルなTCP接続チェックがSSL接続になり、古いssl-hello-chkを置き換える。最も一般的な使用法は、"httpchk"とSSLチェックを組み合わせてHTTPSチェックを送信することである。すべてのSSL設定はヘルスチェックとトラフィックで共通である（例：暗号）。詳細については"ssl"オプションを参照し、このオプションを無効にするには"no-check-ssl"を参照すること。

#### check-via-socks4

**check-via-socks4**

以下のコンテキストで使用可能: tcp, http, log

このオプションは、アップストリームsocks4プロキシを使用した発信ヘルスチェックを有効にする。デフォルトでは、通常のトラフィックで有効になっている場合でも、ヘルスチェックはsocksトンネルを通過しない。

#### ciphers

**ciphers** &lt;ciphers&gt;

以下のコンテキストで使用可能: tcp, http, log, peers, ring

この設定は、OpenSSLのサポートがビルドされている場合にのみ利用可能である。このオプションは、サーバーとのSSL/TLSハンドシェイク中にネゴシエートされる暗号アルゴリズムのリストを記述する文字列を設定する。文字列の形式はOpenSSLマニュアルページの"man 1 ciphers"で定義されている。背景情報と推奨事項については、例：(https://wiki.mozilla.org/Security/Server_Side_TLS)と(https://mozilla.github.io/server-side-tls/ssl-config-generator/)を参照すること。TLSv1.3暗号設定については、"ciphersuites"キーワードを確認すること。

#### ciphersuites

**ciphersuites** &lt;ciphersuites&gt;

以下のコンテキストで使用可能: tcp, http, log, peers, ring

この設定は、OpenSSLのサポートがビルドされており、HAProxyのビルドにOpenSSL 1.1.1以降が使用されている場合にのみ利用可能である。このオプションは、サーバーとのTLS 1.3ハンドシェイク中にネゴシエートされる暗号アルゴリズムのリストを記述する文字列を設定する。文字列の形式はOpenSSLマニュアルページの"ciphersuites"セクションの下の"man 1 ciphers"で定義されている。TLSv1.2以前の暗号設定については、"ciphers"キーワードを確認すること。

#### client-sigalgs

**client-sigalgs** &lt;sigalgs&gt;

以下のコンテキストで使用可能: tcp, http, log, peers, ring

この設定は、OpenSSLのサポートがビルドされている場合にのみ利用可能である。クライアント認証に関連する署名アルゴリズムのリストを記述する文字列を設定する。これらはネゴシエートされる。文字列の形式はOpenSSLマニュアルページの"man 3 SSL_CTX_set1_client_sigalgs"で定義されている。特定のユースケースが特定されていない場合、この設定を使用することは推奨されない。

#### cookie

**cookie** &lt;value&gt;

以下のコンテキストで使用可能: http

"cookie"パラメータは、サーバーに割り当てられたクッキー値を&lt;value&gt;に設定する。この値は着信リクエストでチェックされ、同じ値を持つ最初の動作サーバーが選択される。クッキー挿入または書き換えモードでは、この値はクライアントに送信されるクッキーに割り当てられる。複数のサーバーが同じクッキー値を共有することは何も問題なく、実際には通常のサーバーとバックアップサーバーの間で一般的である。バックエンドセクションの"cookie"キーワードも参照すること。

#### crl-file

**crl-file** &lt;crlfile&gt;

以下のコンテキストで使用可能: tcp, http, log, peers, ring

この設定は、OpenSSLのサポートがビルドされている場合にのみ利用可能である。サーバーの証明書を検証するために使用される証明書失効リストをロードするPEMファイルを指定する。

#### crt

**crt** &lt;cert&gt;

以下のコンテキストで使用可能: tcp, http, log, peers, ring

この設定は、OpenSSLのサポートがビルドされている場合にのみ利用可能である。証明書と関連する秘密鍵の両方をロードするPEMファイルを指定する。このファイルは両方のPEMファイルを1つに連結することによって構築できる。この証明書は、サーバーがクライアント証明書リクエストを送信した場合に送信される。

ファイルに秘密鍵が含まれていない場合、HAProxyは同じパスに".key"サフィックスを付けたキーをロードしようとする（"ssl-load-extra-files"オプションが適切に設定されている場合）。

#### curves

**curves** &lt;curves&gt;

以下のコンテキストで使用可能: tcp, http, log, peers, ring

この設定は、OpenSSLのサポートがビルドされている場合にのみ利用可能である。ECDHEとのSSL/TLSハンドシェイク中にネゴシエートされる楕円曲線アルゴリズム（"curve suite"）のリストを記述する文字列を設定する。文字列の形式は、コロン区切りの曲線名リストである。

**例:**

"X25519:P-256"（引用符なし）

#### disabled

**disabled**

以下のコンテキストで使用可能: tcp, http, log

"disabled"キーワードは、サーバーを"disabled"状態で開始する。これは、メンテナンスモードでダウンマークされ、永続モードで許可されるものを除いて、他の接続は到達しないことを意味する。新しいサーバーのセットアップに非常に適している。通常のトラフィックは決して到達せず、force-persistメカニズムを使用してサービスをテストすることはまだ可能である。"enabled"設定も参照すること。

#### enabled

**enabled**

以下のコンテキストで使用可能: tcp, http, log

このオプションは、'server'設定として使用して、'default-server'ディレクティブから継承された可能性のある'disabled'設定をリセットするために使用できる。また、'default-server'設定として使用して、以前の'default-server' 'disabled'設定をリセットすることもできる。

#### error-limit

**error-limit** &lt;count&gt;

以下のコンテキストで使用可能: tcp, http, log

ヘルス監視が有効になっている場合、"error-limit"パラメータは、"on-error"オプションで選択されたイベントをトリガーする連続エラーの数を指定する。デフォルトでは10の連続エラーに設定される。

"check"、"error-limit"、"on-error"も参照すること。

#### fall

**fall** &lt;count&gt;

以下のコンテキストで使用可能: tcp, http, log

"fall"パラメータは、&lt;count&gt;回の連続した不成功のヘルスチェックの後、サーバーが死亡と見なされることを示す。この値は指定されていない場合、デフォルトで3になる。"check"、"inter"、"rise"パラメータも参照すること。

#### force-sslv3

**force-sslv3**

以下のコンテキストで使用可能: tcp, http, log, peers, ring

このオプションは、サーバーとの通信にSSLが使用される場合、SSLv3のみの使用を強制する。SSLv3は一般に高接続率でTLS対応よりも安価である。このオプションはグローバルステートメント"ssl-default-server-options"でも利用可能である。"ssl-min-ver"とssl-max-ver"も参照すること。

#### force-tlsv10

**force-tlsv10**

以下のコンテキストで使用可能: tcp, http, log, peers, ring

このオプションは、サーバーとの通信にSSLが使用される場合、TLSv1.0のみの使用を強制する。このオプションはグローバルステートメント"ssl-default-server-options"でも利用可能である。"ssl-min-ver"とssl-max-ver"も参照すること。

#### force-tlsv11

**force-tlsv11**

以下のコンテキストで使用可能: tcp, http, log, peers, ring

このオプションは、サーバーとの通信にSSLが使用される場合、TLSv1.1のみの使用を強制する。このオプションはグローバルステートメント"ssl-default-server-options"でも利用可能である。"ssl-min-ver"とssl-max-ver"も参照すること。

#### force-tlsv12

**force-tlsv12**

以下のコンテキストで使用可能: tcp, http, log, peers, ring

このオプションは、サーバーとの通信にSSLが使用される場合、TLSv1.2のみの使用を強制する。このオプションはグローバルステートメント"ssl-default-server-options"でも利用可能である。"ssl-min-ver"とssl-max-ver"も参照すること。

#### force-tlsv13

**force-tlsv13**

以下のコンテキストで使用可能: tcp, http, log, peers, ring

このオプションは、サーバーとの通信にSSLが使用される場合、TLSv1.3のみの使用を強制する。このオプションはグローバルステートメント"ssl-default-server-options"でも利用可能である。"ssl-min-ver"とssl-max-ver"も参照すること。

#### guid

**guid** &lt;string&gt;

以下のコンテキストで使用可能: tcp, http, log

このサーバーの大文字小文字を区別するグローバル一意IDを指定する。これはすべてのhaproxy設定のすべてのオブジェクトタイプで一意である必要がある。その形式の詳細については"guid"プロキシキーワードの説明を参照すること。

#### hash-key

**hash-key** &lt;key&gt;

以下のコンテキストで使用可能: tcp, http, log

"hash-type consistent"ノードキーがどのように計算されるかを指定する

**引数:**

&lt;key&gt;は以下のいずれかである：

  id         "id"で設定された、またはサーバーリスト内の位置からデフォルトで設定されるサーバーの数値識別子からノードキーが派生される。

  addr       サーバーのアドレスからノードキーが派生される（利用可能な場合）。そうでない場合は"id"にフォールバックする。

  addr-port  サーバーのアドレスとポートからノードキーが派生される（利用可能な場合）。そうでない場合は"id"にフォールバックする。

"addr"と"addr-port"オプションは、複数のHAProxyプロセスが同じサーバーセットにトラフィックを負荷分散するシナリオで役立つ場合がある。各プロセスのサーバー順序が異なる場合（例えば、DNSレコードが異なる順序で解決されたため）、これにより各独立したHAProxyプロセスがルーティング決定に同意できる。

#### id

**id** &lt;value&gt;

以下のコンテキストで使用可能: tcp, http, log

サーバーの永続IDを設定する。このIDは正で、プロキシで一意である必要がある。設定されていない場合、未使用のIDが自動的に割り当てられる。最初に割り当てられる値は1である。このIDは現在統計でのみ返される。

#### idle-ping

**idle-ping** &lt;delay&gt;

以下のコンテキストで使用可能: tcp, http, log

アイドルバックエンド接続の定期的な生存性の間隔を定義する。ピアが次のスケジュールされたテストの前に応答できない場合、接続は閉じられる。このキーワードはバックエンド側を参照するため、アイドル接続がまだ使用可能であることをチェックするのに役立つ。これはアイドルプールパージで接続が破棄されることを防がないことに注意すること。

この機能は特定の基盤プロトコルサポートに依存する。現在、H2マルチプレクサーのみが実装している。idle-pingは他のプロトコルでは単純に無視される。

このオプションはリバースHTTPを使用する場合に特に役立つ。サーバー行で設定することは、着信接続を待ち受け、後でトラフィック転送で再利用できるように対応するサーバーにアタッチするピアに役立つ。

#### init-addr

**init-addr** {last | libc | none | &lt;ip&gt;}[,...]*

以下のコンテキストで使用可能: tcp, http, log

FQDNを使用するサーバーのアドレスが起動時にどの順序で解決されるかを示す。カンマ区切りのリストで言及された各メソッドを順番に適用してアドレスの解決を試行する。成功する最初のメソッドが使用される。リストの最後に達しても動作するメソッドが見つからない場合、エラーがスローされる。メソッド"last"は、状態ファイルに表示されるアドレスを選択することを示唆する（"server-state-file"を参照）。メソッド"libc"はlibcの内部リゾルバー（gethostbyname()またはgetaddrinfo()、オペレーティングシステムとビルドオプションに依存）を使用する。メソッド"none"は、サーバーが有効なIPアドレスなしでダウン状態で開始することを具体的に示す。起動時に一部のDNS問題を無視し、状況が後で修正されるのを待つのに役立つ場合がある。最後に、IPアドレス（IPv4またはIPv6）が提供される場合がある。これはサーバーの現在知られているアドレス（例：設定ジェネレーターによって入力された）である場合がある。または、古いセッションをキャッチし、適切なエラーメッセージを提示するために使用されるダミーサーバーのアドレスである場合がある。"first"負荷分散アルゴリズムが使用される場合、このIPアドレスは、必要に応じて新しいインスタンスの作成をトリガーするために使用されるフェイクサーバーを指す場合がある。このオプションはデフォルトで"last,libc"である。これは、状態ファイルで見つかった前のアドレス（存在する場合）が最初に使用され、そうでない場合はlibcのリゾルバーが使用されることを示す。これにより、歴史的な動作との継続的な互換性が確保される。内部リゾルバーを使用する場合、一般に推奨される
### 5.3 DNSを使用したサーバーIPアドレス解決

HAProxyは、サーバー行でホスト名を使用して、ネームサーバーを使用してそのIPアドレスを取得することを許可する。デフォルトでは、HAProxyは設定ファイルを解析する際、起動時に名前を解決し、プロセスの寿命の間結果をキャッシュする。これは、サーバーのIPが再起動後に変更される可能性があるAmazonの場合や、ELB仮想IPが現在のワークロードに基づいて変更される可能性がある場合など、一部のケースでは十分ではない。

この章では、HAProxyが実行時にサーバー名解決を処理するように設定される方法について説明する。

実行時サーバー名解決が有効になっているかどうかに関係なく、デフォルトではHAProxyは"init-addr"パラメータによって無効化されていない限り、設定解析中に起動時にlibcを介して最初の解決を実行する。

#### 5.3.1 グローバル概要

導入で見たように、HAProxyでの名前解決は、プロセスの寿命の2つの異なるステップで発生する：

  1. 起動時、HAProxyはサーバー行定義を解析し、ホスト名と一致する。libc関数を使用してホスト名を解決する。この解決は/etc/resolv.confファイルに依存する。

  2. 実行時に、HAProxyはDNS解決を必要とするサーバーの名前解決を定期的に実行する。

実行時に名前解決をトリガーできる他のイベント：
  - サーバーのヘルスチェックが接続タイムアウトで終了する場合：これはサーバーが新しいIPアドレスを持っている可能性があるためである。そのため、この新しいIPを知るために名前解決をトリガーする必要がある。

リゾルバーを使用する場合、サーバー名はホスト名またはSRVラベルのいずれかである。HAProxyは、アンダースコアで始まるものをSRVラベルと見なす。SRVラベルが指定されている場合、対応するSRVレコードがDNSサーバーから取得され、提供されたホスト名が使用される。SRVラベルは定期的にチェックされ、サーバーが追加または削除されている場合、HAProxyは自動的に同じことを行う。

注意すべき重要な点：
  - すべてのネームサーバーが同時にクエリされる。HAProxyは最初の有効な応答を処理する。

  - 解決は、すべてのサーバーがエラーを返す場合、無効と見なされる（NX、タイムアウト、拒否）。

  - HAProxyに実装されたDNSクライアントは非常に基本的であり、オペレーティングシステムのリゾルバーが処理できる多数のオプションと高度なセットアップを理解しない。そのため、サーバーがFQDNで知られており、一度に正確に1つのIPアドレスを持ち、時々更新する可能性がある（例：再起動）本当に些細なセットアップを除いて、libcベースの初期時間解決とDNSベースの実行時解決を混在させることは強く推奨されない。そのようなセットアップは、アドレス更新時に失敗を引き起こすことが知られている。結論として、正確に何をしているかを知らない限り、サーバー行で"resolvers"を使用する場合は、常に"init-addr"から"libc"を除外する必要がある。

#### 5.3.2 リゾルバーセクション

このセクションは、HAProxyでの名前解決に関連するホスト情報専用である。必要に応じて多くのリゾルバーセクションがある。各セクションには多くのネームサーバーを含めることができる。

起動時、HAProxyは、設定でこの名前が付けられていない場合、"default"という名前のリゾルバーセクションを生成しようとする。このセクションはデフォルトでhttpclientによって使用され、parse-resolv-confキーワードを使用する。HAProxyがこのセクションを自動的に生成できなかった場合、エラーや警告は発行されない。

リゾルバーセクションで複数のネームサーバーが設定されている場合、HAProxyは最初の有効な応答を使用する。無効な応答の場合、最後の1つのみが処理される。目的は、遅いサーバーに、高速な不正または古いサーバーの後に有効な回答を提供する機会を与えることである。

各サーバーが異なるエラータイプを返す場合、HAProxyは最後のエラーのみを使用する。このエラーに以下の処理が適用される：

  1. HAProxyは新しいクエリタイプで同じDNSクエリを再試行する。AクエリはAAAAに切り替わる、またはその逆。SRVクエリはここでは関係ない。タイムアウトエラーも除外される。

  2. クエリタイプへのフォールバックが完了した（または適用できない）場合、HAProxyは優先クエリタイプで元のDNSクエリを再試行する。

  3. HAProxyは前のステップを&lt;resolve_retries&gt;回再試行する。その後も有効な応答が受信されない場合、DNS解決を停止し、エラーを報告する。

例えば、リゾルバーセクションで2つのネームサーバーが設定されている場合、以下のシナリオが可能である：

  - 最初の応答が有効で直接適用され、2番目の応答は無視される

  - 最初の応答が無効で2番目が有効な場合、2番目の応答が適用される

  - 最初の応答がNXドメインで2番目が切り詰められた応答の場合、HAProxyは新しいタイプでクエリを再試行する

  - 最初の応答がNXドメインで2番目がタイムアウトの場合、HAProxyは新しいタイプでクエリを再試行する

  - 両方のネームサーバーでクエリがタイムアウトした場合、HAProxyは同じクエリタイプで再試行する

DNSサーバーが1つのDNSリクエストですべてのIPに回答しない場合があるため、HAProxyは以前の回答のキャッシュを保持する。IPが返されない&lt;hold obsolete&gt;秒後に回答は古いと見なされる。

#### resolvers

**resolvers** &lt;resolvers id&gt;

&lt;resolvers id&gt;というラベルが付けられた新しいネームサーバーリストを作成する

リゾルバーセクションは以下のパラメータを受け入れる：

#### accepted_payload_size

**accepted_payload_size** &lt;nb&gt;

このリゾルバーセクションで設定されたすべてのネームサーバーにHAProxyが受け入れて発表する最大ペイロードサイズを定義する。
&lt;nb&gt;はバイト単位である。設定されていない場合、HAProxyは512を発表する。（RFC 6891で定義された最小値）

注意：最大許可値は65535である。UDPの推奨値は4096であり、システムとネットワークがこれを処理できることが確実でない限り、8192を超えることは推奨されない（65507を超えることは意味がない。これは最大UDPペイロードサイズである）。巨大なDNS応答を処理するためにTCPネームサーバーのみを使用している場合、この値を最大値65535に設定する必要がある。

#### nameserver

**nameserver** &lt;name&gt; &lt;address&gt;[:port] [param*]

ネームサーバーを設定するために使用される。&lt;name&gt;はネームサーバーの一意である必要がある。デフォルトでは&lt;address&gt;はデータグラムタイプと見なされる。これは、特別なアドレスプレフィックス（段落11.）なしでIPv4またはIPv6が設定されている場合、UDPプロトコルが使用されることを意味する。ストリームプロトコルアドレスプレフィックスが使用される場合、ネームサーバーはストリームサーバー（例：TCP）と見なされ、5.2段落で見つかった"server"パラメータはDNS解決に関連するものと見なされる。注意：現在、TCPモードでは、同じ接続で4つのクエリがパイプライン化される。アイドル接続のバッチは5秒ごとに削除される。"maxconn"を設定して、それらの同時接続の量を制限でき、TLSも使用可能である（サーバーがサポートしている場合）。

#### parse-resolv-conf

**parse-resolv-conf**

/etc/resolv.confで見つかったすべてのネームサーバーをこのリゾルバーのネームサーバーリストに追加する。/etc/resolv.confの各ネームサーバーが個別にリゾルバーセクションに配置されたかのように順序付けされる。

#### hold

**hold** &lt;status&gt; &lt;period&gt;

DNS応答&lt;status&gt;を受信した際、サーバーの状態をUPからDOWNに変更すべきかどうかを決定する。その決定を行うために、過去&lt;period&gt;の間に有効なステータスが受信されたかどうかをチェックして、今受信した無効なステータスに対抗する。

  &lt;status&gt; : 最後の名前解決ステータス。
         nx        NXDOMAINステータスを受信した後、結論期間中の有効なステータスをチェックする。

         refused   REFUSEDステータスを受信した後、結論期間中の有効なステータスをチェックする。

         timeout   "timeout retry"が発生した後、結論期間中の有効なステータスをチェックする。

         other     他の無効なステータスを受信した後、結論期間中の有効なステータスをチェックする。

         valid     "http-request do-resolve"と"tcp-request content do-resolve"アクションにのみ適用される。サーバーが別の解決をトリガーする前に有効な応答を維持する期間を定義する。サーバーの動的解決には影響しない。

         obsolete  SRVレコードに適用される。更新された回答レコードを受信した後、古いDNSレコードを削除する前に待機する時間を定義する。

  &lt;period&gt; : 有効な応答が受信されている必要がある過去の時間の量。HAProxy時間形式に従い、デフォルトではミリ秒単位である。

動的DNS解決に依存してIPアドレスを決定するサーバーにとって、NXDOMAINなどの無効なDNS応答を受信することは、サーバーの状態をUPからDOWNに変更することにつながる。holdディレクティブは、過去の有効な応答をどの程度探すかを定義する。結論期間中に有効な応答が受信されている場合、今受信した無効なステータスは無視される。

結論期間中に有効な応答が受信されていない限り、サーバーはDOWNとしてマークされる。例えば、"hold nx 30s"が設定されており、最後に受信したDNS応答がNXDOMAINの場合、過去30秒間に有効な応答が受信されていない限り、サーバーはDOWNとしてマークされる。

DOWN状態のサーバーは、DNSサーバーから有効なステータスを受信すると即座にUPとしてマークされる。

"hold valid"と"hold obsolete"には別の動作が存在する。

デフォルト値は"valid"で10s、"obsolete"で0s、その他で30sである。

#### resolve_retries

**resolve_retries** &lt;nb&gt;

サーバー名の解決を諦める前に送信するクエリの数&lt;nb&gt;を定義する。
デフォルト値: 3

再試行は、ネームサーバータイムアウトまたはDNSクエリタイプフェイルオーバーの完全なシーケンスが終了し、デフォルトのANYクエリタイプから開始する必要がある場合に発生する。

#### timeout

**timeout** &lt;event&gt; &lt;time&gt;

名前解決に関連するタイムアウトを定義する
   &lt;event&gt; : &lt;time&gt;タイムアウト期間が適用されるイベント。
             利用可能なイベント：
             - resolve : 他の時間が適用されない場合の名前解決をトリガーするデフォルト時間。
                         デフォルト値: 1s
             - retry   : 有効な応答が受信されていない場合の2つのDNSクエリ間の時間。
                         デフォルト値: 1s
   &lt;time&gt;  : イベントに関連する時間。HAProxy時間形式に従う。
             &lt;time&gt;はミリ秒で表される。

**例:**

```bash
resolvers mydns
  nameserver dns1 10.0.0.1:53
  nameserver dns2 10.0.0.2:53
  nameserver dns3 tcp@10.0.0.3:53
  parse-resolv-conf
  resolve_retries       3
  timeout resolve       1s
  timeout retry         1s
  hold other           30s
  hold refused         30s
  hold nx              30s
  hold timeout         30s
  hold valid           10s
  hold obsolete        30s
```
## 6. Cache

HAProxyはキャッシュを提供する。これは小さなオブジェクト（ファビコン、CSS...）に対してキャッシュを実行するように設計されている。これはRAMで動作する、メンテナンスが少ないミニマリストなキャッシュである。

キャッシュは、すべてのスレッド間で共有されるメモリ領域に基づいており、1kBブロックに分割されている。

オブジェクトがもはや使用されていない場合、その有効期限に関係なく、新しいオブジェクトを格納するために削除することができる。新しいオブジェクトを割り当てようとする際、最も古いオブジェクトが最初に削除される。

キャッシュは、ホストヘッダーとURIのハッシュをキーとして使用する。

Unixソケットコマンドを使用してキャッシュの状態を表示することが可能である。
### 6.1. Limitation

キャッシュは以下の場合にオブジェクトを格納せず、配信しない：

- レスポンスが200でない場合
- レスポンスにVaryヘッダーが含まれており、process-varyオプションが無効になっているか、Vary値に現在管理されていないヘッダーが指定されている場合（現在はaccept-encoding、referer、originのみが管理されている）
- Content-Length + ヘッダーサイズが「max-object-size」より大きい場合
- レスポンスがキャッシュ可能でない場合
- レスポンスに明示的な有効期限（s-maxageまたはmax-age Cache-ControlディレクティブまたはExpiresヘッダー）またはバリデーター（ETagまたはLast-Modifiedヘッダー）がない場合
- process-varyオプションが有効になっており、現在のレスポンスと同じプライマリキーを持つmax-secondary-entriesエントリが既に存在する場合
- process-varyオプションが有効になっており、accept-encodingクライアントヘッダーで変化する際にレスポンスが未知のエンコーディング（https://www.iana.org/assignments/http-parameters/http-parameters.xhtmlで言及されていない）を持っている場合

- リクエストがGETでない場合
- リクエストのHTTPバージョンが1.1より小さい場合
- リクエストにAuthorizationヘッダーが含まれている場合
### 6.2. Setup

キャッシュを設定するには、キャッシュセクションを定義し、対応するhttp-requestとhttp-responseアクションを持つプロキシで使用する必要がある。

#### 6.2.1. Cache section

**cache** *&lt;name&gt;*

キャッシュセクションを宣言し、&lt;name&gt;という名前の共有キャッシュメモリを割り当てる。キャッシュのサイズは必須である。

**total-max-size** *&lt;megabytes&gt;*

メガバイト単位でRAM内のキャッシュのサイズを定義する。このサイズは1kBブロックに分割され、キャッシュエントリによって使用される。その最大値は4095である。

**max-object-size** *&lt;bytes&gt;*

キャッシュされるオブジェクトの最大サイズを定義する。「total-max-size」の半分以下でなければならない。設定されていない場合、キャッシュサイズの256分の1に等しい。「max-object-size」より大きいサイズのすべてのオブジェクトはキャッシュされない。

**max-age** *&lt;seconds&gt;*

最大有効期限を定義する。有効期限は、Cache-Controlレスポンスヘッダーのs-maxageまたはmax-ageディレクティブ（この順序）とこの値の間の最小値として設定される。デフォルト値は60秒であり、これはデフォルトでオブジェクトを60秒以上キャッシュできないことを意味する。

**process-vary** *&lt;on/off&gt;*

Varyヘッダーの処理を有効または無効にする。無効の場合、そのようなヘッダーを含むレスポンスは決してキャッシュされない。有効の場合、すべての着信リクエスト（CPUコストがかかる可能性がある）のリクエストヘッダーのサブセットの予備ハッシュを計算する必要があり、これは特定のリクエストのセカンダリキーを構築するために使用される（RFC 7234#4.1を参照）。セカンダリキーは現在、'accept-encoding'、'referer'、'origin'ヘッダーの内容から構築される。デフォルト値はoff（無効）である。

**max-secondary-entries** *&lt;number&gt;*

キャッシュ内の同じプライマリキーを持つ同時セカンダリエントリの最大数を定義する。これにはvaryサポートが有効である必要がある。そのデフォルト値は10であり、厳密に正の整数を渡す必要がある。

#### 6.2.2. Proxy section

キャッシュを使用するプロキシセクションは、リクエストされたオブジェクトをキャッシュから検索するために「http-request」ルールセットで「cache-use」アクションを、取得されたオブジェクトをキャッシュに格納または更新するために「http-response」ルールセットで「cache-store」アクションを含める必要がある。これらの各アクションは、オプションで条件を含むことができる。例えば、キャッシュ可能でないことが知られている特定のサブディレクトリに対して「cache-use」アクションをスキップするか、価値がないことが知られている特定のコンテンツタイプに対して「cache-store」アクションをスキップすることを決定できる。キャッシュインデックスキーは「cache-use」アクション中に計算されるため、このアクションがスキップされた場合、レスポンスパスでキャッシュを更新しようとする試みは行われないことに注意してください。

**例：**

```
backend bck1
  mode http

  http-request cache-use foobar
  http-response cache-store foobar
  server srv1 127.0.0.1:80

cache foobar
  total-max-size 4
  max-age 240
```
## 7. Using ACLs and fetching samples

HAProxyは、リクエストまたはレスポンスストリーム、クライアントまたはサーバー情報、テーブル、環境情報などからデータを抽出することができる。そのようなデータを抽出する動作は、サンプルを取得すると呼ばれる。一度取得されると、これらのサンプルは、スティックテーブルのキーなどの様々な目的に使用されるが、最も一般的な使用方法は、パターンと呼ばれる事前定義された定数データと照合することである。
### 7.1. ACL basics

アクセス制御リスト（ACL）は、事前定義されたパターンのリストに対して任意の情報を比較する名前付きメソッドを宣言することで構成される。これらは、ほとんどのプログラミング言語の関数と実用的に同等であると見なされるべきである。その宣言により、必要に応じて後で呼び出されることが可能になる。その評価は一致または不一致のみを返し、これは多くのプログラミング言語のブール値に相当する。プログラミング言語の関数とは異なり、ACLは同じ名前に対して追加のマッチングメソッドを定義するために必要に応じて何度でもオーバーロードされることができる。この場合、それらはすべて宣言順に評価され、一致するまで続けられる。

ACLの使用は、コンテンツスイッチングを実行し、一般的にリクエスト、レスポンス、または任意の環境状態から抽出されたコンテンツに基づいて決定を下すための柔軟なソリューションを提供する。原則はシンプルである：

  - ストリーム、テーブル、または環境からデータサンプルを抽出する
  - オプションで抽出されたサンプルにいくつかのフォーマット変換を適用する
  - このサンプルに対して1つまたは複数のパターンマッチングメソッドを適用する
  - パターンがサンプルと一致する場合のみアクションを実行する

アクションは一般的に、リクエストのブロック、バックエンドの選択、またはヘッダーの追加で構成される。

テストを定義するために、「acl」キーワードが使用される。構文は以下の通りである：

   acl &lt;aclname&gt; &lt;criterion&gt; [flags] [operator] [&lt;value&gt;] ...

これにより、新しいACL &lt;aclname&gt;が作成されるか、既存のものに新しいテストが追加される。これらのテストは&lt;criterion&gt;で指定されたリクエスト/レスポンスの部分に適用され、オプションのフラグ[flags]で調整されることができる。一部の基準は、値のセットの前に指定される演算子もサポートする。オプションで、一部の変換演算子がサンプルに適用されることができ、これらは最初のキーワードの直後にカンマ区切りのキーワードリストとして指定される。値は基準がサポートするタイプであり、スペースで区切られる。

ACL名は、大文字と小文字の文字、数字、'-'（ダッシュ）、'_'（アンダースコア）、'.'（ドット）、':'（コロン）から形成される必要がある。ACL名は大文字と小文字を区別し、これは「my_acl」と「My_Acl」が2つの異なるACLであることを意味する。

ACLの数に強制された制限はない。使用されていないものはパフォーマンスに影響せず、わずかな量のメモリを消費するだけである。

基準は一般的にサンプル取得メソッドの名前、またはそのACL固有の変形の1つである。デフォルトのテストメソッドは、このサンプル取得メソッドの出力タイプによって暗示される。ACL変形は、同じサンプル取得メソッドの代替マッチングメソッドを記述することができる。サンプル取得メソッドは、変換をサポートする唯一のものである。

サンプル取得メソッドは、以下のタイプのデータを返す：

  - boolean
  - integer（符号付きまたは符号なし）
  - IPv4またはIPv6アドレス
  - string
  - data block

コンバーターは、これらのデータのいずれかをこれらの中の任意のものに変換する。例えば、一部のコンバーターは文字列を小文字の文字列に変換するが、他のものは文字列をIPv4アドレスに変換するか、IPアドレスにネットマスクを適用する。結果のサンプルは、リストに適用された最後のコンバーターのタイプであり、これはサンプル取得メソッドのタイプをデフォルトとする。

各サンプルまたはコンバーターは、このドキュメントでそのキーワードで指定された特定のタイプのデータを返す。ACLが標準的なサンプル取得メソッドを使用して宣言される場合、特定のタイプは自動的にデフォルトのマッチングメソッドを伴い、これらは以下の表にまとめられる：
```txt
   +---------------------+-----------------+
   | Sample or converter | Default         |
   |    output type      | matching method |
   +---------------------+-----------------+
   | boolean             | bool            |
   +---------------------+-----------------+
   | integer             | int             |
   +---------------------+-----------------+
   | ip                  | ip              |
   +---------------------+-----------------+
   | string              | str             |
   +---------------------+-----------------+
   | binary              | none, use "-m"  |
   +---------------------+-----------------+
```
バイナリサンプルを一致させるためには、マッチングメソッドを指定することが必須であることに注意してください。以下を参照してください。

ACLエンジンは、これらのタイプを以下のタイプのパターンと照合することができる：

  - boolean
  - integerまたはinteger range
  - IP address / network
  - string（exact、substring、suffix、prefix、subdir、domain）
  - regular expression
  - hex block

現在サポートされているACLフラグは以下の通りである：

   -i : 後続のすべてのパターンのマッチング中に大文字と小文字を無視する。
   -f : リストからパターンを読み込む。
   -m : 特定のパターンマッチングメソッドを使用する
   -n : DNS解決を禁止する
   -M : -fで指されたファイルをマップのように読み込む。
   -u : ACLの一意のIDを強制する
   -- : フラグの終了を強制する。文字列がフラグの1つのように見える場合に便利である。

「-f」フラグの後には、2.7.でマップとACLの名前形式について説明されている形式に従う必要がある名前が続く。パターンが複数のリストから読み込まれる場合、複数の「-f」引数を渡すことも可能である。既存のファイルが参照される場合、すべての行が個別の値として読み込まれる。空行およびシャープ（'#'）で始まる行は無視される。すべての先頭のスペースとタブは削除される。シャープで始まる有効なパターンを挿入することが絶対に必要である場合、コメントとして扱われないように、スペースでプレフィックスを付けるだけである。データタイプとマッチメソッドに応じて、HAProxyは行をバイナリツリーに読み込み、非常に高速なルックアップを可能にする。これはIPv4と正確な文字列マッチングに当てはまる。この場合、重複は自動的に削除される。

「-M」フラグにより、ACLがマップを使用することができる。このフラグが設定されている場合、リストは2列のエントリとして解析される。最初の列にはACLによって使用されるパターンが含まれ、2番目の列にはサンプルが含まれる。サンプルは後でマップによって使用されることができる。これは、マッピングが適用される前にマップ内のパターンの存在をチェックするためにACLが使用されるだけである、いくつかのまれなケースで便利である。

「-u」フラグはACLの一意のIDを強制する。この一意のIDは、ソケットインターフェースでACLを識別し、その値を動的に変更するために使用される。IDが設定されている場合でも、ファイルは常にその名前で識別されることに注意してください。

また、「-i」フラグは後続のエントリに適用され、その前に読み込まれたファイルからのエントリには適用されないことに注意してください。例えば：

    acl valid-ua hdr(user-agent) -f exact-ua.lst -i -f generic-ua.lst test

この例では、「exact-ua.lst」の各行がリクエストの「user-agent」ヘッダーに対して正確に照合される。その後、「generic-ua」の各行が大文字と小文字を区別せずに照合される。その後、「test」という単語も大文字と小文字を区別せずに照合される。

「-m」フラグは、入力サンプルに対して特定のパターンマッチングメソッドを選択するために使用される。すべてのACL固有の基準はパターンマッチングメソッドを暗示し、一般的にこのフラグを必要としない。しかし、このフラグは、汎用サンプル取得メソッドで、パターンに対してどのように照合されるかを記述するために便利である。これは、明らかなマッチングメソッドがないデータタイプ（例：文字列またはバイナリ）を返すサンプル取得に必要である。「-m」が指定され、パターンマッチングメソッド名が続く場合、このメソッドは基準のデフォルトのものの代わりに使用される。これにより、最初に計画されていなかった方法でコンテンツを照合すること、または文字列を返すサンプル取得メソッドで照合することが可能になる。マッチングメソッドは、パターンが解析される方法にも影響する。

「-n」フラグはDNS解決を禁止する。IPファイルの読み込みで使用される。デフォルトでは、パーサーがIPアドレスを解析できない場合、解析された文字列がおそらくドメイン名であると考え、DNS解決を試みる。「-n」フラグはこの解決を無効にする。これは不正なIPリストを検出するのに便利である。DNSサーバーに到達できない場合、HAProxy設定の解析がタイムアウトを待って数分間続く可能性があることに注意してください。この間、エラーメッセージは表示されない。「-n」フラグはこの動作を無効にする。実行時には、この機能は動的ACL変更に対して無効になることにも注意してください。

ただし、いくつかの制限がある。すべてのメソッドをすべてのサンプル取得メソッドで使用できるわけではない。また、「-m」が「-f」と組み合わせて使用される場合、最初に配置される必要がある。パターンマッチングメソッドは以下のいずれかである必要がある：

  - "found" : 要求されたサンプルがストリーム内で見つかったかどうかのみをチェックし、パターンと比較しない。混乱を避けるためにパターンを渡さないことが推奨される。このマッチングメソッドは、ヘッダー、クッキーなどの特定のコンテンツの存在を検出するのに特に便利である。それらが空で、何とも比較せず、カウントしない場合でも。

  - "bool" : 値をブール値としてチェックする。これはブール値または整数値を返す取得にのみ適用され、パターンを取らない。値ゼロまたはfalseは一致せず、他のすべての値は一致する。

  - "int" : 値を整数として照合する。整数とブール値サンプルで使用されることができる。ブール値falseは整数0、trueは整数1である。

  - "ip" : 値をIPv4またはIPv6アドレスとして照合する。これはIPアドレスサンプルのみと互換性があるため、暗示され、決して必要とされない。

  - "bin" : 内容をバイナリシーケンスを表す16進文字列に対して照合する。これはバイナリまたは文字列サンプルで使用されることができる。

  - "len" : サンプルの長さを整数として照合する。これはバイナリまたは文字列サンプルで使用されることができる。

  - "str" : 正確な照合：内容を文字列に対して照合する。これはバイナリまたは文字列サンプルで使用されることができる。

  - "sub" : 部分文字列照合：内容が提供された文字列パターンの少なくとも1つを含むかどうかをチェックする。これはバイナリまたは文字列サンプルで使用されることができる。

  - "reg" : 正規表現照合：内容を正規表現のリストに対して照合する。これはバイナリまたは文字列サンプルで使用されることができる。

  - "beg" : プレフィックス照合：内容が提供された文字列パターンのように始まるかどうかをチェックする。これはバイナリまたは文字列サンプルで使用されることができる。

  - "end" : サフィックス照合：内容が提供された文字列パターンのように終わるかどうかをチェックする。これはバイナリまたは文字列サンプルで使用されることができる。

  - "dir" : サブディレクトリ照合：スラッシュで区切られた内容の部分が提供された文字列パターンの1つと正確に一致するかどうかをチェックする。これはバイナリまたは文字列サンプルで使用されることができる。

  - "dom" : ドメイン照合：ドットで区切られた内容の部分が提供された文字列パターンの1つと正確に一致するかどうかをチェックする。これはバイナリまたは文字列サンプルで使用されることができる。

例えば、HTTPリクエスト内のクッキー「JSESSIONID」の存在を素早く検出するために、以下を実行することができる：

    acl jsess_present req.cook(JSESSIONID) -m found

バッファ内のデータの最初の500バイトに正規表現を適用するために、以下のACLを使用する：

    acl script_tag req.payload(0,500) -m reg -i &lt;script&gt;

「-i」を使用する際に正規表現ライブラリがはるかに遅いシステムでは、照合前にサンプルを小文字に変換することが可能である：

    acl script_tag req.payload(0,500),lower -m reg &lt;script&gt;

すべてのACL固有の基準はデフォルトのマッチングメソッドを暗示する。ほとんどの場合、これらの基準は元のサンプル取得メソッドの名前とマッチングメソッドを連結することで構成される。例えば、「hdr_beg」は「hdr」取得メソッドを使用して取得されたサンプルに「beg」マッチを適用する。このマッチングメソッドは、キーワードが単独で使用され、コンバーターがない場合にのみ使用可能である。そのようなコンバーターがそのようなACLキーワードの後に適用される場合、ACLキーワードのデフォルトのマッチングメソッドは単純に無視される。照合に重要であるのは最後のコンバーターの出力タイプであるためである。すべてのACL固有の基準はサンプル取得メソッドに依存するため、代わりに元のサンプル取得メソッドと「-m」を使用した明示的なマッチングメソッドを使用することは常に可能である。

ACL固有の基準で「-m」を使用して代替マッチが指定される場合、マッチングメソッドは単純に基礎となるサンプル取得メソッドに適用される。例えば、以下のすべてのACLは正確に同等である：

    acl short_form  hdr_beg(host)        www.
    acl alternate1  hdr_beg(host) -m beg www.
    acl alternate2  hdr_dom(host) -m beg www.
    acl alternate3  hdr(host)     -m beg www.

以下の表は、サンプルまたはコンバータータイプと照合するパターンタイプの間の互換性マトリックスをまとめている。各互換性のある組み合わせについて、使用されるマッチングメソッドの名前を示し、メソッドがデフォルトであり、「-m」なしでデフォルトで動作する場合は角括弧「&gt;」と「&lt;」で囲む。
```txt
                           +-------------------------------------------------+
                           |                Input sample type                |
    +----------------------+---------+---------+---------+---------+---------+
    |     pattern type     | boolean | integer |   ip    | string  | binary  |
    +----------------------+---------+---------+---------+---------+---------+
    | none (presence only) |  found  |  found  |  found  |  found  |  found  |
    +----------------------+---------+---------+---------+---------+---------+
    | none (boolean value) |&gt;  bool &lt;|   bool  |         |   bool  |         |
    +----------------------+---------+---------+---------+---------+---------+
    | integer (value)      |   int   |&gt;  int  &lt;|   int   |   int   |         |
    +----------------------+---------+---------+---------+---------+---------+
    | integer (length)     |   len   |   len   |   len   |   len   |   len   |
    +----------------------+---------+---------+---------+---------+---------+
    | IP address           |         |         |&gt;   ip  &lt;|    ip   |    ip   |
    +----------------------+---------+---------+---------+---------+---------+
    | exact string         |   str   |   str   |   str   |&gt;  str  &lt;|   str   |
    +----------------------+---------+---------+---------+---------+---------+
    | prefix               |   beg   |   beg   |   beg   |   beg   |   beg   |
    +----------------------+---------+---------+---------+---------+---------+
    | suffix               |   end   |   end   |   end   |   end   |   end   |
    +----------------------+---------+---------+---------+---------+---------+
    | substring            |   sub   |   sub   |   sub   |   sub   |   sub   |
    +----------------------+---------+---------+---------+---------+---------+
    | subdir               |   dir   |   dir   |   dir   |   dir   |   dir   |
    +----------------------+---------+---------+---------+---------+---------+
    | domain               |   dom   |   dom   |   dom   |   dom   |   dom   |
    +----------------------+---------+---------+---------+---------+---------+
    | regex                |   reg   |   reg   |   reg   |   reg   |   reg   |
    +----------------------+---------+---------+---------+---------+---------+
    | hex block            |         |         |         |   bin   |   bin   |
    +----------------------+---------+---------+---------+---------+---------+
```

#### 7.1.1. Matching booleans

ブール値を照合するために、値は必要なく、すべての値は無視される。ブール値照合は、タイプ「boolean」のすべての取得メソッドに対してデフォルトで使用される。ブール値照合が使用される場合、取得された値はそのまま返される。これは、ブール値「true」が常に一致し、ブール値「false」が決して一致しないことを意味する。

ブール値照合は、整数値を返す取得メソッドで「-m bool」を使用して強制されることもある。この場合、整数値0はブール値「false」に変換され、他のすべての値は「true」に変換される。

#### 7.1.2. Matching integers

整数照合は、デフォルトで整数取得メソッドに適用される。また、「-m int」を使用してブール値取得で強制されることもある。この場合、「false」は整数0に変換され、「true」は整数1に変換される。

整数照合は、整数範囲と演算子もサポートする。整数照合は正の値にのみ適用されることに注意してください。範囲は、コロンで区切られた下限と上限で表現された値であり、両方とも省略される可能性がある。

例えば、「1024:65535」は特権のないポートの範囲を表す有効な範囲であり、「1024:」も機能する。「0:1023」は特権ポートの有効な表現であり、「:1023」も機能する。

特殊なケースとして、一部のACL関数は実際にはドットで区切られた2つの整数である10進数をサポートする。これは、例えば一部のバージョンチェックで使用される。すべての整数プロパティは、範囲と演算子を含むこれらの10進数に適用される。

より簡単な使用のために、比較演算子もサポートされる。範囲で演算子を使用することはあまり意味がなく、強く推奨されないことに注意してください。同様に、値のセットで順序比較を実行することはあまり意味がない。

整数照合で利用可能な演算子は以下の通りである：

  eq : テストされた値が少なくとも1つの値に等しい場合にtrue
  ge : テストされた値が少なくとも1つの値以上である場合にtrue
  gt : テストされた値が少なくとも1つの値より大きい場合にtrue
  le : テストされた値が少なくとも1つの値以下である場合にtrue
  lt : テストされた値が少なくとも1つの値より小さい場合にtrue

例えば、以下のACLは負のContent-Lengthヘッダーと一致する：

  acl negative-length req.hdr_val(content-length) lt 0

これは3.0から3.1（含む）の間のSSLバージョンと一致する：

  acl sslv3 req.ssl_ver 3:3.1

#### 7.1.3. Matching strings

文字列照合は文字列またはバイナリ取得メソッドに適用され、6つの異なる形式で存在する：

  - 正確な照合（-m str）：抽出された文字列はパターンと正確に一致する必要がある。

  - 部分文字列照合（-m sub）：パターンは抽出された文字列内で検索され、その中のいずれかが見つかった場合にACLが一致する。

  - プレフィックス照合（-m beg）：パターンは抽出された文字列の先頭と比較され、その中のいずれかが一致する場合にACLが一致する。

  - サフィックス照合（-m end）：パターンは抽出された文字列の末尾と比較され、その中のいずれかが一致する場合にACLが一致する。

  - サブディレクトリ照合（-m dir）：パターンは抽出された文字列内の任意の場所で検索され、スラッシュ（"/"）、文字列の先頭または末尾で区切られる。その中のいずれかが一致する場合にACLが一致する。そのため、文字列「/images/png/logo/32x32.png」は「/images」、「/images/png」、「images/png」、「/png/logo」、「logo/32x32.png」または「32x32.png」と一致するが、「png」や「32x32」とは一致しない。

  - ドメイン照合（-m dom）：パターンは抽出された文字列内の任意の場所で検索され、ドット（"."）、コロン（":"）、スラッシュ（"/"）、疑問符（"?"）、文字列の先頭または末尾で区切られる。これはURLで使用するために作られている。パターン内の先頭と末尾の区切り文字は無視される。その中のいずれかが一致する場合にACLが一致する。そのため、例の文字列「 http://www1.dc-eu.example.com:80/blah 」では、パターン「http」、「www1」、「.www1」、「dc-eu」、「example」、「com」、「80」、「dc-eu.example」、「blah」、「:www1:」、「dc-eu.example:80」が一致するが、「eu」や「dc」は一致しない。フィルタリングやルーティングのためにドメインサフィックスを照合するために使用することは一般的に良いアイデアではない。ルーティングが別のドメインの前に一致するプレフィックスを付けることで簡単にだまされる可能性があるためである。

文字列照合は、渡される文字列に適用される。バックスラッシュ（"\"）は例外で、スペースなどの一部の文字をエスケープすることが可能にする。最初の文字列の前に「-i」フラグが渡される場合、大文字と小文字を無視してマッチングが実行される。文字列「-i」を照合するために、2番目に設定するか、最初の文字列の前に「--」フラグを渡す。もちろん、文字列「--」を照合するにも同じことが当てはまる。

nullバイト（0x00）を含む可能性があるバイナリ取得には文字列照合を使用しないでください。比較は最初のnullバイトの発生で停止するためである。代わりに、最初にhexコンバーターを使用してバイナリ取得を16進文字列に変換してください。

**例：**

```
# バイナリサンプル内に文字列&lt;tag&gt;が存在する場合に一致する
acl tag_found req.payload(0,0),hex -m sub 3C7461673E
```

#### 7.1.4. Matching regular expressions (regexes)

文字列照合と同様に、正規表現照合は渡される文字列に適用される。バックスラッシュ（"\"）は例外で、スペースなどの一部の文字をエスケープすることが可能にする。最初の正規表現の前に「-i」フラグが渡される場合、大文字と小文字を無視してマッチングが実行される。文字列「-i」を照合するために、2番目に設定するか、最初の文字列の前に「--」フラグを渡す。もちろん、文字列「--」を照合するにも同じ原則が当てはまる。

#### 7.1.5. Matching arbitrary data blocks

抽出されたサンプルを、文字列として安全に表現されない可能性があるバイナリブロックに対して照合することが可能である。このため、マッチメソッドがバイナリに設定されている場合、パターンは偶数の16進数字のシリーズとして渡される必要がある。2つの数字の各シーケンスは1バイトを表す。16進数字は大文字または小文字で使用されることができる。

**例：**

```
# 入力ストリーム内の「Hello\n」と一致（\x48 \x65 \x6c \x6c \x6f \x0a）
acl hello req.payload(0,6) -m bin 48656c6c6f0a
```

#### 7.1.6. Matching IPv4 and IPv6 addresses

IPv4アドレス値は、プレーンアドレスとして、またはネットマスクが付加されて指定されることができ、その場合、IPv4アドレスはネットワーク内にある限り一致する。プレーンアドレスは、解決可能なホスト名に置き換えることもできるが、この慣行は一般的に推奨されない。設定の読み取りとデバッグがより困難になるためである。ホスト名が使用される場合、設定が解析される時点でランダムなDNS一致に依存しないように、少なくとも/etc/hostsに存在することを確認する必要がある。

点付きIPv4アドレス表記は、通常の形式と、すべての0オクテットが省略された省略形式の両方でサポートされる：

    +------------------+------------------+------------------+
    |   Example 1      |     Example 2    |     Example 3    |
    +------------------+------------------+------------------+
    |  192.168.0.1     |   10.0.0.12      |   127.0.0.1      |
    |  192.168.1       |   10.12          |   127.1          |
    |  192.168.0.1/22  |   10.0.0.12/8    |   127.0.0.1/8    |
    |  192.168.1/22    |   10.12/8        |   127.1/8        |
    +------------------+------------------+------------------+

これは192.168.42/24が192.168.42.0/24に相当するRFC 4632 CIDRアドレス表記とは異なることに注意してください。

IPv6は、通常の形式で入力されることができ、ネットマスクが付加されているかどうかに関係なく入力される。IPv6ネットマスクにはビットカウントのみが受け入れられる。ランダムに解決されたIPアドレスで問題が発生するリスクを避けるために、IPv6パターンではホスト名は決して許可されない。

HAProxyは、以下の状況でIPv4アドレスとIPv6アドレスを照合することもできる：

  - テストされたアドレスがIPv4、パターンアドレスがIPv4の場合、マッチはIPv4で適用され、提供されたマスクがある場合はそれを使用する。
  - テストされたアドレスがIPv6、パターンアドレスがIPv6の場合、マッチはIPv6で適用され、提供されたマスクがある場合はそれを使用する。
  - テストされたアドレスがIPv6、パターンアドレスがIPv4の場合、IPv6アドレスが2002:IPV4::、::IPV4、または::ffff:IPV4と一致する場合、パターンのマスクを使用してIPv4でマッチが適用される。そうでなければ失敗する。
  - テストされたアドレスがIPv4、パターンアドレスがIPv6の場合、IPv4アドレスは最初に::ffff:を前に付けることでIPv6に変換され、その後提供されたIPv6マスクを使用してIPv6でマッチが適用される。
### 7.2. Converters

RFC7519の7.2節で指定されている完全なJWT検証を実行しない。例えば、ヘッダーとペイロードの内容がデコードされた後、完全に有効なJSONであることを保証せず、それぞれの内容に関するチェックは実行されない。

可能な戻り値は以下の通りである：

+----+----------------------------------------------------------------------+
| ID | message                                                              |
+----+----------------------------------------------------------------------+
|  0 | "Verification failure"                                               |
|  1 | "Verification success"                                               |
| -1 | "Unknown algorithm (not mentioned in RFC7518)"                       |
| -2 | "Unmanaged algorithm"                                                |
| -3 | "Invalid token"                                                      |
| -4 | "Out of memory"                                                      |
| -5 | "Unknown certificate"                                                |
+----+----------------------------------------------------------------------+

このコンバーターは、HAProxyがUSE_OPENSSLでコンパイルされている場合にのみ利用可能であることに注意してください。

**例：**

```
# 認証ヘッダーからJWTを取得し、そのJOSEヘッダーの「alg」フィールドを抽出し、
# 公開証明書を使用して署名を検証する
http-request set-var(txn.bearer) http_auth_bearer
http-request set-var(txn.jwt_alg) var(txn.bearer),jwt_header_query('$.alg')
http-request deny unless { var(txn.jwt_alg) -m str "RS256" }
http-request deny unless { var(txn.bearer),jwt_verify(txn.jwt_alg,"/path/to/pubkey.pem") 1 }
```

#### 7.2.1. Language converter

**language**(&lt;value&gt;[,&lt;default&gt;])

「req.fhdr」を使用して「accept-language」ヘッダーから抽出されたリストから最高のq-factorを持つ値を返す。q-factorのない値はq-factor 1を持つ。q-factor 0の値は削除される。セミコロンで区切られた&lt;values&gt;のリストに属する値のみが考慮される。引数&lt;value&gt;の構文は「lang[;lang[;lang[;...]]]」である。値が指定されたリストと一致せず、デフォルト値が提供される場合、それが返される。言語名はダッシュ（'-'）の後にバリアントを持つ可能性があることに注意してください。このバリアントがリストに存在する場合、一致するが、存在しない場合、基本言語のみがチェックされる。照合は大文字と小文字を区別し、出力文字列は常に引数で提供されたものの1つである。引数の順序は意味がなく、リクエスト内の値の順序のみが重要である。同じq-factorを共有する複数の値の中で最初の値が使用される。

**例：**

```
# この設定は、リクエストに基づいて特定の言語に一致するバックエンドに切り替える：

acl es req.fhdr(accept-language),language(es;fr;en) -m str es
acl fr req.fhdr(accept-language),language(es;fr;en) -m str fr
acl en req.fhdr(accept-language),language(es;fr;en) -m str en
use_backend spanish if es
use_backend french  if fr
use_backend english if en
default_backend choose_your_language
```

#### 7.2.2. Length converter

**length**

文字列の長さを取得する。これは文字列サンプル取得関数の後、または文字列タイプを返す変換キーワードの後にのみ配置されることができる。結果は整数タイプである。

#### 7.2.3. Lower converter

**lower**

文字列サンプルを小文字に変換する。これは文字列サンプル取得関数の後、または文字列タイプを返す変換キーワードの後にのみ配置されることができる。結果は文字列タイプである。

#### 7.2.4. Local time converter

**ltime**(&lt;format&gt;[,&lt;offset&gt;])

エポックからの日付を含むと想定される整数を、strftime(3)を使用して&lt;format&gt;文字列で定義された形式でローカル時間でこの日付を表す文字列に変換する。目的は、ログで任意の日付形式を使用できるようにすることである。オプションの&lt;offset&gt;（秒単位、正または負）が入力日付に適用されることができる。オペレーティングシステムでサポートされている形式については、strftime()のマニュアルページを参照してください。utimeコンバーターも参照してください。

**例：**

```
# ローカル時間とip:portの2つのコロンを出力する
# 例：20140710162350 127.0.0.1:57325
log-format %[date,ltime(%Y%m%d%H%M%S)]\ %ci:%cp
```

#### 7.2.5. Left trim converter

**ltrim**(&lt;chars&gt;)

入力サンプルの文字列表現の先頭から&lt;chars&gt;の任意の文字をスキップする。

#### 7.2.6. Map converter

**map**(&lt;map_name&gt;[,&lt;default_value&gt;])

map_&lt;match_type&gt;(&lt;map_name&gt;[,&lt;default_value&gt;])
map_&lt;match_type&gt;_&lt;output_type&gt;(&lt;map_name&gt;[,&lt;default_value&gt;])
  &lt;map_name&gt;から&lt;match_type&gt;マッチングメソッドを使用して入力値を検索し、
  関連する値を&lt;output_type&gt;タイプに変換して返す。入力値が&lt;map_name&gt;内で
  見つからない場合、コンバーターは&lt;default_value&gt;を返す。&lt;default_value&gt;が
  設定されていない場合、コンバーターは失敗し、入力値を取得できなかったかのように
  動作する。&lt;match_type&gt;が設定されていない場合、デフォルトは「str」である。
  同様に、&lt;output_type&gt;が設定されていない場合、デフォルトは「str」である。
  便宜上、「map」キーワードは「map_str」のエイリアスであり、文字列を別の文字列に
  マップする。&lt;map_name&gt;は2.7.でマップとACLの名前形式について説明されている
  形式に従う必要がある。

  キー間の重複を避けることが重要である：IPアドレスと文字列はツリーに格納されるため、
  最も細かい一致の最初のものが使用される。他のキーはリストに格納されるため、
  最初の一致する発生が使用される。

  以下の配列には、入力タイプ、マッチタイプ、出力タイプでソートされた利用可能な
  すべてのマップ関数のリストが含まれている。

|input type|match method|output type str|output type int|output type ip|output type key|
|-----------|------------|----------------|----------------|---------------|----------------|
|str|str|map_str|map_str_int|map_str_ip|map_str_key|
|str|beg|map_beg|map_beg_int|map_end_ip|map_end_key|
|str|sub|map_sub|map_sub_int|map_sub_ip|map_sub_key|
|str|dir|map_dir|map_dir_int|map_dir_ip|map_dir_key|
|str|dom|map_dom|map_dom_int|map_dom_ip|map_dom_key|
|str|end|map_end|map_end_int|map_end_ip|map_end_key|
|str|reg|map_reg|map_reg_int|map_reg_ip|map_reg_key|
|str|reg|map_regm|map_reg_int|map_reg_ip|map_reg_key|
|int|int|map_int|map_int_int|map_int_ip|map_int_key|
|ip|ip|map_ip|map_ip_int|map_ip_ip|map_ip_key|

特別なマップ「map_regm」は正規表現内のマッチングゾーンを期待し、出力を変更して
バックリファレンス（「\1」など）を対応するマッチテキストに置き換える。

出力タイプ「key」は、値の代わりに、マッチしたエントリのキー（マップファイルで
見つかったもの）が文字列として返されることを意味する。出力タイプ「key」が使用
される場合、オプションの&lt;default_value&gt;引数はサポートされないことに注意してください。

&lt;map_name&gt;で参照されるファイルには、1行に1つのキー+値が含まれる。'#'で始まる行は
無視され、空行と同様に扱われる。先頭のタブとスペースは削除される。キーは最初の
「word」（スペース/タブ以外の文字のシリーズ）であり、値はこのスペース/タブのシリーズ
の後に続くもので、末尾のスペース/タブを除いて行の終わりまで続く。

**例：**

```
# これはコメントであり、無視される
   2.22.246.0/23    United Kingdom      \n
&lt;-&gt;&lt;-----------&gt;&lt;--&gt;&lt;------------&gt;&lt;----&gt;
 |       |       |         |        `- 末尾のスペースは無視される
 |       |       |         `---------- 値
 |       |       `-------------------- 中間のスペースは無視される
 |       `---------------------------- キー
 `------------------------------------ 先頭のスペースは無視される
```

#### 7.2.7. Modulo converter

**mod**(&lt;value&gt;)

タイプ符号付き整数の入力値を&lt;value&gt;で除算し、剰余を符号付き整数として返す。&lt;value&gt;がnullの場合、ゼロが返される。
### 7.3. Bandwidth limitation filters

&lt;pattern&gt;は7.3節で説明されているサンプル式ルールである。これは分析、抽出、結合され、カウンターを更新するテーブルエントリを選択するために使用される要素を記述する。共有帯域幅制限フィルターでのみ指定される必要がある。

&lt;table&gt;は、デフォルトのものの代わりに使用されるオプションのテーブルである。これは現在のプロキシで宣言されたスティックテーブルである。共有帯域幅制限フィルターでのみ指定されることができる。

&lt;time&gt;は帯域幅制限レートを評価するために使用されるデフォルトの時間期間である。ストリーム単位の帯域幅制限フィルターでのみ指定されることができる。HAProxy時間形式に従い、ミリ秒単位で表現される。

&lt;min-size&gt;は、最後のパケット（より小さい可能性がある）を除いて、ストリームによって一度に転送されるバイト数のオプションの最小値である。この値はストリーム単位および共有帯域幅制限フィルターで指定されることができる。HAProxyサイズ形式に従い、バイト単位で表現される。

帯域幅制限フィルターは、ストリームレベルでデータ転送速度を制限するために使用されるべきである。拡張により、そのようなフィルターはリソースによって消費されるネットワーク帯域幅を制限する。複数の帯域幅制限フィルターを使用することができる。例えば、クライアントが他のクライアントを不利にすることを避けるために、クライアントがネットワーク帯域幅をすべて消費しないことを確実にするために、ソースアドレスごとに制限を定義することが可能である。また、特定のクライアントの複数の接続を公平に処理できるように、ストリームごとに制限を定義することも可能である。

これらのフィルターの定義順序は重要である。複数の帯域幅フィルターがストリームで有効になっている場合、フィルタリングは定義順序で適用される。他のフィルターの定義順序も影響を持つことを理解することも重要である。例えば、HTTP圧縮フィルターが帯域幅制限フィルターの前または後に定義されているかどうかに応じて、制限は圧縮されたペイロードに適用されるかどうかが決まる。キャッシュフィルターについても同様である。

帯域幅制限フィルターには2つの種類がある。最初のものはデフォルトの制限を強制し、ストリームごとに適用される。2番目のものはスティッキネステーブルを使用して、テーブル内の同じエントリを共有するすべてのストリーム間で均等に分割された制限を強制する。

さらに、特定のフィルターについて、使用されるフィルターキーワードに応じて、制限はクライアントから受信されサーバーに転送される着信データ、またはサーバーから受信されクライアントに送信される発信データに適用されることができる。着信データに制限を適用するには、「bwlim-in」キーワードを使用する必要がある。発信データに適用するには、「bwlim-out」キーワードを使用する必要がある。どちらの場合も、帯域幅制限は転送されたデータに適用され、ストリームレベルで適用される。

帯域幅制限はストリームレベルで適用され、接続レベルでは適用されない。多重化プロトコル（H2、H3、FastCGI）の場合、同じ接続のストリームは異なる制限を持つ可能性がある。

ストリーム単位の帯域幅制限フィルターの場合、デフォルト期間と制限を定義する必要がある。その名前が示すように、これらはストリームの帯域幅制限レートを設定するために使用されるデフォルト値である。しかし、この種類のフィルターおよびこれのみについて、フィルターがTCP/HTTP「set-bandwidth-limit」アクションで有効になっている場合、サンプル式を使用してこれらの値を再定義することが可能である。

共有帯域幅制限フィルターの場合、着信データまたは発信データのどちらに適用されるかに応じて、使用されるスティッキネステーブルは対応するバイトレート情報を格納する必要がある。「bytes_in_rate(&lt;period&gt;)」カウンターは着信データを制限するために格納される必要があり、「bytes_out_rate(&lt;period&gt;)」カウンターは発信データを制限するために使用される必要がある。

最後に、帯域幅制限フィルターが特定のストリームに対して一度に転送できる最小バイト数を設定することが可能である。これは、CPU使用率を減らすために、あまりにも小さな量のデータを転送しないために使用されるべきである。慎重に定義される必要がある。値が小さすぎると、CPU使用率が増加する可能性がある。高すぎると、レイテンシが増加する可能性がある。また、定義された帯域幅制限と密接に関連している。帯域幅制限に近すぎる場合、一度に消費されるバイトが多すぎるため、制限を超えないように一部の一時停止が経験される可能性がある。これはフィルター設定に大きく依存する。良いアイデアは、通常2896バイトの2 TCP MSS程度で開始し、いくつかの実験の後に調整することである。

**例：**

```
frontend http
    bind *:80
    mode http

    # このフィルターが有効になっている場合、ストリームは他のすべてのストリームと
    # 同じソースアドレスを持つ10m/sのダウンロード制限を共有する。
    filter bwlim-out limit-by-src key src table limit-by-src limit 10m

    # このフィルターが有効になっている場合、ストリームは他のすべてのストリームとは
    # 独立して1m/sでダウンロードするように制限される。
    filter bwlim-out limit-by-strm default-limit 1m default-period 1s

    # すべてのストリームを1m/s（デフォルト制限）に制限し、内部APIにアクセス
    # するものを100k/sに制限する。各ソースアドレスを10m/sに制限する。
    # 共有制限が最初に適用される。両方ともダウンロードレートを制限している。
    http-request set-bandwidth-limit limit-by-strm
    http-request set-bandwidth-limit limit-by-strm limit 100k if { path_beg /internal }
    http-request set-bandwidth-limit limit-by-src
    ...

backend limit-by-src
    # &lt;limit-by-src&gt;フィルターによって使用されるスティッキネステーブル
    stick-table type ip size 1m expire 3600s store bytes_out_rate(1s)
```

**参照：「tcp-request content set-bandwidth-limit」、「tcp-response content set-bandwidth-limit」、「http-request set-bandwidth-limit」および「http-response set-bandwidth-limit」。**
### 7.4. Pre-defined ACLs

一部の事前定義されたACLはハードコードされているため、それらを必要とするすべてのフロントエンドで宣言する必要がない。混乱を避けるために、それらすべての名前は大文字である。それらの等価性は以下に提供される。

|ACL name|Equivalent to|Usage|
|---------|-------------|-----|
|FALSE|always_false|決して一致しない|
|HTTP|req.proto_http|リクエストプロトコルが有効なHTTPの場合に一致|
|HTTP_1.0|req.ver 1.0|HTTPリクエストバージョンが1.0の場合に一致|
|HTTP_1.1|req.ver 1.1|HTTPリクエストバージョンが1.1の場合に一致|
|HTTP_2.0|req.ver 2.0|HTTPリクエストバージョンが2.0の場合に一致|
|HTTP_3.0|req.ver 3.0|HTTPリクエストバージョンが3.0の場合に一致|
|HTTP_CONTENT|req.hdr_val(content-length) gt 0|HTTPリクエスト内の既存のcontent-lengthと一致|
|HTTP_URL_ABS|url_reg ^[^/:]*://|スキームを持つ絶対URLと一致|
|HTTP_URL_SLASH|url_beg /|"/"で始まるURLと一致|
|HTTP_URL_STAR|url     *|"*"に等しいURLと一致|
|LOCALHOST|src 127.0.0.1/8 ::1|ローカルホストからの接続と一致|
|METH_CONNECT|method  CONNECT|HTTP CONNECTメソッドと一致|
|METH_DELETE|method  DELETE|HTTP DELETEメソッドと一致|
|METH_GET|method  GET HEAD|HTTP GETまたはHEADメソッドと一致|
|METH_HEAD|method  HEAD|HTTP HEADメソッドと一致|
|METH_OPTIONS|method  OPTIONS|HTTP OPTIONSメソッドと一致|
|METH_POST|method  POST|HTTP POSTメソッドと一致|
|METH_PUT|method  PUT|HTTP PUTメソッドと一致|
|METH_TRACE|method  TRACE|HTTP TRACEメソッドと一致|
|RDP_COOKIE|req.rdp_cookie_cnt gt 0|リクエストバッファ内のRDPクッキーの存在と一致|
|REQ_CONTENT|req.len gt 0|リクエストバッファ内のデータと一致|
|TRUE|always_true|常に一致する|
|WAIT_END|wait_end|コンテンツ分析の終了を待つ|
## 8. Logging

HAProxyの強みの一つは、確実にその精密なログにある。おそらく、そのような製品で利用可能な最も細かいレベルの情報を提供しており、これは複雑な環境のトラブルシューティングにおいて非常に重要である。ログで提供される標準的な情報には、クライアントポート、TCP/HTTP状態タイマー、終了時の精密なストリーム状態と精密な終了原因、トラフィックをサーバーに振り分ける決定に関する情報、そしてもちろん任意のヘッダーをキャプチャする機能が含まれる。

管理者の反応性を向上させるために、遭遇した問題（内部と外部の両方）について大きな透明性を提供し、異なるレベルフィルターで同時に異なるソースにログを送信することが可能である：

  - グローバルプロセスレベルのログ（システムエラー、開始/停止など）
  - インスタンスごとのシステムと内部エラー（リソース不足、バグなど）
  - インスタンスごとの外部の問題（サーバーの起動/停止、最大接続数）
  - インスタンスごとのアクティビティ（クライアント接続）、接続確立時または終了時のいずれか
  - リクエストごとのログレベル制御、例：
        http-request set-log-level silent if sensitive_request

異なるレベルのログを異なるログサーバーに分散する機能により、複数の運用チームが相互作用し、できるだけ早く問題を修正することができる。例えば、システムチームはシステム全体のエラーを監視し、アプリケーションチームはサーバーの起動/停止をリアルタイムで監視し、セキュリティチームは1時間の遅延でアクティビティログを分析する可能性がある。
### 8.1 Log levels

TCPとHTTP接続は、日付、時刻、送信元IPアドレス、宛先アドレス、接続時間、応答時間、HTTPリクエスト、HTTPリターンコード、送信されたバイト数、ストリームが終了した条件、さらには交換されたクッキーの値などの情報と共にログに記録される。例えば、特定のユーザーの問題を追跡する。すべてのメッセージは最大2つまで送信される
### 8.2 Log formats

HAProxyは5つのログフォーマットをサポートしている。これらのフォーマット間でいくつかのフィールドが共通しており、以下のセクションで詳細に説明される。それらのいくつかは、特定のオプションに固有のインジケーターにより、設定によって若干異なる場合がある。サポートされているフォーマットは以下の通りである：

  - デフォルトフォーマット、これは非常に基本的で、めったに使用されない。接続が受け入れられた瞬間の着信接続に関する非常に基本的な情報のみを提供する：送信元IP:ポート、宛先IP:ポート、およびフロントエンド名。このモードは最終的に消滅するため、詳細には説明されない。

  - TCPフォーマット、これはより高度である。このフォーマットは、フロントエンドで「option tcplog」が設定されている場合に有効になる。HAProxyは通常、ログ記録前に接続の終了を待つ。このフォーマットは、タイマー、接続数、キューサイズなど、より豊富な情報を提供する。このフォーマットは純粋なTCPプロキシに推奨される。

  - HTTPフォーマット、これはHTTPプロキシ用に最も高度である。このフォーマットは、フロントエンドで「option httplog」が設定されている場合に有効になる。TCPフォーマットと同じ情報に加えて、リクエスト、ステータスコード、ヘッダーとクッキーのキャプチャなど、HTTP固有のフィールドを提供する。このフォーマットはHTTPプロキシに推奨される。

  - CLF HTTPフォーマット、これはHTTPフォーマットと同等であるが、フィールドがCLFフォーマットと同じ順序で配置されている。このモードでは、すべてのタイマー、キャプチャ、フラグなどが、共通フィールドの終了後に、標準HTTPフォーマットで表示されるのと同じ順序で、フィールドごとに1つずつ表示される。

  - カスタムログフォーマット、独自のログ行を作成することができる。

次のセクションでは、これらの各フォーマットの詳細について詳しく説明する。フォーマット仕様は「フィールド」ベースで実行される。特に明記されていない限り、フィールドは任意の数のスペースで区切られたテキストの一部である。syslogサーバーは行の先頭にフィールドを挿入する可能性があるため、最初のフィールドは常にプロセス名と識別子を含むものと仮定される。

注意：ログ行が非常に長い場合があるため、以下のセクションのログ例は複数行に分割される場合がある。ログ例の行は3つの閉じ角括弧（'&gt;&gt;&gt;'）で始まり、ログが複数行に分割されるたびに、最終行以外の各行はバックスラッシュ（'\'）で終わり、次の行は2文字でインデントされて始まる。
### 8.3 Advanced logging options

一部の高度なログオプションは、しばしば求められるが、様々なオプションを見るだけでは見つけ出すのが容易ではない。より良いログ記録を可能にするいくつかのオプションのためのエントリーポイントをここに示す。使用方法の詳細については、キーワードリファレンスを参照してください。

#### 8.3.1 Disabling logging of external tests

HAProxyでヘルスチェックを実行する監視ツールがあることは非常に一般的である。時には、LVSやその他の商用ロードバランサーなどのレイヤー3ロードバランサーであり、時には単純にNagiosなどのより完全な監視システムである。テストが非常に頻繁な場合、ユーザーはしばしばそれらのチェックのログ記録を無効にする方法を尋ねる。3つの可能性がある：

  - 接続がどこからでも来て、単なるTCPプローブである場合、フロントエンドで「option dontlognull」を設定することにより、データ交換のない接続のログ記録を単純に無効にすることがしばしば望まれる。また、ポートスキャンのログ記録も無効になり、これは望まれる場合もあればそうでない場合もある。

  - 様々な条件（送信元ネットワーク、パス、ユーザーエージェントなど）を使用して「http-request set-log-level silent」アクションを使用することが可能である。

  - テストが既知のURIで実行される場合、「monitor-uri」を使用してこのURIを監視専用として宣言する。このリクエストを送信するホストは、ヘルスチェックの結果のみを受け取り、リクエストはログに記録されない。

#### 8.3.2 Logging before waiting for the stream to terminate

接続終了時のログ記録の問題は、リモートターミナルセッションや大きなファイルダウンロードなどの非常に長いストリーム中に何が起こっているかについて手がかりがないことである。この問題は、フロントエンドで「option logasap」を指定することにより回避できる。HAProxyはその後、できるだけ早く、データ転送が開始する直前にログを記録する。これは、TCPの場合、サーバーへの接続状態をまだログに記録し、HTTPの場合、サーバーヘッダーの処理直後にログを記録することを意味する。この場合、報告されるバイト数は、クライアントに送信されたヘッダーバイト数である。通常のログとの混乱を避けるために、合計時間フィールドとバイト数は「+」記号で始まり、これは実際の数値が確実に大きいことを意味する。

#### 8.3.3 Raising log level upon errors

時には、エラーログから通常のトラフィックを分離することがより便利である。例えば、ログファイルからのエラー監視を容易にするためである。「log-separate-errors」オプションが使用される場合、エラー、タイムアウト、リトライ、リディスパッチ、またはHTTPステータスコード5xxを経験した接続は、syslogレベルが「info」から「err」に引き上げられる。これは、syslogデーモンがログを別のファイルに保存するのに役立つ。ログの順序が変更されないように、エラーを通常のトラフィックファイルにも保持することが非常に重要である。syslogデーモンが既に「notice」より高いすべてのログを「admin」ファイルに保存するように設定している場合は注意する必要がある。なぜなら「err」レベルは「notice」より高いからである。

#### 8.3.4 Disabling logging of successful connections

最初は奇妙に聞こえるかもしれないが、一部の大規模サイトは毎秒数千のログを処理する必要があり、それらを長期間無傷で保持したり、その中でエラーを検出することに困難を経験している。フロントエンドで「option dontlog-normal」が設定されている場合、すべての正常な接続はログに記録されない。この点で、正常な接続は、エラー、タイムアウト、リトライ、リディスパッチのないものとして定義される。HTTPでは、ステータスコードもチェックされ、ステータス5xxのレスポンスは正常とは見なされず、ログにも記録される。もちろん、これを行うことは本当に推奨されない。なぜなら、ログから有用な情報の大部分が削除されるからである。他の選択肢がない場合のみこれを行う。

#### 8.3.5 Log profiles

「log-format」、「log-format-sd」、「error-log-format」、または「log-tag」などの一部のディレクティブが、ログフォーマットをグローバルまたはプロキシレベルで設定することを可能にするが、そのような設定をログエンドポイントにできるだけ近い場所、つまり「log」ディレクティブごとに設定することが適切である場合がある。

ここで「log-profile」セクションが役立つ：「log-profile」は設定のどこでも定義される場合がある。このセクションは、特定の`log`ディレクティブに対して発行されるログがどのように構築されるべきかを記述するために使用される異なるキーワードのセットを受け入れる。

「log」ディレクティブから、名前で特定のログプロファイルを使用することを選択できる。同じプロファイルは複数の「log」ディレクティブから使用される場合がある。
### 8.4 Timing events

タイマーはネットワーク問題のトラブルシューティングにおいて大きな助けを提供する。すべての値はミリ秒（ms）で報告される。これらのタイマーは、ストリーム終了フラグと組み合わせて使用されるべきである。フロントエンドで「option tcplog」が設定されているTCPモードでは、3つの制御点が「Tw/Tc/Tt」の形式で報告され、HTTPモードでは、5つの制御点が「TR/Tw/Tc/Tr/Ta」の形式で報告される。さらに、3つの他の測定値「Th」、「Ti」、「Tq」が提供される。

HTTPモードでのタイミングイベント：
```txt
                 first request               2nd request
      |&lt;--------------------------------&gt;|&lt;-------------- ...
      t         tr                       t    tr ...
   ---|----|----|----|----|----|----|----|----|--
      : Th   Ti   TR   Tw   Tc   Tr   Td : Ti   ...
      :&lt;---- Tq ----&gt;:                   :
      :&lt;-------------- Tt --------------&gt;:
      :&lt;--        -----Tu---------------&gt;:
                :&lt;--------- Ta ---------&gt;:
```
TCPモードでのタイミングイベント：
```txt
           TCP session
      |&lt;-----------------&gt;|
      t                   t
   ---|----|----|----|----|---
      | Th   Tw   Tc   Td |
      |&lt;------ Tt -------&gt;|
```
  - Th: TCP接続を受け入れ、低レベルプロトコルのハンドシェイクを実行するための合計時間。現在、これらのプロトコルはproxy-protocolとSSLである。これは接続の生涯中に一度だけ発生する場合がある。ここで大きな時間は、クライアントが話すことなく事前に接続を確立しただけであること、または合理的な時間内にハンドシェイクを完了することを妨げるネットワーク問題を経験していること（例：MTU問題）、またはSSLハンドシェイクの計算が非常に高価であったことを示す場合がある。この時間は最初のリクエストの前にのみ報告されるため、償却値を計算するためにすべてのリクエストで平均化することは安全である。2番目以降のリクエストは常にここでゼロを報告する。

    このタイマーは、ログフォーマットエイリアスとして%Th、サンプルフェッチとしてfc.timer.handshakeと命名される。

  - Ti: HTTPリクエスト前のアイドル時間（HTTPモードのみ）。このタイマーは、ハンドシェイクの終了とHTTPリクエストの最初のバイトの間をカウントする。keep-aliveモードで2番目のリクエストを処理する場合、前のレスポンスの送信終了後にカウントを開始する。HTTP/2などの多重化プロトコルが使用される場合、前のリクエストの直後にカウントを開始する。一部のブラウザは、将来のリクエストの遅延を減らすためにサーバーへの接続を事前に確立し、必要になるまでそれらを保留状態に保つ。この遅延はアイドル時間として報告される。-1の値は、接続で何も受信されなかったことを示す。

    このタイマーは、ログフォーマットエイリアスとして%Ti、サンプルフェッチとしてreq.timer.idleと命名される。

  - TR: クライアントリクエストを取得するための合計時間（HTTPモードのみ）。最初のバイトを受信してから、プロキシがHTTPヘッダーの終わりを示す空行を受信した瞬間までの経過時間である。「-1」の値は、ヘッダーの終わりが一度も見られなかったことを示す。これは、クライアントが早期に閉じるか、タイムアウトした場合に発生する。この時間は通常非常に短い。なぜなら、ほとんどのリクエストは単一のパケットに収まるからである。大きな時間は、テスト中に手動で入力されたリクエストを示す場合がある。

    このタイマーは、ログフォーマットエイリアスとして%TR、サンプルフェッチとしてreq.timer.hdrと命名される。

  - Tq: 受け入れ日時から、または前のレスポンスの最後のバイトの送信からクライアントリクエストを取得するための合計時間（HTTPモードのみ）。これは、それらのいずれかが-1でない限り、Th + Ti + TRと正確に等しい。それらのいずれかが-1の場合、-1も返される。このタイマーは、HTTP keep-aliveとブラウザの事前接続機能の到着前に非常に有用であった。アイドル時間がレポートに多くのノイズを追加するため、現在はTRの代わりにこれを削除することが推奨される。

    このタイマーは、ログフォーマットエイリアスとして%Tq、サンプルフェッチとしてreq.timer.tqと命名される。

  - Tw: 接続スロットを待つキューで費やされた合計時間。これはバックエンドキューとサーバーキューの両方を考慮し、キューサイズとサーバーが前のリクエストを完了するために必要な時間に依存する。「-1」の値は、リクエストがキューに到達する前にキルされたことを意味し、これは一般的に無効または拒否されたリクエストで起こることである。

    このタイマーは、ログフォーマットエイリアスとして%Tw、サンプルフェッチとしてreq.timer.queueと命名される。

  - Tc: サーバーへのTCP接続を確立するための合計時間。プロキシが接続リクエストを送信した瞬間から、サーバーによって確認された瞬間まで、またはTCP SYNパケットから戻りのSYN/ACKパケットまでの経過時間である。「-1」の値は、接続が一度も確立されなかったことを意味する。

    このタイマーは、ログフォーマットエイリアスとして%Tc、サンプルフェッチとしてbc.timer.connectと命名される。

  - Tr: サーバー応答時間（HTTPモードのみ）。サーバーへのTCP接続が確立された瞬間から、サーバーが完全なレスポンスヘッダーを送信した瞬間までの経過時間である。これは純粋にリクエスト処理時間を示し、データ送信によるネットワークオーバーヘッドは含まれない。クライアントがサーバーに送信するデータがある場合、例えばPOSTリクエスト中、時間は既に実行されており、これは見かけの応答時間を歪める可能性があることに注意する価値がある。この理由により、信頼されていないネットワークの背後にあるクライアントから開始されたPOSTリクエストに対して、このフィールドをあまり信頼しないことが一般的に賢明である。ここで「-1」の値は、最後のレスポンスヘッダー（空行）が一度も見られなかったことを意味し、おそらくサーバーがリクエストを処理する前にサーバータイムアウトが発生したか、サーバーが無効なレスポンスを返したためである。

    このタイマーは、ログフォーマットエイリアスとして%Tr、サンプルフェッチとしてres.timer.hdrと命名される。

  - Td: これは、クライアントに送信された最後のバイトまでのレスポンスペイロードの合計転送時間である。HTTPでは、最後のレスポンスヘッダー（Trの後）の後に開始される。

    送信されたデータは、クライアントによって受信されることが保証されておらず、カーネルまたはネットワークのいずれかで詰まる可能性がある。

    このタイマーは、ログフォーマットエイリアスとして%Td、サンプルフェッチとしてres.timer.dataと命名される。

  - Ta: HTTPリクエストの合計アクティブ時間、プロキシがリクエストヘッダーの最初のバイトを受信した瞬間から、レスポンスボディの最後のバイトを送信した瞬間まで。「logasap」オプションが指定されている場合を除く。この場合、これは（TR+Tw+Tc+Tr）にのみ等しく、「+」記号で始まる。このフィールドから、有効な場合に他のタイマーを減算することにより、「Td」、データ送信時間を推論できる：

        Td = Ta - (TR + Tw + Tc + Tr)

    「-1」値のタイマーは、この方程式から除外される必要がある。「Ta」が負になることは決してないことに注意する。

    このタイマーは、ログフォーマットエイリアスとして%Ta、サンプルフェッチとしてtxn.timer.totalと命名される。

  - Tt: 合計ストリーム継続時間、プロキシがそれを受け入れた瞬間から両端が閉じられた瞬間まで。「logasap」オプションが指定されている場合を除く。この場合、これは（Th+Ti+TR+Tw+Tc+Tr）にのみ等しく、「+」記号で始まる。このフィールドから、有効な場合に他のタイマーを減算することにより、「Td」、データ送信時間を推論できる：

        Td = Tt - (Th + Ti + TR + Tw + Tc + Tr)

    「-1」値のタイマーは、この方程式から除外される必要がある。TCPモードでは、「Ti」、「Tq」、「Tr」も除外される必要がある。「Tt」が負になることは決してなく、HTTPでは、Ttは単純に（Th+Ti+Ta）に等しいことに注意する。

    このタイマーは、ログフォーマットエイリアスとして%Tt、サンプルフェッチとしてfc.timer.totalと命名される。

  - Tu: クライアントから見た推定合計時間、プロキシがそれを受け入れた瞬間から両端が閉じられた瞬間まで、アイドル時間なし。これは、リクエスト間のkeep-alive時間からのアイドル時間汚染なしで、ユーザーが見るエンドツーエンド時間を大まかに測定するのに有用である。このタイマーは、ネットワーク遅延が両方向で同じであると仮定するため、ユーザーが見る時間の推定値のみである。「logasap」オプションが指定されている場合を除く。この場合、これは（Th+TR+Tw+Tc+Tr）にのみ等しく、「+」記号で始まる。

    このタイマーは、ログフォーマットエイリアスとして%Tu、サンプルフェッチとしてtxn.timer.userと命名される。

これらのタイマーは、問題の原因について貴重な指示を提供する。TCPプロトコルは3、6、12...秒の再送信遅延を定義するため、3秒の倍数に近いタイマーは、ネットワーク問題（配線、ネゴシエーション、輻輳）によるパケット損失に関連していることが確実である。さらに、「Ta」または「Tt」が設定で指定されたタイムアウト値に近い場合、ストリームがタイムアウトで中止されたことを意味することが多い。

最も一般的なケース：

  - 「Th」または「Ti」が3000に近い場合、クライアントとプロキシの間でパケットが失われた可能性が高い。これはローカルネットワークでは非常にまれであるが、クライアントが遠隔ネットワークにあり、大きなリクエストを送信する場合に発生する可能性がある。ネットワークの原因なしに、ここで通常より大きい値が表示される場合がある。時には、攻撃中またはリソース不足が終了した直後に、HAProxyが数ミリ秒で数千の接続を受け入れる場合がある。これらの接続を受け入れるために費やされた時間は、必然的に他の接続の処理をわずかに遅延させ、数千の新しい接続が一度に受け入れられた後に、数十ミリ秒のオーダーのリクエスト時間が測定される場合がある。keep-aliveモードのいずれかを使用すると、「Ti」が追加のリクエストを待つために費やされた時間を測定するため、より大きなアイドル時間が表示される場合がある。

  - 「Tc」が3000に近い場合、サーバー接続フェーズ中にサーバーとプロキシの間でパケットが失われた可能性が高い。この値は常に非常に低い必要がある。例えば、ローカルネットワークでは1ms、遠隔ネットワークでは数十ms未満である。

  - 「Tr」が常に3000未満であるが、平均が3000で増加したように見えるまれな値がある場合、プロキシとサーバーの間で一部のパケットが失われた可能性が高い。

  - 「Ta」が小さなバイト数でも大きい場合、一般的に、クライアントもサーバーも、HAProxyがトンネルモードで実行中で両方がkeep-alive接続モードに同意している間、接続を閉じることを決定しないためである。この問題を解決するために、フロントエンドまたはバックエンドのいずれかでkeep-aliveまたはcloseオプションを操作するHTTPオプションのいずれかを指定する必要がある。接続制御がサーバーの「maxconn」オプションで使用される場合、可能な限り小さい「Ta」または「Tt」を持つことは重要である。なぜなら、別の接続が解放されるまで、サーバーに新しい接続が送信されないからである。

他の注目すべきHTTPログケース（'xx'は無視される任意の値を意味する）：

  TR/Tw/Tc/Tr/+Ta  「option logasap」がフロントエンドに存在し、ログがデータフェーズの前に発行された。すべてのタイマーは有効であるが、「Ta」は現実より短い。

  -1/xx/xx/xx/Ta   クライアントが時間内に完全なリクエストを送信できなかったか、早すぎる段階で中止した。ストリーム終了フラグをチェックし、その後「timeout http-request」と「timeout client」設定をチェックする。

  TR/-1/xx/xx/Ta   リクエストを処理することができなかった。おそらく、サーバーが故障していたか、リクエストが無効であったか、ACLルールによって禁止されていたためである。ストリーム終了フラグをチェックする。

  TR/Tw/-1/xx/Ta   サーバーで接続を確立できなかった。サーバーが積極的に拒否したか、Ta-(TR+Tw)ms後にタイムアウトした。ストリーム終了フラグをチェックし、その後「timeout connect」設定をチェックする。tarpitアクションが同様のパターンを返す可能性があることに注意する。「Tw」はクライアント接続が開いたまま維持された時間に等しい。

  TR/Tw/Tc/-1/Ta   サーバーが接続を受け入れたが、時間内に完全なレスポンスを返さなかったか、Ta-(TR+Tw+Tc)ms後に予期せずに接続を閉じた。ストリーム終了フラグをチェックし、その後「timeout server」設定をチェックする。
### 8.5 Stream state at disconnection

TCPとHTTPログは、「termination_state」フィールドでストリーム終了インジケーターを提供する。これはアクティブ接続数の直前にある。TCPモードでは2文字の長さで、HTTPモードでは4文字に拡張され、それぞれが特別な意味を持つ：

  - 最初の文字では、ストリームの終了を引き起こした最初のイベントを報告するコード：

        C : TCPセッションがクライアントによって予期せず中止された。

        S : TCPセッションがサーバーによって予期せず中止されたか、サーバーが明示的に拒否した。

        P : ストリームまたはセッションがプロキシによって早期に中止された。接続制限の強制、DENYフィルターが一致した、サーバーレスポンスで情報漏洩を引き起こす可能性のある危険なエラーを検出してブロックしたセキュリティチェック（例：キャッシュ可能なクッキー）のため。

        L : ストリームがHAProxyによってローカルに処理された。

        R : プロキシのリソースが枯渇した（メモリ、ソケット、送信元ポートなど）。通常、これは接続フェーズ中に表示され、システムログには正確なエラーのコピーが含まれる必要がある。これが発生した場合、できるだけ早く何らかの手段で修正されるべき非常に深刻な異常として考慮される必要がある。

        I : 内部エラーが自己チェック中にプロキシによって識別された。これは決して発生すべきではなく、これを含むログを報告することが奨励される。なぜなら、これはほぼ確実にバグであるからである。メモリ破損によって引き起こされた場合に備えて、そのようなイベントの後に予防的にプロセスを再起動することも賢明である。

        D : サーバーがダウンとして検出され、ダウン時にすべての接続をキルするように設定されていたため、ストリームがHAProxyによってキルされた。

        U : アクティブサーバーがアップとして検出され、アップ時にすべてのバックアップ接続をキルするように設定されていたため、このバックアップサーバーでストリームがHAProxyによってキルされた。

        K : ストリームがHAProxyを操作する管理者によって積極的にキルされた。

        c : クライアントがデータを送信または受信するのを待っている間、クライアント側のタイムアウトが期限切れになった。

        s : サーバーがデータを送信または受信するのを待っている間、サーバー側のタイムアウトが期限切れになった。

        - : 正常なストリーム完了、クライアントとサーバーの両方がバッファに何も残さずに閉じられた。

  - 2番目の文字では、閉じられた時のTCPまたはHTTPストリーム状態：

        R : プロキシがクライアントからの完全で有効なREQUESTを待っていた（HTTPモードのみ）。何もサーバーに送信されなかった。

        Q : プロキシがQUEUEで接続スロットを待っていた。これは、サーバーに'maxconn'パラメータが設定されている場合にのみ発生する。また、死にかけのサーバーへの接続試行が失敗した後のリディスパッチに続いて、グローバルキューでも発生する可能性がある。リディスパッチが報告されない場合、どのサーバーにも接続試行が行われなかった。

        C : プロキシがサーバーでのCONNECTION確立を待っていた。サーバーは最大で接続試行に気づいた可能性がある。

        H : プロキシがサーバーからの完全で有効なレスポンスHEADERSを待っていた（HTTPのみ）。

        D : ストリームがDATAフェーズにあった。

        L : サーバーが既に終了していた間、プロキシがまだクライアントにLASTデータを送信していた。これは非常にまれである。なぜなら、クライアントが最後のパケットを受信中に死亡した場合にのみ発生する可能性があるからである。

        T : リクエストがtarpitされた。「timeout tarpit」期間全体またはクライアントが閉じるまで、クライアントと共に開いたまま保持された。どちらも「Tw」タイマーで報告される。

        - : データ転送終了後の正常なストリーム完了。

  - 3番目の文字は、永続性クッキーがクライアントによって提供されたかどうかを示す（HTTPモードのみ）：

        N : クライアントがクッキーを提供しなかった。これは通常、新しい訪問者の場合であるため、ログでこのフラグの出現回数をカウントすることは、一般的にサイト訪問の有効な傾向を示す。

        I : クライアントが既知のサーバーと一致しない無効なクッキーを提供した。これは、最近の設定変更、HTTP/HTTPSサイト間の混合クッキー、条件付きで無視される永続性、または攻撃によって引き起こされた可能性がある。

        D : クライアントがDOWN状態のサーバーを指定するクッキーを提供した。したがって、「option persist」が使用され、クライアントがこのサーバーに送信されたか、設定されず、クライアントが別のサーバーにリディスパッチされた。

        V : クライアントが有効なクッキーを提供し、関連するサーバーに送信された。

        E : クライアントが有効なクッキーを提供したが、最後の日付が「maxidle」クッキーパラメータで許可されているものより古かったため、クッキーは期限切れと見なされ、無視される。リクエストは、クッキーがなかったかのようにリディスパッチされる。

        O : クライアントが有効なクッキーを提供したが、最初の日付が「maxlife」クッキーパラメータで許可されているものより古かったため、クッキーは古すぎると見なされ、無視される。リクエストは、クッキーがなかったかのようにリディスパッチされる。

        U : クッキーが存在したが、他のサーバー選択メカニズムが代わりに使用されたため、サーバー選択に使用されなかった（通常は「use-server」ルール）。

        - : 適用されない（設定でクッキーが設定されていない）。

  - 最後の文字は、サーバーによって返された永続性クッキーに対して実行された操作を報告する（HTTPモードのみ）：

        N : サーバーによってクッキーが提供されず、挿入もされなかった。

        I : サーバーによってクッキーが提供されず、プロキシが1つを挿入した。「cookie insert」モードでは、サーバーがクッキーを提供する場合、それも上書きされ、ここで「I」として報告されることに注意する。

        U : プロキシがクライアントによって提示されたクッキーの最後の日付を更新した。これは「maxidle」を使用した挿入モードでのみ発生する可能性がある。クッキーで示された日付とは異なる日付でアクティビティがあるたびに発生する。リディスパッチなどの他の変更が発生した場合、クッキーは挿入されたものとしてマークされる。

        P : クッキーがサーバーによって提供され、そのまま送信された。

        R : サーバーによって提供されたクッキーがプロキシによって書き換えられた。これは「cookie rewrite」または「cookie prefix」モードで発生する。

        D : サーバーによって提供されたクッキーがプロキシによって削除された。

        - : 適用されない（設定でクッキーが設定されていない）。

最初の2つのフラグの組み合わせは、ストリームまたはセッションが終了した時に何が起こっていたか、そしてなぜ終了したかについて多くの情報を与える。サーバー飽和、ネットワーク問題、ローカルシステムリソース不足、攻撃などを検出するのに役立つ。

最も一般的な終了フラグの組み合わせを以下に示す。これらはアルファベット順に並べられており、大文字セットの直後に小文字セットが配置されており、見つけやすく理解しやすくなっている。

  フラグ   理由

     --   正常終了。

     CC   サーバーへの接続が確立される前にクライアントが中止した。これは、HAProxyが最近死亡した（またはチェックされていない）サーバーに接続しようとし、HAProxyがサーバーの応答または「timeout connect」の期限切れを待っている間にクライアントが中止した場合に発生する可能性がある。

     CD   クライアントがデータ転送中に予期せずに中止した。これは、ブラウザクラッシュ、クライアントとHAProxyの間の中間機器が積極的に接続を切断することを決定したこと、クライアントとHAProxyの間のネットワークルーティング問題、またはサーバーとクライアントの間のkeep-aliveストリームがクライアントによって最初に終了されたことによって引き起こされる可能性がある。

     cD   クライアントが「timeout client」遅延の間、データを送信も確認応答もしなかった。これは、クライアント側のネットワーク障害、またはクライアントが単純にネットワークを不潔に離れることによって引き起こされることが多い。

     CH   クライアントがサーバーが応答を開始するのを待っている間に中止した。サーバーが応答するのに時間がかかりすぎるか、クライアントが「停止」ボタンを早すぎる段階でクリックした可能性がある。

     cH   POSTリクエスト中にクライアントデータを待っている間に「timeout client」が発生した。これは、PPPoEネットワークがフルサイズパケットを転送できないため、クライアント側でTCP MSS値が大きすぎることによって引き起こされる場合がある。また、クライアントタイムアウトがサーバータイムアウトより小さく、サーバーが応答するのに時間がかかりすぎる場合にも発生する可能性がある。

     CQ   クライアントが、十分な空きスロットを持つサーバーがそれを受け入れるのを待つキュー内のストリームが中止された。すべてのサーバーが飽和していたか、割り当てられたサーバーが応答するのに時間がかかりすぎていた可能性がある。

     CR   クライアントが完全なHTTPリクエストを送信する前に中止した。おそらく、リクエストはtelnetクライアントを使用して手動で入力され、早すぎる段階で中止された。HTTPステータスコードはここで400である可能性が高い。時には、IDSがHAProxyとクライアントの間の接続をキルすることによっても引き起こされる可能性がある。「option http-ignore-probes」を使用して、データ転送のない接続を無視することができる。

     cR   「timeout http-request」がクライアントが完全なHTTPリクエストを送信する前に発生した。これは、PPPoEネットワークがフルサイズパケットを転送できないため、クライアント側でTCP MSS値が大きすぎること、またはクライアントが手動でリクエストを送信し、十分に速く入力しないか、リクエストの最後に空行を入力するのを忘れることによって引き起こされる場合がある。HTTPステータスコードはここで408である可能性が高い。注意：最近、一部のブラウザが「事前接続」機能の実装を開始した。これは、ユーザーがそれらを訪問したい場合に備えて、最近訪問したWebサイトに推測的に接続することで構成される。これにより、Webサイトへの多くの接続が確立され、タイムアウトが最初に発生した場合は408 Request Timeoutで終了し、ブラウザが最初にそれらを閉じることを決定した場合は400 Bad Requestで終了する。これらはログを汚染し、エラーカウンターを供給する。一部のブラウザの一部のバージョンは、エラーコードを表示することも報告されている。フロントエンドに「option http-ignore-probes」を追加することにより、この動作の望ましくない効果を回避することができる。これにより、ゼロデータ転送の接続が完全に無視される。ただし、これにより、接続性問題を経験している人々のエラーが確実に隠される。

     CT   クライアントがストリームがtarpitされている間に中止した。間違ったtarpitルールが書かれていないことを確認するために、これが有効なリクエストで発生するかどうかをチェックすることが重要である。多くのリクエストが発生する場合、「timeout tarpit」値を報告された平均「Tw」タイマーに近い何かに下げることで意味がある場合がある。少数の攻撃者のためにリソースを消費しないようにするためである。

     LC   リクエストが傍受され、HAProxyによってローカルに処理された。リクエストはサーバーに送信されなかった。これは、サーバー行の「redir」パラメータによるリダイレクトの場合にのみ発生する。

     LR   リクエストが傍受され、HAProxyによってローカルに処理された。リクエストはサーバーに送信されなかった。一般的に、リダイレクトが返された、HTTP return文が処理された、またはリクエストがアプレット（stats、cache、Prometheus exported、lua applet...）によって処理されたことを意味する。

     LH   レスポンスが傍受され、HAProxyによってローカルに処理された。一般的に、リダイレクトが返されたか、HTTP return文が処理されたことを意味する。

     SC   サーバーまたはそれとHAProxyの間の機器がTCP接続を明示的に拒否した（プロキシはTCP RSTまたはICMPメッセージを戻りとして受信した）。一部の状況では、サーバーが到達不能であることをプロキシに伝えるネットワークスタックである可能性もある（例：ルートなし、またはローカルネットワークでARP応答なし）。これがHTTPモードで発生する場合、ステータスコードはここで502または503である可能性が高い。

     sC   サーバーへの接続が完了する前に「timeout connect」が発生した。これがHTTPモードで発生する場合、ステータスコードはここで503または504である可能性が高い。

     SD   サーバーとの接続がデータ転送中にエラーで死亡した。これは通常、HAProxyがサーバーとのデータ交換中にサーバーからRSTまたは中間機器からICMPメッセージを受信したことを意味する。これは、サーバークラッシュまたは中間機器のネットワーク問題によって引き起こされる可能性がある。

     sD   サーバーがデータフェーズ中に「timeout server」設定の間、データを送信も確認応答もしなかった。これは、サーバーの前のL4機器（ファイアウォール、ロードバランサーなど）でのタイムアウトが短すぎること、およびクライアントとサーバーの間で維持されたkeep-aliveセッションがHAProxyで最初に期限切れになることによって引き起こされることが多い。

     SH   サーバーが完全なHTTPレスポンスヘッダーを送信する前に中止したか、リクエスト処理中にクラッシュした。この瞬間にサーバーが中止することは非常にまれであるため、クラッシュしたかどうか、そしてなぜクラッシュしたかを制御するためにログを検査することが賢明である。ログに記録されたリクエストは、アプリケーションのバグを示す問題のあるリクエストの小さなセットを示す可能性がある。時には、IDSがHAProxyとサーバーの間の接続をキルすることによっても引き起こされる可能性がある。

     sH   サーバーがレスポンスヘッダーを返す前に「timeout server」が発生した。これは最も一般的な異常であり、おそらくサーバーまたはデータベース飽和によって引き起こされる、長すぎるトランザクションを示す。即座の回避策は「timeout server」設定を増やすことで構成されるが、ユーザーエクスペリエンスがこれらの長い応答時間から苦しむことを心に留めておくことが重要である。長期的な唯一の解決策は、アプリケーションを修正することである。

     sQ   ストリームがキューで時間を費やしすぎて期限切れになった。「timeout queue」と「timeout connect」設定をチェックして、これが頻繁に発生する場合の修正方法を見つける。短時間で大量に発生する場合、影響を受けるサーバーでのI/Oまたはデータベース輻輳、または外部攻撃によって引き起こされる飽和による一般的な問題を示す可能性がある。

     PC   プロキシがサーバーへの接続を確立することを拒否した。なぜなら、接続を試行中にプロセスのソケット制限に達したからである。グローバル「maxconn」パラメータを設定で増やすことで、これが再び発生しないようにできる。このステータスは非常にまれで、グローバル「ulimit-n」パラメータが手動で強制される場合に発生する可能性がある。

     PD   プロキシが、サーバーがヘッダーを発行した後、リクエストまたはレスポンスで不正確にフォーマットされたチャンクエンコードメッセージをブロックした。ほとんどの場合、これはサーバーからクライアントへの無効なメッセージを示す。HAProxyは最大2GB - 1（2147483647バイト）のチャンクサイズをサポートする。これより大きいサイズはエラーと見なされる。

     PH   プロキシがサーバーのレスポンスをブロックした。なぜなら、無効、不完全、危険（キャッシュ制御）、またはセキュリティフィルターに一致したからである。いずれの場合も、HTTP 502エラーがクライアントに送信される。このエラーの可能な原因の1つは、許可されていない文字を含むHTTPヘッダー名の無効な構文である。また、サーバーが応答する前に、無効な構文のためにクライアントからのチャンクエンコードリクエストがプロキシによってブロックされる可能性もあるが、これは非常にまれである。この場合、HTTP 400エラーがクライアントに送信され、ログに報告される。最後に、レスポンスでのHTTPヘッダー書き換えの失敗による可能性もある。この場合、HTTP 500エラーが送信される（詳細については「tune.maxrewrite」と「http-response strict-mode」を参照）。

     PR   プロキシがクライアントのHTTPリクエストをブロックした。無効なHTTP構文のため、この場合クライアントにHTTP 400エラーを返したか、denyフィルターが一致したため、この場合クライアントにHTTP 403エラーを返した。また、リクエストでのHTTPヘッダー書き換えの失敗による可能性もある。この場合、HTTP 500エラーが送信される（詳細については「tune.maxrewrite」と「http-request strict-mode」を参照）。

     PT   プロキシがクライアントのリクエストをブロックし、500サーバーエラーを返す前に接続をtarpitした。何もサーバーに送信されなかった。接続は「Tw」タイマーフィールドで報告された間、開いたまま維持された。

     RC   ローカルリソースが枯渇した（メモリ、ソケット、送信元ポート）。これにより、サーバーへの接続の確立が妨げられた。エラーログは、何が不足していたかを正確に伝える。これは非常にまれで、適切なシステムチューニングによってのみ解決できる。

最後の2つのフラグの組み合わせは、永続性がクライアント、サーバー、およびHAProxyによってどのように処理されたかについて多くの情報を与える。これは、ユーザーが再認証する必要があると不平を言う切断のトラブルシューティングにおいて非常に重要である。一般的に遭遇するフラグは：

     --   永続性クッキーが有効になっていない。

     NN   クッキーがクライアントによって提供されず、レスポンスに挿入もされなかった。例えば、これはGETリクエストで「postonly」が設定された挿入モードである可能性がある。

     II   クライアントによって無効なサーバーを指定するクッキーが提供され、有効なクッキーがレスポンスに挿入された。これは通常、「server」エントリが設定から削除された場合に発生する。なぜなら、他のサーバーがそれを知らない場合、クライアントによってそのクッキー値が提示される可能性があるからである。

     NI   クッキーがクライアントによって提供されず、1つがレスポンスに挿入された。これは通常、「insert」モードのすべてのユーザーからの最初のリクエストで発生し、実際のユーザーをカウントする簡単な方法となる。

     VN   クッキーがクライアントによって提供されたが、レスポンスに挿入されなかった。これは、クライアントが既にクッキーを持っているほとんどのレスポンスで発生する。

     VU   クッキーがクライアントによって提供されたが、最後の訪問日が完全に最新ではないため、更新されたクッキーがレスポンスで提供された。また、日付が全くない場合、または日付があるが「maxidle」パラメータが設定されていないため、クッキーを無制限時間に切り替えることができる場合にも発生する可能性がある。

     EI   クッキーがクライアントによって提供されたが、最後の訪問日が「maxidle」パラメータに対して古すぎるため、クッキーは無視され、新しいクッキーがレスポンスに挿入された。

     OI   クッキーがクライアントによって提供されたが、最初の訪問日が「maxlife」パラメータに対して古すぎるため、クッキーは無視され、新しいクッキーがレスポンスに挿入された。

     DI   クッキーによって指定されたサーバーがダウンしていた。新しいサーバーが選択され、新しいクッキーがレスポンスで発行された。

     VI   クッキーによって指定されたサーバーは死亡としてマークされていなかったが、到達できなかった。リディスパッチが発生し、別のサーバーが選択され、その後レスポンスで宣伝された。
### 8.6 Non-printable characters

ログ分析ツールやログ参照中のターミナルに問題を引き起こさないようにするために、非印刷可能文字はログファイルにそのまま送信されず、ASCIIコードの2桁の16進表現に変換され、「#」文字が前に付く。エスケープされずにログに記録できる唯一の文字は、32から126（含む）の間にある。明らかに、エスケープ文字「#」自体も曖昧さを避けるためにエンコードされる（「#23」）。「"」文字も「#22」になり、ヘッダーのログ記録時には「{」、「|」、「}」も同様である。

スペース文字（' '）はヘッダーでエンコードされないことに注意する。これは、フィールドを配置するためにスペースカウントに依存するツールに問題を引き起こす可能性がある。スペースを含む典型的なヘッダーは「User-Agent」である。

最後に、syslog-ngなどの一部のsyslogデーモンが引用符（'"'）をバックスラッシュ（'\'）でエスケープすることが観察されている。逆操作は安全に実行できる。なぜなら、ログの他の場所に引用符が表示されることはないからである。
### 8.7 Capturing HTTP cookies

クッキーキャプチャは、完全なユーザーセッションの追跡を簡素化する。これは、フロントエンドで「capture cookie」文を使用することによって達成できる。詳細については
### 8.8 Capturing HTTP headers (legacy)

ヘッダーキャプチャは、上位プロキシによって設定された一意のリクエスト識別子、仮想ホスト名、ユーザーエージェント、POST content-length、リファラーなどを追跡するのに有用である。レスポンスでは、レスポンスの長さ、サーバーがキャッシュにどのように動作するように要求したか、またはリダイレクション中のオブジェクトの場所に関する情報を検索できる。

ヘッダーキャプチャを実行する方法は2つある。現代的な方法は、キャプチャされるヘッダーから変数を設定すること、または「req.hdr_names」、「req.hdrs」、「res.hdr_names」、「res.hdrs」（すべての可能性についてはセクション7.3.6を参照）によって返される複合サンプルから変数を設定することである。これらは「set-var」と「set-var-fmt」アクションを使用して「txn」スコープの変数に割り当てることができる。「http-request」と
### 8.9 Examples of logs

これらは説明を伴うログの実際の例である。一部は手動で作成されている。読みやすくするためにsyslog部分は削除されている。それらの唯一の目的は、それらを解読する方法を説明することである。

    &gt;&gt;&gt; haproxy[674]: 127.0.0.1:33318 [15/Oct/2003:08:31:57.130] px-http \
          px-http/srv1 6559/0/7/147/6723 200 243 - - ---- 5/3/3/1/0 0/0 \
          "HEAD / HTTP/1.0"

    =&gt; 長いリクエスト（6.5秒）が'telnet'を通じて手動で入力された。サーバーは147msで応答し、セッションは正常に終了した（'----'）

    &gt;&gt;&gt; haproxy[674]: 127.0.0.1:33319 [15/Oct/2003:08:31:57.149] px-http \
          px-http/srv1 6559/1230/7/147/6870 200 243 - - ---- 324/239/239/99/0 \
          0/9 "HEAD / HTTP/1.0"

    =&gt; 同様であるが、リクエストはグローバルキューで9つの他のリクエストの後ろにキューに入れられ、そこで1230ms待機した。

    &gt;&gt;&gt; haproxy[674]: 127.0.0.1:33320 [15/Oct/2003:08:32:17.654] px-http \
          px-http/srv1 9/0/7/14/+30 200 +243 - - ---- 3/3/3/1/0 0/0 \
          "GET /image.iso HTTP/1.0"

    =&gt; 長いデータ転送のリクエスト。「logasap」オプションが指定されていたため、ログはデータ転送の直前に生成された。サーバーは14msで応答し、243バイトのヘッダーがクライアントに送信され、受け入れから最初のデータバイトまでの合計時間は30msである。

    &gt;&gt;&gt; haproxy[674]: 127.0.0.1:33320 [15/Oct/2003:08:32:17.925] px-http \
          px-http/srv1 9/0/7/14/30 502 243 - - PH-- 3/2/2/0/0 0/0 \
          "GET /cgi-bin/bug.cgi? HTTP/1.0"

    =&gt; プロキシが「http-response deny」ルールのため、またはレスポンスが不適切にフォーマットされHTTP準拠でないため、またはキャッシュされるリスクのある機密情報をブロックしたため、サーバーレスポンスをブロックした。この場合、レスポンスは「502 bad gateway」に置き換えられる。フラグ（「PH--」）は、502を返すことを決定したのはHAProxyであり、サーバーではないことを示している。

    &gt;&gt;&gt; haproxy[18113]: 127.0.0.1:34548 [15/Oct/2003:15:18:55.798] px-http \
          px-http/&lt;NOSRV&gt; -1/-1/-1/-1/8490 -1 0 - - CR-- 2/2/2/0/0 0/0 ""

    =&gt; クライアントがリクエストを完了せず、8.5秒後に自分で中止した（「C---」）。プロキシがリクエストヘッダーを待っている間（「-R--」）。何もサーバーに送信されなかった。

    &gt;&gt;&gt; haproxy[18113]: 127.0.0.1:34549 [15/Oct/2003:15:19:06.103] px-http \
         px-http/&lt;NOSRV&gt; -1/-1/-1/-1/50001 408 0 - - cR-- 2/2/2/0/0 0/0 ""

    =&gt; クライアントがリクエストを完了せず、タイムアウト（「c---」）によって50秒後に中止された。プロキシがリクエストヘッダーを待っている間（「-R--」）。何もサーバーに送信されなかったが、プロキシはクライアントに408リターンコードを送信できた。

    &gt;&gt;&gt; haproxy[18989]: 127.0.0.1:34550 [15/Oct/2003:15:24:28.312] px-tcp \
          px-tcp/srv1 0/0/5007 0 cD 0/0/0/0/0 0/0

    =&gt; このログは「option tcplog」で生成された。クライアントは5秒後にタイムアウトした（「c----」）。

    &gt;&gt;&gt; haproxy[18989]: 10.0.0.1:34552 [15/Oct/2003:15:26:31.462] px-http \
          px-http/srv1 3183/-1/-1/-1/11215 503 0 - - SC-- 205/202/202/115/3 \
          0/0 "HEAD / HTTP/1.0"

    =&gt; リクエストは完了するのに3秒かかった（おそらくネットワーク問題）。サーバーへの接続は4回の2秒試行（設定は「retries 3」と言う）の後に失敗した（'SC--'）。リディスパッチはなかった（そうでなければ「/+3」を見たであろう）。ステータスコード503がクライアントに返された。このサーバーには115の接続、このプロキシには202の接続、グローバルプロセスには205の接続があった。サーバーが既に確立された接続が多すぎるために接続を拒否した可能性がある。
## 9. サポートされているフィルター

ここでは、公式にサポートされているフィルターと、それらが受け入れるパラメータのリストが記載されている。コンパイルオプションによっては、これらのフィルターの一部が利用できない場合がある。利用可能なフィルターのリストは `haproxy -vv` で報告される。

**参照項目：** "filter" このキーワードは以下のセクションで利用可能である：
- Alphabetically sorted keywords reference
- Trace
- HTTP compression
- Stream Processing Offload Engine (SPOE)
- Cache
- fcgi-app
- OpenTracing
- Bandwidth limitation
### 9.1. Trace

**filter trace** [name &lt;name&gt;] [random-forwarding] [hexdump]

**引数：**
&lt;name&gt;               メッセージで報告される任意の名前である。名前が提供されない場合、"TRACE"が使用される。

&lt;quiet&gt;              トレースメッセージを抑制する。

&lt;random-forwarding&gt;  解析されたデータのランダム転送を有効にする。デフォルトでは、このフィルターは以前に解析されたすべてのデータを転送する。このパラメータを使用すると、解析されたデータのランダムな量のみを転送する。

&lt;hexdump&gt;            サーバーとクライアントに転送されるすべてのデータをダンプする。

このフィルターは、新しいフィルターを開発するためのベースとして使用できる。すべてのコールバックを定義し、それらのすべてについて有用な情報を含むメッセージを標準エラーストリーム（stderr）に出力する。他のフィルターの動作や、単純にHAProxyの動作をデバッグするのに役立つ場合がある。

&lt;random-parsing&gt;や&lt;random-forwarding&gt;パラメータを使用することは、処理にいくつかの遅延を追加することにより、クライアントとサーバー間で交換されるデータを解析するフィルターの動作をテストする良い方法である。
**参照項目：** "use-fcgi-app" このキーワードは以下のセクションで利用可能である：
- Proxy section
- Alphabetically sorted keywords reference

圧縮フィルターについては9.2節、キャッシュフィルターについては9.4節、FastCGIアプリケーションについては10節を参照のこと。
管理ガイドの9.3節の「set ssl cert」を参照のこと。

「crt-store」セクションでは以下のキーワードがサポートされている：
  - crt-base
  - key-base
  - load

**crt-base** &lt;dir&gt;

相対パスが「crt」ディレクティブで使用される場合にSSL証明書を取得するためのデフォルトディレクトリを割り当てる。指定された絶対位置が優先され、「crt-base」を無視する。crt-storeで使用される場合、グローバルセクションのcrt-baseは無視される。

**key-base** &lt;dir&gt;

相対パスが「key」ディレクティブで使用される場合にSSL秘密鍵を取得するためのデフォルトディレクトリを割り当てる。指定された絶対位置が優先され、「key-base」を無視する。crt-storeで使用される場合、グローバルセクションのkey-baseは無視される。

**load** [crt &lt;filename&gt;] [param*]

証明書ストレージにSSLファイルを読み込む。パラメータリストについては「12.7.1. Load options」節を参照のこと。

**例：**
```
crt-store
    load crt "site1.crt" key "site1.key" ocsp "site1.ocsp" alias "site1"
    load crt "site2.crt" key "site2.key"

frontend in2
    bind *:443 ssl crt "@/site1" crt "site2.crt"

crt-store web
    crt-base /etc/ssl/certs/
    key-base /etc/ssl/private/
    load crt "site3.crt" alias "site3"
    load crt "site4.crt" key "site4.key"

frontend in2
    bind *:443 ssl crt "@/site1" crt "site2.crt"  crt "@/web/site3" crt "@/web/site4.crt"
```

### 12.7.1. Load options

証明書ストレージにSSLファイルを読み込む。loadキーワードは複数のパラメータを取ることができ、以下にリストされている。これらのキーワードはcrt-listでも使用できる。

**crt** &lt;filename&gt;

この引数は必須である。公開証明書を含む必要があるが、中間証明書と秘密鍵も含むことができるPEMを読み込む。このファイルに秘密鍵が提供されない場合、鍵は「key」キーワードで提供できる。

**acme** &lt;string&gt;

このオプションにより、特定の証明書のACMEプロトコルを設定できる。これは実験的機能であり、グローバルセクションに「expose-experimental-directives」キーワードが必要である。

12.8節（「ACME」）とこの節の「domains」も参照のこと。

**alias** &lt;string&gt;

オプションの引数である。証明書にエイリアスで名前を付けることを許可し、設定でそれによって参照できる。エイリアスは設定の他の場所で呼び出される場合、'@/'で始まる必要がある。

**domains** &lt;string&gt;

ACME証明書に使用されるドメインのリストを設定する。リストの最初のドメインがCNとして使用される。ドメインはリスト内でカンマで区切られる。

12.8節（「ACME」）とこの節の「acme」も参照のこと。

**例：**
```
load crt "example.com.pem" acme LE domains "bar.example.com,foo.example.com"
```

**key** &lt;filename&gt;

この引数はオプションである。PEM形式の秘密鍵を読み込む。「crt」で既に秘密鍵が定義されている場合、それを上書きする。

**ocsp** &lt;filename&gt;

この引数はオプションである。DER形式のOCSPレスポンスを読み込む。CLIで更新できる。

**issuer** &lt;filename&gt;

この引数はオプションである。PEM形式でOCSP発行者を読み込む。OCSPレスポンスがどの証明書に適用されるかを識別するために、発行者の証明書が必要である。「crt」ファイルに発行者の証明書が見つからない場合、この引数でファイルから読み込むことができる。

**sctl** &lt;filename&gt;

この引数はオプションである。Certificate Transparency（RFC6962）TLS拡張のサポートが有効になる。ファイルには、RFCで説明されている有効なSigned Certificate Timestamp Listが含まれている必要がある。ファイルは基本的な構文をチェックするために解析されるが、署名は検証されない。

**ocsp-update** [ off | on ]

'on'に設定すると自動OCSPレスポンス更新を有効にし、そうでなければ無効にする。その値はデフォルトで'off'である。

bind行でOCSP自動更新を有効にするには、crt-storeでこのオプションを使用するか、グローバルオプション「tune.ocsp-update.mode」を使用できる。特定の証明書が異なる値の'ocsp-update'設定で複数のcrt-listで使用される場合、エラーが発生する。同様に、証明書がbind行のグローバルオプションから継承され、crt-listで互換性のない明示的な'ocsp-update'オプションが設定されている場合、同じエラーが発生する。

**例：**

crt-listで有効にする設定例：

haproxy.cfg:
```
frontend fe
    bind :443 ssl crt-list haproxy.list
```

haproxy.list:
```
server_cert.pem [ocsp-update on] foo.bar
```

crt-storeで有効にする設定例：

haproxy.cfg:
```
crt-store
  load crt foobar.pem ocsp-update on

frontend fe
    bind :443 ssl crt foobar.pem
```

オプションが'on'に設定されている場合、フロントエンドの証明書でOCSP URIが見つかるたびにOCSPレスポンスを取得しようとする。このモードの唯一の制限は、OCSP certidを構築するために証明書の発行者が知られている必要があることである。

各OCSPレスポンスは少なくとも1時間に1回更新され、特定のOCSPレスポンスの有効期限がこの1時間制限より早い場合は、さらに頻繁に更新される。5分間の最小更新間隔は、非常に短い有効期限を持つレスポンスや「Next Update」が全くないレスポンスを頻繁に更新しすぎることを避けるために存在する。このハード制限により、自動更新が'on'に設定されている場合、初期化中に読み込まれたOCSPレスポンスは、有効期限がnow+5mより前に終了した場合でも、少なくとも5分間は更新されないことに注意してください。これは、OCSPレスポンスが初期化中に読み込まれる際に有効でなければならない（その有効期限は将来でなければならない）ため、このレスポンスが初期化後すぐに有効期限が切れることはありそうにないため、それほど問題にならないはずである。

一方、証明書にOCSP URIが指定されており、OCSPレスポンスがない場合、特定の証明書のこのオプションを'on'に設定すると、初期化直後にOCSPレスポンスが自動的に取得されることが保証される。

デフォルトの最小および最大遅延（それぞれ5分と1時間）は、「ocsp-update.maxdelay」と「ocsp-update.mindelay」グローバルオプションで設定できる。

自動更新タスクまたは「update ssl ocsp-response」CLIコマンドの呼び出しによってOCSPレスポンスが更新されるたびに、専用のログ行が出力される。これは専用の形式に従い、以下のヘッダー「&lt;OCSP-UPDATE&gt;」を含み、その後に特定のOCSP関連情報が続く：
  - 対応するフロントエンド証明書のパス
  - 数値更新ステータス
  - テキスト更新ステータス
  - 特定のレスポンスの更新失敗回数
  - 特定のレスポンスの更新成功回数

エラーコードとエラーメッセージの完全なリストについては「show ssl ocsp-updates」CLIコマンドを参照のこと。この行は、関連するOCSPレスポンス更新の成功または失敗に関係なく出力される。

OCSPリクエスト/レスポンスは、dontlog-normalオプションが設定され、エラーの場合に通常のHTTPログ形式を使用するhttp_clientインスタンスを通じて送受信される。このようなエラーが発生した場合、HTTP関連の情報を含む別のログ行が「通常の」OCSP行と一緒に出力される（おそらくテキストステータスとして「HTTP error」を持つ）。しかし、純粋なHTTPエラーが発生した場合（たとえば到達不可能なOCSPレスポンダー）、通常のHTTPログ形式に従う追加のログ行が出力される。

以下は、そのようなログ行の2つの例で、最初に成功したOCSP更新ログ行、次にHTTPエラーの例で2つの異なる行（行は分割され、URLは読みやすさのために短縮されている）：

```
&lt;133&gt;Mar  6 11:16:53 haproxy[14872]: &lt;OCSP-UPDATE&gt; /path_to_cert/foo.pem 1 \
        "Update successful" 0 1

&lt;133&gt;Mar  6 11:18:55 haproxy[14872]: &lt;OCSP-UPDATE&gt; /path_to_cert/bar.pem 2 \
        "HTTP error" 1 0
&lt;133&gt;Mar  6 11:18:55 haproxy[14872]: -:- [06/Mar/2023:11:18:52.200] \
        &lt;OCSP-UPDATE&gt; -/- 2/0/-1/-1/3009 503 217 - - SC-- 0/0/0/0/3 0/0 {} \
        "GET http://127.0.0.1:12345/MEMwQT HTTP/1.1"
```

**トラブルシューティング：**

Let's Encrypt証明書で発生する可能性のある一般的なエラーは、DNS解決がIPv6アドレスを提供し、システムに有効な発信IPv6ルートがない場合である。このような場合、適切なルートを作成するか、グローバルセクションで「httpclient.resolvers.prefer ipv4」オプションを設定できる。

「OCSP response check failure」エラーの場合、提供した発行者証明書が有効であることを確認したい場合がある。「OCSP response check failure」または「Error during insertion」エラーの場合、より正確なエラーメッセージが「一般的な」エラーメッセージの後の括弧内に表示される場合もある。
### 9.4. Cache

**filter cache** &lt;name&gt;

**引数：**
&lt;name&gt;      このフィルターが使用するキャッシュセクションの名前である。

キャッシュは、キャッシュ可能なレスポンスを保存するためにフィルターを使用する。「cache-store」と「cache-use」のHTTPルールを使用して、キャッシュをどのように、いつ使用するかを定義する必要がある。デフォルトでは、対応するフィルターが暗黙的に定義される。fcgi-appや圧縮以外の他のフィルターが使用されない場合、それで十分である。このような場合、圧縮フィルターは常にキャッシュフィルターの後に評価される。しかし、同じリスナー/フロントエンド/バックエンドで圧縮やfcgi-app以外の少なくとも1つのフィルターが使用される場合、キャッシュを使用するには明示的にフィルター行を使用することが必須である。これはフィルターの評価順序を知るために重要である。
### 9.5. Fcgi-app

**filter fcgi-app** &lt;name&gt;

**引数：**
&lt;name&gt;      このフィルターが使用するfcgi-appセクションの名前である。

FastCGIアプリケーションは、リクエストパス上のすべてのカスタムパラメータを評価し、レスポンスパス上のヘッダーを処理するためにフィルターを使用する。&lt;name&gt;は既存のfcgi-appセクションを参照する必要がある。「use-fcgi-app」ディレクティブを使用して、使用するアプリケーションを定義する必要がある。デフォルトでは、対応するフィルターが暗黙的に定義される。キャッシュや圧縮以外の他のフィルターが使用されない場合、それで十分である。しかし、同じバックエンドで圧縮やキャッシュ以外の少なくとも1つのフィルターが使用される場合、fcgi-appに明示的にフィルター行を使用することが必須である。これはフィルターの評価順序を知るために重要である。
### 9.6. OpenTracing

OpenTracingフィルターは、HAProxyで分散トレーシングを使用するためのネイティブサポートを追加する。これは、Datadog、Jaeger、Lightstep、Zipkinトレーサーなどのサポートされているトレーサーの1つにOpenTracing準拠のリクエストを送信することによって有効になる。注意：トレーサーは優先順位ではなく、アルファベット順にリストされている。

この機能は、HAProxyがUSE_OT=1でビルドされた場合にのみ有効になる。

OpenTracingフィルターのアクティベーションは、HAProxy設定で明示的に指定することによって行われる。これが行われない場合、OpenTracingフィルターはHAProxyの作業に一切参加しない。

**filter opentracing** [id &lt;id&gt;] config &lt;file&gt;

**引数：**
&lt;id&gt;        設定ファイルで正しいスコープを見つけるために使用されるOpenTracingフィルターIDである。フィルターIDが指定されない場合、デフォルトとして'ot-filter'が使用される。設定ファイルでスコープが指定されない場合、定義されたすべてのOpenTracingフィルターに適用される。

&lt;file&gt;       OpenTracing設定ファイルのパスである。同じファイルに複数のOpenTracingフィルターの設定を同時に含めることができる。その場合、スコープを定義する必要がないため、同じ設定がすべてのフィルターに適用されるか、各フィルターが独自のスコープを定義する必要がある。

フィルターの動作、設定、使用に関するより詳細なドキュメントは、addons/otディレクトリで見つけることができる。

注意：OpenTracingフィルターは新しい設計には使用すべきではない。OpenTracing自体はもはやメンテナンスされておらず、その作者によってサポートされていない。OpenTelemetryベースの代替フィルターが現在開発中であり、HAProxy 3.2頃に準備完了予定である。そのため、OpenTracingは3.3で非推奨となり、3.5で削除される。
### 9.7. Bandwidth limitation

**filter bwlim-in** &lt;name&gt; default-limit &lt;size&gt; default-period &lt;time&gt; [min-size &lt;sz&gt;]

**filter bwlim-out** &lt;name&gt; default-limit &lt;size&gt; default-period &lt;time&gt; [min-size &lt;sz&gt;]

**filter bwlim-in** &lt;name&gt; limit &lt;size&gt; key &lt;pattern&gt; [table &lt;table&gt;] [min-size &lt;sz&gt;]

**filter bwlim-out** &lt;name&gt; limit &lt;size&gt; key &lt;pattern&gt; [table &lt;table&gt;] [min-size &lt;sz&gt;]

**引数：**
&lt;name&gt;      'set-bandwidth-limit'アクションが特定の帯域幅制限フィルターを参照するために使用するフィルター名である。

&lt;size&gt;      期間中に転送できる最大バイト数である。この値は、ストリーム単位および共有帯域幅制限フィルターに指定する必要がある。HAProxyサイズ形式に従い、バイト単位で表現される。
## 10. FastCGIアプリケーション

HAProxyは、Responder FastCGIアプリケーションにHTTPリクエストを送信できる。この機能はHAProxy 2.1で追加された。これを行うには、サーバーがFastCGIプロトコルを使用するように設定する必要がある（サーバー行で「proto fcgi」キーワードを使用）そして、これらのサーバーを管理するバックエンドでFastCGIアプリケーションが設定され、使用される必要がある（プロキシセクションで「use-fcgi-app」キーワードを使用）。複数のFastCGIアプリケーションが定義される場合があるが、バックエンドで一度に1つしか使用できない。

HAProxyは、ResponderアプリケーションのFastCGI仕様のすべての機能を実装している。特に、単純な接続で複数のリクエストを多重化できる。
### 10.1. Setup

#### 10.1.1. Fcgi-app section

**fcgi-app** &lt;name&gt;

&lt;name&gt;という名前のFastCGIアプリケーションを宣言する。有効であるためには、少なくともドキュメントルートが定義される必要がある。

**acl** &lt;aclname&gt; &lt;criterion&gt; [flags] [operator] &lt;value&gt; ...

アクセスリストを宣言または完成させる。
### 10.2. Default parameters

Responder FastCGIアプリケーションは、CGI/1.1プログラムと同じ目的を持つ。CGI/1.1仕様（RFC3875）では、スクリプトに渡される必要があるいくつかの変数がある。そのため、HAProxyはそれらとFastCGIアプリケーションで一般的に使用される他のいくつかを設定する。これらすべての変数は上書きできるが、注意が必要である。
```txt
  +-------------------+-----------------------------------------------------+
  | AUTH_TYPE         | HAProxyがユーザーを認証するために使用するメカニズム（もしあれば）を識別する。具体的には、BASIC認証メカニズムのみがサポートされている。 |
  |                   |                                                     |
  +-------------------+-----------------------------------------------------+
  | CONTENT_LENGTH    | リクエストに添付されたメッセージボディのサイズを含む。既知のサイズを持つリクエストのみが有効とみなされ、アプリケーションに送信されることを意味する。 |
  |                   |                                                     |
  +-------------------+-----------------------------------------------------+
  | CONTENT_TYPE      | リクエストに添付されたメッセージボディのタイプを含む。設定されない場合がある。 |
  |                   |                                                     |
  +-------------------+-----------------------------------------------------+
  | DOCUMENT_ROOT     | アプリケーションの設定で定義されているように、スクリプトが実行される必要があるリモートホスト上のドキュメントルートを含む。 |
  |                   |                                                     |
  +-------------------+-----------------------------------------------------+
  | GATEWAY_INTERFACE | HAProxyがFastCGIアプリケーションと通信するために使用するCGIの方言を含む。具体的には、「CGI/1.1」に設定される。 |
  |                   |                                                     |
  +-------------------+-----------------------------------------------------+
  | PATH_INFO         | スクリプト自体を識別する部分に続くURIパス階層の部分を含む。設定するには、「path-info」ディレクティブが定義される必要がある。 |
  |                   |                                                     |
  +-------------------+-----------------------------------------------------+
  | PATH_TRANSLATED   | PATH_INFOが設定されている場合、その翻訳されたバージョンである。DOCUMENT_ROOTとPATH_INFOの連結である。PATH_INFOが設定されていない場合、このパラメータも設定されない。 |
  |                   |                                                     |
  +-------------------+-----------------------------------------------------+
  | QUERY_STRING      | リクエストのクエリ文字列を含む。設定されない場合がある。 |
  |                   |                                                     |
  +-------------------+-----------------------------------------------------+
  | REMOTE_ADDR       | リクエストを送信しているクライアントのネットワークアドレスを含む。 |
  |                   |                                                     |
  +-------------------+-----------------------------------------------------+
  | REMOTE_USER       | クライアントがユーザー認証の一部として提供するユーザー識別文字列を含む。 |
  |                   |                                                     |
  +-------------------+-----------------------------------------------------+
  | REQUEST_METHOD    | スクリプトがリクエストを処理するために使用すべきメソッドを含む。 |
  |                   |                                                     |
  +-------------------+-----------------------------------------------------+
  | REQUEST_URI       | リクエストのURIを含む。 |
  |                   |                                                     |
  +-------------------+-----------------------------------------------------+
  | SCRIPT_FILENAME   | スクリプトの絶対パス名を含む。DOCUMENT_ROOTとSCRIPT_NAMEの連結である。 |
  |                   |                                                     |
  +-------------------+-----------------------------------------------------+
  | SCRIPT_NAME       | スクリプトの名前を含む。「path-info」ディレクティブが定義されている場合、スクリプト名で終わるURIパス階層の最初の部分である。そうでなければ、URIパス全体である。 |
  |                   |                                                     |
  +-------------------+-----------------------------------------------------+
  | SERVER_NAME       | クライアントリクエストが向けられるサーバーホストの名前を含む。「Host」ヘッダーの値である（定義されている場合）。そうでなければ、クライアント側の接続の宛先アドレスである。 |
  |                   |                                                     |
  +-------------------+-----------------------------------------------------+
  | SERVER_PORT       | クライアント側の接続の宛先TCPポートを含む。これはクライアントが接続したポートである。 |
  |                   |                                                     |
  +-------------------+-----------------------------------------------------+
  | SERVER_PROTOCOL   | リクエストのプロトコルを含む。 |
  |                   |                                                     |
  +-------------------+-----------------------------------------------------+
  | SERVER_SOFTWARE   | 現在のHAProxyバージョンが続く「HAProxy」文字列を含む。 |
  |                   |                                                     |
  +-------------------+-----------------------------------------------------+
  | HTTPS             | スクリプトがHTTPSプロトコルを通じてクエリされた場合、空でない値（「on」）に設定される。 |
  |                   |                                                     |
  +-------------------+-----------------------------------------------------+
```

### 10.3. Limitations

現在の実装にはいくつかの制限がある。最初の制限は、一部のリクエストヘッダーがFastCGIアプリケーションに隠される方法に関する。これは、接続確立前のバックエンド側でのヘッダー解析中に発生する。この段階で、HAProxyはバックエンドがFastCGIアプリケーションを使用していることを知っているが、リクエストがFastCGIサーバーにルーティングされるかどうかは知らない。しかし、リクエストヘッダーを隠すために、HTXメッセージからそれらを単純に削除する。そのため、リクエストが最終的にHTTPサーバーにルーティングされる場合、これらのヘッダーを見ることはない。この理由により、同じバックエンドの下でFastCGIサーバーとHTTPサーバーを混在させることは推奨されない。

同様に、「set-param」と「pass-header」のルールは、リクエストヘッダー解析中に評価される。そのため、リクエストが最終的にHTTPサーバーに転送される場合でも、評価は常に実行される。

「set-param」ルールについて、ルールが適用されると、疑似ヘッダーがHTXメッセージに追加される。そのため、HTTPヘッダー書き換えと同様に、バッファが一杯の場合に失敗する可能性がある。「set-param」ルールは「http-request」ルールと競合する。

最後に、すべてのFastCGIパラメータとHTTPヘッダーは、単一のレコードFCGI_PARAMに送信される。このレコードのエンコーディングは1回のパスで行われる必要があり、そうでなければ処理エラーが返される。これは、レコードFCGI_PARAMが一度エンコードされると、バッファのサイズを超えてはならないことを意味する。しかし、ここで尊重すべき予備はない。
## 11. Stick-tables and Peers

HAProxyにおけるStick-tablesは、特定のタイプのキーと一定数の情報およびメトリクスを関連付けることを可能にするメカニズムであり、これは最後の更新後の一定期間にわたって有効である。これは、テーブル内の複数列の行として見ることができ、行番号はキー値によって定義され、列はすべて異なる基準を表している。

Stick-tablesは元々、これらのエンティティ間の永続的なセッションを維持するために、クライアント-サーバーのスティッキネス情報を格納するように設計されていた。クライアントが接続またはリクエストを送信すると、このクライアントは識別子（送信元アドレス、Cookie、URLパラメータ）によって識別され、選択されたサーバーは設定可能な期間にわたってこの識別子と関連付けてStick tableに格納される。これにより、同じクライアントからの後続のアクセスは、クライアントがアプリケーションセッションを作成した同じサーバーに自動的にルーティングされることができる。

現在、Stick-tablesは単なるサーバー番号以上の情報を格納することができ、特定のクライアントに関連するアクティビティメトリクスなどの要素（リクエスト数/レート、接続数/レート、バイト数/レートなど）を格納することができる。また、いくつかの任意のイベントカウンター（「General Purpose Counters」の「gpc」）と、クライアントに特定の特性をラベル付けするためのいくつかのタグ（「General Purpose Tag」の「gpt」）も格納できる。

Stick-tablesは、クライアント-サーバーのスティッキネスに使用される「stick」ディレクティブ、メトリクスを収集するためにどのテーブルのどのキーを追跡するかを記述するために使用される「track-sc」ルール、および特定のメトリクスやデータを取得するために特定のキーの即座のルックアップを実行できるサンプルフェッチ関数やコンバーターの数によって参照されることができる。一般的な原則は、テーブル（gpt/gpc/メトリクス）への更新およびスティッキネス情報のルックアップがアクセスされたエントリを更新し、その有効期限を延期するのに対し、サンプルフェッチ関数やコンバーターからの単なるルックアップは、エントリの有効期限を延期することなくデータのみを抽出することである。

メカニズムがスケールし、HAProxyのリロードやフェイルオーバーに耐えるために、Stick-tablesの更新を他のノードと共有することが可能である。これらのノードは
### 11.1 

（上記のセクション11.1を参照）。

また、「peers」セクションが独自のStick-table名前空間を持っているという事実にも注意する必要がある。これは、異なる「peers」セクションで同一のStick-table名による衝突を避けるためである。これは内部的に、「peers」セクション名をStick-tableの名前に「/」文字を続けて前置することで処理される。設定ファイルの他の場所で「peers」セクションで宣言されたそのようなStick-tableを参照する必要がある場合は、以下のようにStick-table名の前置バージョンを使用する必要がある：

    peers mypeers
        peer A ...
        peer B ...
        table t1 ...

    frontend fe1
        tcp-request content track-sc0 src table mypeers/t1

これは、CLIを通じてStick-tableを参照するために使用する必要があるStick-table名の前置バージョンでもある。

「peers」プロトコルについて、同じセクションに属する「peers」のみが互いに通信できるため、そのような区別を行う必要がない。複数の「peers」セクションが同じ名前のStick-tableを宣言することができる。これは、ネットワーク上で送信されるStick-table名の短縮バージョンである。バックエンドとして宣言されたStick-tableと「peers」セクションで宣言されたStick-table間のStick-table名の衝突を避けるために、以下のような奇妙だがサポートされている設定で「/」文字のみが前置される：

    peers mypeers
        peer A ...
        peer B ...
        table t1 type string size 10m store gpc0

    backend t1
        stick-table type string size 10m store gpc0 peers mypeers

ここで、「mypeers」セクションで宣言された「t1」テーブルは「mypeers/t1」をグローバル名として持つ。「t1」テーブルはバックエンドとして宣言され、「t1」をグローバル名として持つ。しかし、ピアプロトコルレベルでは、前者のテーブルは「/t1」と命名され、後者は再び「t1」と命名される。
### 11.2 Peers宣言

複数のHAProxyインスタンス間でStick-tableの任意のデータ型のエントリを、マルチマスターファッションでTCP接続を介して伝播することが可能である。各インスタンスは、そのローカル更新と挿入をリモートピアにプッシュする。プッシュされた値は、集約なしでリモートの値を上書きする。

一つの例外は、デフォルトではピアから学習されることがない「conn_cur」データ型である。これはローカル値を反映することを想定しているためである。以前のバージョンでは、デフォルトでこれを同期していたが、アクティブ-アクティブ設定で負の値を引き起こすことが知られており、リロードやアクティブ-パッシブ切り替え時に常に増加する値を引き起こすことが知られていた。これは、ローカル値がローカルに存在するよりも多くの接続を反映するためである。しかし、ピアからこの値を学習することが関連する可能性がある設定がいくつか存在する。例えば、テーブルが書き込み指向の操作や更新に依存せず、そこからデータを学習/監視するためにのみ使用される受動的なリモートテーブルである場合である。これを実現するために、「recv-only」キーワードをテーブル宣言に追加することができる。いずれにせよ、「conn_cur」情報は常にプッシュされるため、監視システムがそれを監視することができる。

中断された交換は自動的に検出され、最後に既知のポイントから回復される。さらに、ソフトリスタート中、古いプロセスは新しいプロセスが他のピアに接続を試みる前に、そのすべてのエントリをプッシュするためにそのようなTCP接続を使用して新しいプロセスに接続する。これにより、リロード中の非常に高速なレプリケーションが保証され、大きなテーブルでも通常は1秒の数分の一しかかからない。

サーバーIDはリモートでサーバーを識別するために使用されることに注意する必要がある。したがって、設定が類似しているか、少なくとも同じIDがすべての参加者の各サーバーに強制されることが重要である。

**peers** &lt;peersect&gt;

名前&lt;peersect&gt;で新しいピアリストを作成する。これは独立したセクションであり、1つ以上のStick-tableによって参照される。

**bind** [&lt;address&gt;]:port [param*]

**bind** /&lt;path&gt; [param*]

この「peers」セクションのローカルピアのバインディングパラメータを定義する。そのような行は、同じ「peers」セクションの「peer」行ではサポートされていない。

**disabled**

ピアセクションを無効にする。これにより、このセクションに関連するリスニングと同期の両方が無効になる。これは、すべての「peers」参照をコメントアウトすることなく、Stickテーブルの同期を無効にするために提供される。

**default-bind** [param*]

ローカルピアのバインディングパラメータを定義する（アドレスを除く）。

**default-server** [param*]

「peers」セクション内のサーバーのデフォルトオプションを変更する。

**Arguments:**

&lt;param*&gt; はこのサーバーのパラメータのリストである。「default-server」キーワードは多くのオプションを受け入れ、それに専用の完全なセクションがある。ピアセクションでは、「default-server」行のトランスポートパラメータがサポートされている。参照するには
## 12. Other sections

以下で説明されるセクションは、あまり一般的に使用されず、通常は少数のパラメータのみをサポートする。それらの間に暗黙の関係は存在しない。それらはすべて単一のキーワードを使用して開始される。「global」セクションの前にそれらのいずれも許可されない。それらの一部のサポートは、ビルドオプションによって条件付けられる可能性がある（例：SSL関連のもの）。
### 12.1 Traces

デバッグ目的で、HAProxyのサブシステムでトレースを有効にすることが可能である。これにより、特定のサブシステムに関するデバッグメッセージがダンプされる。これは問題を診断するための非常に強力なツールである。トレースはCLIを介して動的に設定することができる。また、設定ファイルの専用の「traces」セクションで事前にいくつかの設定を定義することも可能である。トレースの詳細については管理ガイドを参照すること。これは複雑なデバッグセッション中に使用される開発者ツールのままである。非常に冗長でコストがかかるため、注意して使用すること。また、これは開発者ツールであるため、このセクションの後方互換性について保証はない。

**traces**

新しいtracesセクションを開始する。1つまたは複数の「traces」セクションを使用することができる。すべてのディレクティブは宣言順に評価され、最後のものが前のものを上書きする。

**trace** &lt;source&gt; &lt;args...&gt;

「trace」サブシステムを設定する。それぞれは管理マニュアルで見つけることができ、正確に同じ構文に従う。「trace」コマンドが生成する出力は、セクションの解析ステップ中に出力される。ほとんどの場合、これらはエラーと警告であるが、特定の不完全なコマンドは許可される選択肢をリストアップする可能性がある。このコマンドは通常の使用を意図したものではなく、一般的に開発者が複雑なデバッグセッション中に提案するのみである。トレースレベルと詳細に応じて、トレースを有効にするとグローバルパフォーマンスが大幅に低下する可能性があることを覚えておくことが重要である。ステートメントの構文については管理マニュアルを参照すること。

**Example:**

```
ring buf1
  size 10485760 # 10MB
  format timed
  backing-file /tmp/h1.traces

ring buf2
  size 10485760 # 10MB
  format timed
  backing-file /tmp/h2.traces

traces
  trace h1 sink buf1 level developer verbosity complete start now
  trace h2 sink buf1 level developer verbosity complete start now
```
### 12.2 Userlists

フロントエンド/バックエンド/リスンセクションまたはHTTP統計へのアクセスを、認証済みで認可されたユーザーのみに許可することで制御することが可能である。これを行うには、少なくとも1つのuserlistを作成し、ユーザーを定義する必要がある。

**userlist** &lt;listname&gt;

名前&lt;listname&gt;で新しいuserlistを作成する。多くの独立したuserlistを使用して、独立した顧客の認証・認可データを格納することができる。

**group** &lt;groupname&gt; [users &lt;user&gt;,&lt;user&gt;,(...)]

現在のuserlistにグループ&lt;groupname&gt;を追加する。「users」キーワードに続くカンマ区切りの名前リストを使用して、このグループにユーザーを添付することも可能である。

**user** &lt;username&gt; [password|insecure-password &lt;password&gt;]
                [groups &lt;group&gt;,&lt;group&gt;,(...)]

現在のuserlistにユーザー&lt;username&gt;を追加する。安全（暗号化）と安全でない（暗号化されていない）パスワードの両方を使用することができる。暗号化されたパスワードはcrypt(3)関数を使用して評価されるため、システムの機能に応じて、異なるアルゴリズムがサポートされる。例えば、現代のGlibcベースのLinuxシステムはMD5、SHA-256、SHA-512、そしてもちろん、パスワードを暗号化するための古典的なDESベースのメソッドをサポートする。

注意：暗号化されたパスワードを使用すると、リクエスト数と使用されるアルゴリズムに応じて、CPU使用量が大幅に増加する可能性があることに注意すること。ハッシュ化されたバリアントのいずれについても、設定ファイルで指定された値と比較できるようになる前に、各リクエストのパスワードを選択されたアルゴリズムで処理する必要がある。現在のアルゴリズムのほとんどは、ブルートフォース攻撃に対する耐性を実現するために、計算が高価になるように意図的に設計されている。これらは単純に平文パスワードを一度ソルト/ハッシュ化するのではなく、何千回も行う。これはHAProxyの全体的なCPU消費の主要な要因となり、アプリケーションのクラッシュにつながる可能性さえある！

ハッシュ関数の高いCPU使用量に対処するために、一つのアプローチは、ハッシュ関数（SHAファミリーアルゴリズム）のラウンド数を減らすか、アルゴリズムがサポートしている場合に関数の「コスト」を下げることである。

余談として、musl（例：Alpine Linux）の実装は、ハッシュを計算する際にglibcの対応するものよりも遅いことが知られているため、この側面も考慮したい場合がある。

すべてのパスワードは通常の引数と見なされ、したがって
### 12.3 Mailers

サーバーの状態が変更されたときにメールアラートを送信することが可能である。設定されている場合、メールアラートはmailersセクションで設定されている各メーラーに送信される。メールはLuaを介してメーラーに送信される（examples/lua/mailers.luaを参照）。

**mailers** &lt;mailersect&gt;

名前&lt;mailersect&gt;で新しいメーラーリストを作成する。これは独立したセクションであり、1つまたは複数のプロキシによって参照される。

**mailer** &lt;mailername&gt; &lt;ip&gt;:&lt;port&gt;

mailersセクション内のメーラーを定義する。

**Example:**

```
global
    # gitリポジトリで提供されるmailers.luaファイル
    # 必要に応じてパスを調整
    lua-load examples/lua/mailers.lua

mailers mymailers
    mailer smtp1 192.168.0.1:587
    mailer smtp2 192.168.0.2:587

backend mybackend
    mode tcp
    balance roundrobin

    email-alert mailers mymailers
    email-alert from test1@horms.org
    email-alert to test2@horms.org

    server srv1 192.168.0.30:80
    server srv2 192.168.0.31:80
```

**timeout mail** &lt;time&gt;

メール/接続が作成され、メールサーバーに送信されるために利用可能な時間を定義する。定義されていない場合、デフォルト値は10秒である。初期TCPハンドシェイク中に少なくとも2つのSYN-ACKパケットが送信されることを許可するために、この値を4秒以上に保つことが推奨される。

**Example:**

```
mailers mymailers
    timeout mail 20s
    mailer smtp1 192.168.0.1:587
```
### 12.4 HTTP-errors

設定で使用されるHTTPエラーのいくつかのグループをグローバルに宣言し、その後任意のプロキシセクションでインポートすることが可能である。同じグループは複数の場所で参照され、完全または部分的にインポートすることができる。

**http-errors** &lt;name&gt;

名前&lt;name&gt;で新しいhttp-errorsグループを作成する。これは独立したセクションであり、その名前を使用して1つまたは複数のプロキシによって参照される可能性がある。

**errorfile** &lt;code&gt; &lt;file&gt;

HTTPエラーコードにファイルの内容を関連付ける

**Arguments :**

&lt;code&gt;    はHTTPステータスコードである。現在、HAProxyはコード200、400、401、403、404、405、407、408、410、425、429、500、501、502、503、および504を生成することができる。

&lt;file&gt;    完全なHTTPレスポンスを含むファイルを指定する。人々がレスポンスをHTMLエラーページと混同しないように、ファイル名に「.http」を追加するという一般的な慣行に従うことが推奨され、ファイルはchrootが実行される前に読み取られるため、絶対パスを使用することが推奨される。
### 12.5 Rings

ログサーバーやトレースのターゲットとして使用されるリングバッファをグローバルに宣言することが可能である。

**ring** &lt;ringname&gt;

名前&lt;ringname&gt;で新しいリングバッファを作成する。

**backing-file** &lt;path&gt;

これにより、リングを格納するための通常のメモリ割り当てがRAMマップファイルに置き換えられる。これは、CLIに低速クライアントを接続することなく、事後分析のためにトレースやログを収集するのに役立つ。新しいコンテンツは古いものを自動的に置き換えるため、最新のコンテンツが常に利用可能である。リングに書き込まれたコンテンツは、プロセスが停止した後（多くの場合、すぐ後に見えるが、書き込みが非同期であるためそのような保証はない）、そのファイルで見えるようになる。

このオプションが使用される場合、総ストレージ領域は領域の先頭から始まる「struct ring」のサイズだけ減少し、これは領域のコンテンツを回復するために必要である。ファイルは開始ユーザーの所有権で作成され、モード0600で、「size」ディレクティブで設定されたサイズになる。ディレクティブが解析されるとき（したがって設定チェック中でも）、既存の空でないファイルは最初に「.bak」という追加のサフィックスで名前が変更され、以前に存在していた「.bak」サフィックスを持つファイルは削除される。これにより、プロセスの即座のリロードまたは再起動が貴重なデバッグ情報を消去することがなく、管理者がこの新しい「.bak」ファイルを見つけて必要に応じてアーカイブする時間が残される。このように、クラッシュ後、&lt;path&gt;で指定されたファイルには最新の情報が含まれ、サービスが再起動された場合、「&lt;path&gt;.bak」ファイルにそれが含まれる。これは、必要な総ストレージ容量がリングサイズの2倍になることを意味する。ファイルのローテーションの失敗は静かに無視されるため、バックアップファイルが望ましくない場合、書き込み権限のないディレクトリにファイルを配置するだけで十分である。

警告：この機能を使用することには安定性とセキュリティの影響がある。第一に、リングを低速デバイス（例：物理ハードドライブ）にバックアップすると、アクセス中に知覚可能な減速が発生し、過度に多くのスレッドがアクセスを競合する場合、パニックが発生する可能性さえある。第二に、領域を変更する外部プロセスがhaproxyプロセスをクラッシュさせたり、トレースで自身のメモリの一部を上書きさせたりする可能性がある。第三に、ファイルシステムがリングの前に満杯になった場合、リングへの書き込みがプロセスをクラッシュさせる可能性がある。

このリングに存在する情報は構造化されており、テキストエディタで直接読み取ることはできない（そのほとんどがかろうじて読み取り可能に見えるにもかかわらず）。このファイルの出力は開発者のみを対象としている。

**description** &lt;text&gt;

説明はリングのオプションの説明文字列である。CLIに表示される。デフォルトでは、&lt;name&gt;がこのフィールドを埋めるために再利用される。

**format** &lt;format&gt;

リングバッファにイベントを格納するために使用されるフォーマット。

**Arguments:**

&lt;format&gt; はsyslogメッセージを生成する際に使用されるログフォーマットである。以下のいずれかである可能性がある：

  iso     テキストに続くISO日付のみを含むメッセージ。PID、プロセス名、システム名は省略される。これはローカルログサーバーで使用するように設計されている。

  local   hostnameフィールドが削除されることを除いて、rfc3164 syslogメッセージフォーマットに類似している。これがデフォルトである。注意：オプション「log-send-hostname」はデフォルトをrfc3164に切り替える。

  raw     テキストのみを含むメッセージ。レベル、PID、日付、時刻、プロセス名、システム名は省略される。これは、重要度が使用されるファイル記述子（stdout/stderr）のみに依存するコンテナまたは開発中に使用するように設計されている。これがデフォルトである。

  rfc3164 RFC3164 syslogメッセージフォーマット。
          (https://tools.ietf.org/html/rfc3164)

  rfc5424 RFC5424 syslogメッセージフォーマット。
          (https://tools.ietf.org/html/rfc5424)

  short   '&lt;3&gt;'のような角括弧内のレベルのみを含むメッセージで、その後にテキストが続く。PID、日付、時刻、プロセス名、システム名は省略される。これはローカルログサーバーで使用するように設計されている。このフォーマットは、systemdロガーが消費するものと互換性がある。

  priority 角括弧内のレベルとsyslogファシリティのみを含むメッセージで、'&lt;63&gt;'のようなもので、その後にテキストが続く。PID、日付、時刻、プロセス名、システム名は省略される。これはローカルログサーバーで使用するように設計されている。

  timed   角括弧内のレベルのみを含むメッセージで、'&lt;3&gt;'のようなもので、その後にISO日付とテキストが続く。PID、プロセス名、システム名は省略される。これはローカルログサーバーで使用するように設計されている。

**maxlen** &lt;length&gt;

リングに格納されるイベントメッセージの最大長（フォーマットされたヘッダーを含む）。イベントメッセージが&lt;length&gt;より長い場合、この長さに切り詰められる。

**server** &lt;name&gt; &lt;address&gt; [param*]

リングバッファからメッセージを転送するsyslog tcpサーバーを設定するために使用される。これは5.2段落で見つかったすべての「server」パラメータをサポートする。これらのパラメータの一部は「ring」セクションには無関係である。重要なポイント：リングに複数のサーバーを追加する理由はほとんどない。なぜなら、すべてのサーバーがリングコンテンツの正確に同じコピーを受け取るため、リングは最も遅いサーバーの速度で進行するからである。1つのサーバーが応答しない場合、古いメッセージの削除を防ぎ、新しいメッセージがリングに挿入されることをブロックする可能性がある。複数のサーバーにメッセージを送信する適切な方法は、同じリングに複数のサーバーを添付することではなく、ログサーバーごとに1つの異なるリングを使用することである。特定のサーバーディレクティブ「log-proto」がメッセージの送信に使用されるプロトコルを設定するために使用されることに注意すること。

**size** &lt;size&gt;

これはリングバッファのオプションのサイズ（バイト単位）である。デフォルト値はBUFSIZEに設定される。

**timeout connect** &lt;timeout&gt;

サーバーへの接続試行が成功するために待機する最大時間を設定する。

**Arguments :**

&lt;timeout&gt; はデフォルトでミリ秒単位で指定されるタイムアウト値であるが、このドキュメントの上部で説明されているように、数値に単位が付いている場合は他の単位でも可能である。

**timeout server** &lt;timeout&gt;

出力バッファに残っている保留データの最大時間を設定する。

**Arguments :**

&lt;timeout&gt; はデフォルトでミリ秒単位で指定されるタイムアウト値であるが、このドキュメントの上部で説明されているように、数値に単位が付いている場合は他の単位でも可能である。

**Example:**

```
global
    log ring@myring local7

ring myring
    description "My local buffer"
    format rfc5424
    maxlen 1200
    size 32764
    timeout connect 5s
    timeout server 10s
    server mysyslogsrv 127.0.0.1:6514 log-proto octet-count
```
### 12.6 Log forwarding

1つまたは複数のログ転送セクションを宣言することが可能である。HAProxyは受信したすべてのログメッセージをログサーバーのリストに転送する。

**log-forward** &lt;name&gt;

名前&lt;name&gt;で識別される新しいログ転送プロキシを作成する。

**backlog** &lt;conns&gt;

接続受け入れ時の希望するリスンバックログの概算サイズについてシステムにヒントを与える。

**bind** &lt;addr&gt; [param*]

転送するメッセージを受信するストリームログリスナーを設定するために使用される。これは5.1段落で見つかった「bind」パラメータをサポートする（SSLに関するものを含む）が、「alpn」などの一部のステートメントはTCP経由のsyslogプロトコルには無関係である可能性がある。これらのリスナーは、rfc-6587で定義されている「Octet Counting」と「Non-Transparent-Framing」の両方のモードをサポートする。

**dgram-bind** &lt;addr&gt; [param*]

転送するメッセージを受信するデータグラムログリスナーを設定するために使用される。アドレスはIPv4またはIPv6形式で、その後にポートが続く必要がある。これは5.1段落で見つかった「bind」パラメータの一部をサポートする。その中には「interface」、「namespace」または「transparent」があり、他のものはUDP/syslogケースには無関係であるため静かに無視される。

**log global**

**log** &lt;target&gt; [len &lt;length&gt;] [format &lt;format&gt;] [sample &lt;ranges&gt;:&lt;sample_size&gt;]
    &lt;facility&gt; [&lt;level&gt; [&lt;minlevel&gt;]]

ターゲットログサーバーを設定するために使用される。プロキシのドキュメントの詳細を参照すること。
フォーマットが指定されていない場合、HAProxyは受信ログフォーマットを保持しようとする。
設定されたファシリティは無視されるが、受信メッセージがファシリティを提示しないが発信フォーマットで必須である場合を除く。
入力フォーマットでタイムスタンプが利用できないが、出力フォーマットでフィールドが存在する場合、HAProxyはローカル日付を使用する。

**Example:**

```
global
   log stderr format iso local7

ring myring
    description "My local buffer"
    format rfc5424
    maxlen 1200
    size 32764
    timeout connect 5s
    timeout server 10s
    # syslog tcp server
    server mysyslogsrv 127.0.0.1:514 log-proto octet-count

log-forward sylog-loadb
    dgram-bind 127.0.0.1:1514
    bind 127.0.0.1:1514
    # all messages on stderr
    log global
    # all messages on local tcp syslog server
    log ring@myring local0
    # load balance messages on 4 udp syslog servers
    log 127.0.0.1:10001 sample 1:4 local0
    log 127.0.0.1:10002 sample 2:4 local0
    log 127.0.0.1:10003 sample 3:4 local0
    log 127.0.0.1:10004 sample 4:4 local0
```

**maxconn** &lt;conns&gt;

ログ転送者の同時接続の最大数を固定する。デフォルトは10である。

**timeout client** &lt;timeout&gt;

クライアント側の最大非アクティブ時間を設定する。

**option assume-rfc6587-ntf**

HAProxyに受信TCPログストリームを常に非透過フレーミングを使用しているものとして扱うように指示する。このオプションはフレーミングロジックを簡素化し、メッセージの一貫した処理を保証する。特に、不適切に形成された開始文字を扱う際に有用である。

**option dont-parse-log**

HAProxyがsyslogメッセージを解析および再構築しようとすることなく中継することを可能にする。これは、従来のフォーマットに準拠していない可能性があるメッセージを転送するのに有用である。このオプションは、元のメッセージコンテンツが保持されることを保証するために、宛先ログターゲットでフォーマットraw設定と共に使用される必要がある。

**option host** { replace | fill | keep | append }

発信rfc3164またはrfc5424メッセージのsyslog hostnameフィールドに関するログ転送セクションで使用されるホスト戦略を設定する。

    replace 入力メッセージがすでにhostnameフィールドの値を含んでいる場合、送信者の送信元IPアドレスで置き換える。
            入力メッセージがhostnameフィールドの値を含んでいない場合（例：入力rfc5424メッセージとしての'-'または準拠していないrfc3164またはrfc5424メッセージ）、送信者の送信元IPアドレスをhostnameフィールドとして使用する。

    fill    入力メッセージがすでにhostnameフィールドの値を含んでいる場合、それを保持する。
            入力メッセージがhostnameフィールドの値を含んでいない場合（例：入力rfc5424メッセージとしての'-'または準拠していないrfc3164またはrfc5424メッセージ）、送信者の送信元IPアドレスをhostnameフィールドとして使用する。
            （これがデフォルト）

    keep    入力メッセージがすでにhostnameフィールドの値を含んでいる場合、それを保持する。
            入力メッセージがhostnameフィールドの値を含んでいない場合、'localhost'（rfc3164）または'-'（rfc5424）に設定する。

    append  入力メッセージがすでにhostnameフィールドの値を含んでいる場合、カンマに続いて送信者のIPアドレスを追加する。
            入力メッセージがhostnameフィールドの値を含んでいない場合、送信者の送信元IPアドレスを使用する。

上記のすべてのオプションについて、送信者の送信元IPアドレスが利用できない場合（例：UNIX/ABNSソケット）、結果として得られる戦略は「keep」である。

このオプションはrfc3164またはrfc5424宛先ログフォーマットにのみ関連することに注意すること。そうでなければ、オプションを設定しても目に見える効果はない。
### 12.7 Certificate Storage

HAProxyは、設定で使用される証明書を読み込み、格納するための内部ストレージメカニズムを使用する。このストレージは「crt-store」セクションを使用して設定することができる。これにより、証明書定義とどのファイルがそれに読み込まれるべきかを設定することができる。証明書定義は、設定の他の場所で使用される前に記述される必要がある。

**crt-store** [&lt;name&gt;]

「crt-store」は引数としてオプションの名前を取る。名前が指定されている場合、このストアのすべての証明書は「@&lt;name&gt;/&lt;crt&gt;」または「@&lt;name&gt;/&lt;alias&gt;」を使用して参照される必要がある。

証明書ストレージ内のファイルは、CLIを使用して動的に更新することもできる。
### 12.8 ACME

**acme** &lt;name&gt;

ACMEプロトコルは「acme」セクションを使用して設定することができる。セクションは「&lt;name&gt;」引数を取り、これは証明書をセクションにリンクするために使用される。

ACMEセクションにより、HAProxyをACMEv2クライアントとして設定することができる。この機能は実験的であることを意味し、「expose-experimental-directives」がグローバルセクションに含まれている必要があるため、これを使用することができる。

3.2現在の制限：機能は現在HTTP-01チャレンジに限定されている。現在のHAProxyアーキテクチャは非ブロッキングモデルであり、設定が読み込まれた後はディスクへのアクセスが行われることを想定していない。これはイベントループをブロックし、同じスレッド上のトラフィックをブロックする可能性があるためである。これは、HAProxyから生成される証明書とキーは、統計ソケットで「dump ssl cert」を使用してHAProxyの外部からダンプする必要があることを意味する。External Account Binding（EAB）はサポートされていない。

ACMEスケジューラーはHAProxy起動時に開始され、証明書をループし、notAfterタスクがcurtime + (notAfter - notBefore) / 12、またはnotBeforeが定義されていない場合は7日を過ぎたときにACME更新タスクを開始する。スケジューラーはその後12時間後にスリープして起動する。「acme renew」で手動で更新タスクを開始することも可能である。管理ガイドの「acme status」も参照すること。

ACMEセクションで使用可能なキーワードは以下の通りである：

**account-key** &lt;filename&gt;

アカウントキーへのパスを設定する。キーはHAProxyを起動する前に生成される必要がある。アカウントキーワードが使用されていない場合、acmeセクションはセクション名「&lt;name&gt;.account.key」を使用してファイル名を読み込もうとする。ファイルが存在しない場合、HAProxyはacmeセクションのパラメータを使用して1つを生成する。

opensslを使用して手動でRSA秘密鍵を生成することもできる：

  openssl genrsa -out account.key 2048

またはECDSAのもの：

  openssl ecparam -name secp384r1 -genkey -noout -out account.key

**bits** &lt;number&gt;

RSA証明書を生成するためのビット数を設定する。デフォルトは2048である。高すぎる値を設定すると、マシンが十分に強力でない場合に警告が発生する可能性がある。（これは「warn-blocked-traffic-after」で設定できるが、トラフィックをブロックしすぎるとウォッチドッグが発生する可能性がある。）

**challenge** &lt;string&gt;

パラメータとしてチャレンジタイプを取る。これはhttp-01またはdns-01でなければならない。使用されていない場合、デフォルトはhttp-01である。

**contact** &lt;string&gt;

CAのアカウントキーに関連付けられる連絡先メール。

**curves** &lt;string&gt;

ECDSAキータイプを使用する場合、曲線を設定する。デフォルトはP-384である。

**directory** &lt;string&gt;

このacmeセクションで使用されるCAのディレクトリURLを設定する。このキーワードは必須である。デフォルトURLがないためである。

**Example:**

```
directory https://acme-staging-v02.api.letsencrypt.org/directory
```

**keytype** &lt;string&gt;

生成されるキーのタイプを設定する。値は「RSA」または「ECDSA」のいずれかである。ECDSAの「curves」とRSAの「bits」数も設定できる。デフォルトではEC384キーが生成される。

**map** &lt;map&gt;

トークン（キー）とサムプリント（値）を格納するために使用されるマップを設定する。これは複数のアカウントが使用されている場合にチャレンジに応答するのに有用である。acmeタスクはチャレンジを検証する前にエントリを追加し、タスクの終了時にエントリを削除する。

**Example:**

```
global
    expose-experimental-directives
    httpclient.resolvers.prefer ipv4

frontend in
    bind *:80
    bind *:443 ssl
    http-request return status 200 content-type text/plain lf-string "%[path,field(-1,/)].%[path,field(-1,/),map(virt@acme)]\n" if { path_beg '/.well-known/acme-challenge/' }
    ssl-f-use crt "foo.example.com.pem.rsa"   acme LE1 domains "foo.example.com.pem,bar.example.com"
    ssl-f-use crt "foo.example.com.pem.ecdsa" acme LE2 domains "foo.example.com.pem,bar.example.com"

acme LE1
    directory https://acme-staging-v02.api.letsencrypt.org/directory
    account-key /etc/haproxy/letsencrypt.account.key
    contact john.doe@example.com
    challenge http-01
    keytype RSA
    bits 2048
    map virt@acme

acme LE2
    directory https://acme-staging-v02.api.letsencrypt.org/directory
    account-key /etc/haproxy/letsencrypt.account.key
    contact john.doe@example.com
    challenge http-01
    keytype ECDSA
    curves P-384
    map virt@acme
```
### 12.9 Programs (deprecated)

このセクションは非推奨であり、HAProxy 3.3で削除される予定である。セクションは分離されたプロセスマネージャーによって簡単に置き換えることができる。Systemdユニットファイルまたはsysvinitスクリプトは、より信頼性が高いため、このセクションを置き換えることができる。Docker環境では、s6やsupervisordなどの代替手段も見つけることができる。

マスター-ワーカーモードでは、マスターと共に外部バイナリを起動することが可能である。これらのプロセスはプログラムと呼ばれる。これらのプログラムは、ワーカーと同じ方法で起動され、管理される。

バージョン3.1以降、プログラムセクションはわずかに異なる動作をする。セクションは解析され、プログラムはマスターから開始されるが、設定の残りの部分はワーカーに読み込まれる。これは、プログラム設定がワーカー設定から完全に分離されていることを意味し、ワーカー設定が間違っている場合でも、リロード時にプログラムが再実行される可能性がある。

HAProxyのリロード中、これらのプロセスはワーカーと同じシーケンスを扱う：

  - マスターが再実行される
  - マスターがプログラムにSIGUSR1信号を送信する
  - 「option start-on-reload」が無効にされていない場合、マスターがプログラムの新しいインスタンスを起動する

停止または再起動中、SIGTERMがプログラムに送信される。

**program** &lt;name&gt;

これは新しいプログラムセクションである。このセクションは&lt;name&gt;のインスタンスを作成し、これはマスターCLIの「show proc」で見える。（管理ガイドの「9.4. Master CLI」を参照）。

**command** &lt;command&gt; [arguments*]

オプションの引数で開始するコマンドを定義する。コマンドは絶対パスを含まない場合、現在のPATHで検索される。これはプログラムセクションの必須オプションである。スペースを含む引数は引用符または二重引用符で囲むか、バックスラッシュを前置する必要がある。

**user** &lt;user name&gt;

実行されるコマンドのユーザーIDを/etc/passwdの&lt;user name&gt;に変更する。「group」も参照すること。

**group** &lt;group name&gt;

実行されるコマンドのグループIDを/etc/groupの&lt;group name&gt;に変更する。「user」も参照すること。

**option start-on-reload**

**no option start-on-reload**

マスターのリロード時にプログラムの新しいインスタンスを開始する（またはしない）。デフォルトは新しいインスタンスを開始することである。このオプションはプログラムセクションでのみ使用できる。
