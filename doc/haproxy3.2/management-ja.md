# HAProxy Management Guide 3.2.4

## LICENSE

```
本資料は、GPL v2ライセンスに基づき公開された 以下のドキュメントを簡易的に抜粋翻訳したもので、内容の正確性、網羅性は保証しない。
https://docs.haproxy.org/3.2/management.html

Copyright (c) 2006 Willy Tarreau - w@1wt.eu

この翻訳物の配布もGPL v2に従う。
```

## 1. 前提条件

この文書では、読者がUNIX系オペレーティングシステムにおいて十分な管理スキルを持ち、日常的にシェルを使用し、straceやtcpdumpなどのトラブルシューティングユーティリティに精通していることを前提としている。
## 2. HAProxyのアーキテクチャに関する簡単な復習

HAProxyは、マルチスレッド、イベント駆動、非ブロッキングのデーモンである。これは、システムが複数のアクティビティ間でスケジュールするのを頼るのではなく、イベント多重化を使用してすべてのアクティビティをスケジュールすることを意味している。ほとんどの場合、単一プロセスとして実行されるため、システムでの「ps aux」の出力は1つの「haproxy」プロセスのみを報告する。ただし、ソフトリロードが進行中で古いプロセスが新しいプロセスと並行してジョブを完了している場合を除く。したがって、straceユーティリティを使用してそのアクティビティを追跡することは常に容易である。利用可能なプロセッサの数に合わせてスケールするために、デフォルトではhaproxyは実行を許可されたプロセッサごとに1つのワーカースレッドを開始する。明示的に異なる設定がされていない限り、着信トラフィックはこれらすべてのスレッドに分散され、すべてが同じイベントループを実行している。スレッド間の依存関係を厳密な最小限に制限するよう細心の注意が払われており、ほぼ線形のスケーラビリティを達成しようとしている。これには、特定の接続が単一のスレッドによって処理されるという事実などの影響がある。したがって、利用可能なすべての処理能力を使用するには、スレッド数と少なくとも同じ数の接続が必要であり、これはほとんど常に保証されている。

HAProxyは、起動時にchroot jailに自身を隔離するように設計されており、そこでファイルシステムアクセスをまったく実行できない。これは、依存するライブラリ（例：libc、libsslなど）にも当てはまる。即座の効果は、実行中のプロセスが設定ファイルをリロードして変更を適用することができず、代わりに更新された設定ファイルを使用して新しいプロセスが開始されることである。その他のあまり明らかでない効果として、libcが実行時にアクセスしようとする可能性のある一部のタイムゾーンファイルやリゾルバーファイルが見つからないことがある。ただし、これらは起動後に必要ないため、一般的には発生すべきではない。この原則の良い結果として、HAProxyプロセスは完全にステートレスであり、殺された後にクリーンアップは必要ないため、機能する任意の殺害方法が正しいことを行う。

HAProxyはログファイルを書き込まず、標準のsyslogプロトコルに依存してログをリモートサーバー（多くの場合同じシステム上に配置されている）に送信する。

HAProxyは、タイムアウトを強制するために内部クロックを使用する。これはシステムの時間から派生しているが、予期しないドリフトは修正される。これは、poll()でイベントを待機する時間を制限し、実際にかかった時間を測定することによって行われる。実際には、1秒以上待機することはない。これが、完全にアイドル状態のプロセスでstraceを実行する際に、2つのgettimeofday()呼び出しで囲まれたpoll()（またはその変形のいずれか）への定期的な呼び出しが気づかれる理由を説明している。これらは正常で、完全に無害であり、システムスケールでそれらが暗示する負荷が完全に検出できないほど安価であるため、そこに異常なものは何もない。例：

  16:35:40.002320 gettimeofday({1442759740, 2605}, NULL) = 0
  16:35:40.002942 epoll_wait(0, {}, 200, 1000) = 0
  16:35:41.007542 gettimeofday({1442759741, 7641}, NULL) = 0
  16:35:41.007998 gettimeofday({1442759741, 8114}, NULL) = 0
  16:35:41.008391 epoll_wait(0, {}, 200, 1000) = 0
  16:35:42.011313 gettimeofday({1442759742, 11411}, NULL) = 0

HAProxyはTCPプロキシであり、ルーターではない。カーネルによって検証された確立された接続を処理し、任意の形式のパケットや他の状態のソケット（例：SYN_RECVやTIME_WAITではない）は処理しない。ただし、それらの存在はポートのバインドを妨げる可能性がある。着信接続を受け入れ、発信接続を開始するためにシステムに依存している。これの即座の効果は、転送された接続の両側で観察されるパケット間に関係がないことであり、これらは異なるサイズ、数、さらにはファミリーである可能性がある。接続はLISTEN状態のソケットからのみ受け入れられる可能性があるため、リッスンしているすべてのソケットは、リッスンしているソケットを表示する「netstat」ユーティリティを使用して必然的に可視である。例：

  # netstat -ltnp
  Active Internet connections (only servers)
  Proto Recv-Q Send-Q Local Address   Foreign Address   State    PID/Program name
  tcp        0      0 0.0.0.0:22      0.0.0.0:*         LISTEN   1629/sshd
  tcp        0      0 0.0.0.0:80      0.0.0.0:*         LISTEN   2847/haproxy
  tcp        0      0 0.0.0.0:443     0.0.0.0:*         LISTEN   2847/haproxy
## 3. HAProxyの起動

HAProxyは、コマンドラインで多数の引数を渡して「haproxy」プログラムを呼び出すことによって起動される。実際の構文は以下の通りである：

  $ haproxy [&lt;options&gt;]*

**where** [&lt;options&gt;]* は任意の数のオプションである。オプションは常に「-」で始まり、その後に1つ以上の文字が続き、さらに1つまたは複数の追加引数が続く場合がある。オプションなしでは、HAProxyはサポートされているオプションのリマインダーと共にヘルプページを表示する。利用可能なオプションは、オペレーティングシステムに基づいて若干異なる場合がある。これらのオプションの相当数は「global」セクションの同等のものと重複している。この場合、コマンドラインは常に設定ファイルよりも優先されるため、コマンドラインを使用して設定ファイルに触れることなく、すばやくいくつかの設定を強制することができる。現在のオプションリストは以下の通りである：

  -- &lt;cfgfile&gt;* : 「--」の後に続くすべての引数は、宣言順序で読み込まれ処理される設定ファイル/ディレクトリへのパスである。シェルに依存して数値順に並べられた多数のファイルを読み込む場合に主に有用である。「-f」も参照のこと。「--」と「-f」の違いは、各ファイル名の前に「-f」を1つ配置する必要があるのに対し、すべてのファイル名の前に単一の「--」が必要であることである。両方のオプションを一緒に使用でき、コマンドラインの順序は引き続き適用される。複数のファイルが指定されている場合、各ファイルはセクションボーダーで開始する必要があり、各ファイルの最初のキーワードは「global」、「defaults」、「peers」、「listen」、「frontend」、「backend」などのいずれかでなければならない。ファイルには、例えばサーバーリストだけを含めることはできない。

  -f &lt;cfgfile|cfgdir&gt; : &lt;cfgfile&gt;を読み込まれる設定ファイルのリストに追加する。&lt;cfgdir&gt;がディレクトリの場合、そのディレクトリに含まれるすべてのファイル（ファイルのみ）が辞書順（LC_COLLATE=Cを使用）で読み込まれる設定ファイルのリストに追加される。「.cfg」拡張子を持つファイルのみが追加され、隠しファイル（「.」で始まらない）のみが追加される。設定ファイルは宣言順序で読み込まれ処理される。このオプションは複数のファイルを読み込むために複数回指定できる。「--」も参照のこと。「--」と「-f」の違いは、各ファイル名の前に「-f」を1つ配置する必要があるのに対し、すべてのファイル名の前に単一の「--」が必要であることである。両方のオプションを一緒に使用でき、コマンドラインの順序は引き続き適用される。複数のファイルが指定されている場合、各ファイルはセクションボーダーで開始する必要があり、各ファイルの最初のキーワードは「global」、「defaults」、「peers」、「listen」、「frontend」、「backend」などのいずれかでなければならない。ファイルには、例えばサーバーリストだけを含めることはできない。

  -C &lt;dir&gt; : 設定ファイルを読み込む前にディレクトリ&lt;dir&gt;に変更する。相対パスを使用する場合に有用である。「--」の後にワイルドカードを使用する場合の警告は、実際にはシェルによってhaproxyを開始する前に置き換えられる。

  -D : デーモンとして開始する。プロセスはフォーク後に現在のターミナルから分離し、エラーはターミナルに報告されなくなる。これは設定の「global」セクションの「daemon」キーワードと同等である。不良な設定がシステムの起動を妨げないように、initスクリプトで常に強制することを推奨する。

  -L &lt;name&gt; : ローカルピア名を&lt;name&gt;に変更する。デフォルトはローカルホスト名である。これはピアレプリケーションでのみ使用される。設定ファイルで$HAPROXY_LOCALPEER変数を使用してピア名を参照できる。

  -N &lt;limit&gt; : プロキシあたりのデフォルトmaxconnを組み込みのデフォルト値（通常2000）の代わりに&lt;limit&gt;に設定する。デバッグでのみ有用である。

  -V : 詳細モードを有効にする（静寂モードを無効にする）。「-q」または「quiet」の効果を元に戻す。

  -W : マスター-ワーカーモード。これは設定の「global」セクションの「master-worker」キーワードと同等である。このモードは「master」を起動し、それが「workers」を監視する。このモードを使用すると、マスターにSIGUSR2シグナルを送信することによってHAProxyを直接リロードできる。マスター-ワーカーモードはフォアグラウンドまたはデーモンモードのいずれかと互換性がある。マルチプロセスとsystemdでこのモードを使用することを推奨する。

  -Ws : `notify`タイプのsystemdサービスをサポートするマスター-ワーカーモード。

  -4 : DNSリゾルバーにIPv4アドレスのみ（「A」レコード）を照会して受け入れることを強制する。これは、エンドツーエンドのデュアルスタック接続性を欠く特定の環境で困難に直面している場合に使用できる。グローバル「dns-accept-family」ディレクティブをオーバーライドし、それを「ipv4」に強制する。

  -c : 設定ファイルのチェックのみを実行し、バインドを試行する前に終了する。すべてが正常な場合、終了ステータスはゼロであり、エラーが発生した場合は非ゼロである。警告の存在は、警告がある場合に報告される。デフォルトでは、このオプションは成功メッセージを報告しない。「-V」と組み合わせると、成功時に「Configuration file is valid」メッセージが印刷される。

    スクリプトは、コマンドの成功を判断するために終了ステータスを使用する必要がある。

  -cc : 設定の条件ブロック内で使用される条件を評価する。条件が真の場合、終了ステータスはゼロであり、条件が偽の場合は1、エラーが発生した場合は2である。

  -d : デバッグモードを有効にする。これによりデーモンモードが無効になり、プロセスがフォアグラウンドに留まり、着信および発信イベントを表示することが強制される。initスクリプトで使用してはならない。

  -dC[key] : 設定ファイルをダンプする。これは行がトークン化された後に行われるため、コメントは削除され、インデントが強制される。非ゼロのキーが指定されている場合、機密/機密フィールドの前で行が切り詰められ、識別子とアドレスはCLIの匿名化モードで使用されるものと同じアルゴリズムを使用してこのキーでハッシュ化されて出力される。これは、同じキーを使用して匿名化されたダンプで何が起こっているかを理解する必要がある開発者と出力を安全に共有できることを意味する。CLIの「set anon」コマンドも参照のこと。

  -dD : 診断モードを有効にする。このモードは、疑わしい設定文に関する追加の警告を出力する。これは「zero-warning」モードでも起動を妨げることはなく、終了ステータスコードも変更しない。

  -dF : データファストフォワードを無効にする。これは、ストリームを起動することなく、データを一方の側から他方の側に直接渡すことによってデータ転送を最適化するメカニズムである。このディレクティブのおかげで、この最適化を無効にすることができる。カーネルTCPスプライシングも無効になることに注意すること。このコマンドは通常の使用を意図したものではなく、一般的に開発者が複雑なデバッグセッションに沿って提案するのみである。

  -dG : getaddrinfo()を使用してホスト名をアドレスに解決することを無効にする。getaddrinfo()が期待通りに動作しないと疑われる場合に使用できる。このオプションが利用可能になったのは、getaddrinfo()の多くの偽の実装が様々なシステムに存在し、トラブルシューティングが困難な異常を引き起こすためである。

  -dI : 安全でないフォークを有効にする。これはグローバルセクションの「insecure-fork-wanted」と同等である。ASANでaddr2lineをフォークしてアドレスを解決する必要があるすべてのreg-testsを実行する場合に有用である。

  -dK&lt;class[,class]*&gt; : 各クラスの登録されたキーワードのリストをダンプする。クラスのリストは「-dKhelp」で利用可能である。すべてのクラスは「-dKall」を使用してダンプできる。それ以外の場合、ヘルプに表示されるものの選択を、カンマ区切りのリストとして指定できる。出力形式は、どのクラスのキーワードがダンプされているかによって異なる（例：「cfg」は設定ファイル形式に似た既知の設定キーワードを表示し、「smp」は各ルールセットとの互換性マトリックスをプレフィックスとして持つサンプルフェッチ関数を表示する）。これらは人間がそのまま使用することはほとんどないが、特定の場所で新しいキーワードの出現を検出しようとする外部ツールにとって、一部のドキュメント、シンタックスハイライトファイル、設定パーサー、APIなどを自動的に更新するのに非常に役立つ場合がある。出力形式は時間の経過とともに少し進化する可能性があるため、この出力を使用して主に以前のアーカイブとの違いを検出することを本当に推奨する。すべてのキーワードがリストされているわけではないことに注意すること。多くのキーワードは、異なるキーワード登録サブシステムが作成されるずっと前に存在しており、そこには表示されない。ただし、新しいキーワードは現代のメカニズムを介してのみ追加されるため、この出力を使用して言語の追加を良好な精度で検出できると安全に想定できる。キーワードは設定が完全に解析された後にのみダンプされるため、動的に作成されたキーワードもダンプできる。ダンプして終了する良い方法は、既存の設定でサイレント設定チェックを実行することである：

       ./haproxy -dKall -q -c -f foo.cfg

    設定ファイルが利用できない場合、「-f /dev/null」を使用すると、すべてのデフォルトキーワードをダンプすることもできるが、その場合、リスナーがないため戻りステータスはゼロではなく、無視する必要がある。

  -dL : 設定処理の最後に読み込まれる動的共有ライブラリのリストをダンプする。これには一般的に、Luaコードから読み込まれたものなど、深い依存関係も含まれる。リストは、すべての依存関係のtarballを直接生成するために十分にサニタイズしやすい形式で印刷される。プログラムの起動を停止しないため、「-c」と「-q」を組み合わせて使用することを推奨する。その場合、読み込まれたオブジェクトのリストのみが表示される（またはエラーの場合は何も表示されない）。さらに、コアファイル分析を支援するためにそのようなパッケージを提供する場合、ほとんどのライブラリは実際にはシンボリックリンクであり、アーカイブを作成する際に逆参照する必要があることを覚えておくこと：

       ./haproxy -W -q -c -dL -f foo.cfg | tar -T - -hzcf archive.tgz

   詳細モード（-V）で開始された場合、共有ライブラリのアドレス範囲も列挙される。ただし、静寂モード（-q）が使用されている場合は除く。

  -dM[&lt;byte&gt;[,]][help|options,...] : メモリポイズニングを強制し、および/またはメモリの他のデバッグオプションを変更する。メモリポイズニングとは、malloc()またはpool_alloc()で割り当てられたすべてのメモリ領域が、呼び出し元に渡される前に&lt;byte&gt;で満たされることを意味する。&lt;byte&gt;が指定されていない場合、デフォルトは0x50（'P'）である。これは操作をわずかに遅くするが、コードで初期化が忘れられてランダムなクラッシュを引き起こす問題を確実にトリガーするのに有用である。-dM0は任意のmalloc()をcalloc()に変える効果があることに注意すること。いずれにせよ、このオプションを使用してバグが現れたり消えたりする場合、それはhaproxyにバグがあることを意味するため、報告すること。他の多くのオプションが、単独で、またはバイトの後にカンマが続く形で利用可能である。特別なオプション「help」は、現在サポートされているオプションとその現在の値をリストする。各デバッグオプションは強制的にオンまたはオフにできる。最適なオプションは通常、オペレーティングシステムに基づいてビルド時に選択され、開発者が提案しない限り調整する必要がない。サポートされているデバッグオプションには以下が含まれる（設定/クリア）：
      - fail / no-fail:
        これにより、グローバル「tune.fail-alloc」設定と組み合わせて、ランダムに失敗するメモリ割り当てが有効になる。これはコードで不足しているエラーチェックを検出するために使用される。オプションを設定すると、比率が1%の失敗率にプリセットされる。

      - no-merge / merge:
        デフォルトでは、非常に類似したサイズのプールがマージされ、より効率的になるが、これは特定のメモリダンプの分析を複雑にする。このオプションにより、このメカニズムを無効にでき、メモリ使用量がわずかに増加する可能性がある。

      - cold-first / hot-first:
        CPUキャッシュヒット率を最適化するために、デフォルトでは最も最近解放されたオブジェクト（「hot」）が新しい割り当てのためにリサイクルされる。しかし、そうすることでメモリダンプの分析も複雑になり、use-after-freeバグを隠す可能性がある。このオプションにより、代わりに最も冷たいオブジェクトを最初に選択でき、CPU使用量がわずかに増加する可能性がある。

      - integrity / no-integrity:
        このオプションが有効になっている場合、割り当てられた領域でメモリ整合性チェックが有効になり、最後に解放されてから変更されていないことを確認する。これは「no-merge」、「cold-first」、「tag」と組み合わせて最適に動作する。このオプションを有効にすると、CPU使用量がわずかに増加する。

      - backup / no-backup:
        このオプションは、解放時に各解放されたオブジェクトのコピーを実行し、開発者がそれらを検査できるようにする。また、割り当て時に比較も実行して、その間に何かが変更されたかどうかを検出し、use-after-free状態を示す。これはメモリ使用量を2倍にし、CPU使用量をわずかに増加させる（「integrity」と同様）。「integrity」と組み合わせた場合、内容は複製されるが、比較は実行されない（「integrity」によって実行される）。「integrity」と同様に、「no-merge」、「cold-first」、「tag」と組み合わせて最適に動作する。

      - no-global / global:
        オペレーティングシステムに応じて、標準アロケーターがスレッドで遅すぎるまたは非効率的であると推定される場合、プロセス全体のグローバルメモリキャッシュが有効になる場合がある。このオプションにより、強制的に無効にしたり有効にしたりできる。無効にすると、非効率的なアロケーターでCPU使用量が増加する可能性がある。有効にすると、効率的なアロケーターでメモリ使用量が高くなる可能性がある。

      - no-cache / cache:
        各スレッドは割り当てのための非常に高速なローカルオブジェクトキャッシュを使用し、これは常にデフォルトで有効になっている。このオプションにより、それを無効にできる。グローバルキャッシュもローカルキャッシュを経由するため、これにより効果的にすべてのキャッシュが無効になり、デフォルトアロケーターから直接割り当てが行われる。これによりCPU使用量が大幅に増加する可能性があるが、小さなシステムで小さなメモリ節約が得られる可能性もある。

      - caller / no-caller:
        このオプションを有効にすると、各割り当てられたオブジェクトに、それを割り当てたり解放した最後の呼び出し元のアドレスを保存するための追加のスペースが予約される。これは開発者がメモリダンプを分析する際に時間を遡って、予期しないことがどのように起こったかを推測するのに役立つ。

      - tag / no-tag:
        このオプションを有効にすると、各割り当てられたオブジェクトに、double-free、無効なオブジェクトの解放、バッファオーバーフローなどのバグを検出できるタグを保存するための追加のスペースが予約される。割り当てあたり4または8バイトの追加コストで、はるかに強力な信頼性保証を提供する。通常、メモリ破損を検出する最初のステップである。

      - poison / no-poison:
        このオプションを有効にすると、割り当てられたオブジェクトが固定パターンで満たされ、新しく追加されたフィールドが初期化ルーチンで誤って忘れられた場合、0などの偶発的な値が存在しないことが確実になる。そのようなバグは、特にプールがマージされていない場合、再現されることはめったにない。これは通常、バイトの値を-dMに直接渡すことによって有効になるが、このオプションを使用すると、以前に設定された値の使用を無効にしたり有効にしたりできる。

  -dR : リスニングポートでSO_REUSEPORTソケットオプションを無効にする。これは「global」セクションの「noreuseport」キーワードと同等である。これは、haproxyスレッド間で負荷分散の問題が観察されるマルチスレッドシナリオで適用できる場合がある（topで監視できる）。

  -dS : splice()システムコールの使用を無効にする。これは「global」セクションの「nosplice」キーワードと同等である。splice()が適切に動作しない、またはパフォーマンスの問題を引き起こすと疑われる場合、またはstraceを使用して転送されたデータを確認する場合に使用できる（splice()を使用すると表示されない）。

  -dV : サーバー側でのSSL検証を無効にする。これは設定の「global」セクションに「ssl-server-verify none」があることと同等である。これは本番環境外で本番の問題を再現しようとする場合に有用である。SSLセキュリティがサーバーに低下するため、initスクリプトで使用してはならない。

  -dW : 設定されている場合、設定の処理中に警告が発行された場合、haproxyは起動を拒否する。これは微妙な間違いを検出し、設定をクリーンでバージョン間で移植可能に保つのに役立つ。設定が人間によって管理されている場合、サービススクリプトでこのオプションを設定することを推奨するが、生成された設定では使用しないことを推奨する。生成された設定はより多くの警告を発行する傾向がある。これは「-c」と組み合わせて、チェックされた設定の警告を失敗させるために使用できる。これはグローバルオプション「zero-warning」と同等である。

  -dZ : 「ゼロコピー」モードでのデータ転送を無効にする。これは「global」セクションの「tune.disable-zero-copy-forwarding」キーワードと同等である。データ損失やデータ整合性の問題の場合、またはstraceを使用して転送されたデータを確認する場合に役立つ場合がある。カーネルTCPスプライシングも無効になるためである。

  -db : バックグラウンドモードとマルチプロセスモードを無効にする。プロセスはフォアグラウンドに留まる。これは主に開発中または小さなテスト中に使用され、Ctrl-Cでプロセスを停止するのに十分である。initスクリプトで使用してはならない。

  -dc : CPUアフィニティデバッグを有効にする。選択されたCPUと追放されたCPUのリスト、およびそれらのトポロジが開始前に報告される。

  -de : 「epoll」ポーラーの使用を無効にする。これは「global」セクションのキーワード「noepoll」と同等である。このポーラーに関連するバグを疑う場合に主に有用である。epollをサポートするシステムでは、フォールバックは一般的に「poll」ポーラーになる。

  -dk : 「kqueue」ポーラーの使用を無効にする。これは「global」セクションのキーワード「nokqueue」と同等である。このポーラーに関連するバグを疑う場合に主に有用である。kqueueをサポートするシステムでは、フォールバックは一般的に「poll」ポーラーになる。

  -dp : 「poll」ポーラーの使用を無効にする。これは「global」セクションのキーワード「nopoll」と同等である。このポーラーに関連するバグを疑う場合に主に有用である。pollをサポートするシステムでは、フォールバックは一般的に「select」ポーラーになる。これは無効にできず、1024ファイル記述子に制限される。

  -dr : サーバーアドレス解決の失敗を無視する。本番環境外で設定を検証する場合、同じリゾルバーにアクセスできず、サーバーアドレス解決で失敗することが非常に一般的であり、設定をテストすることが困難になる。このオプションは単純に「none」メソッドをすべてのサーバーのアドレス解決メソッドのリストに追加し、libcがアドレスの解決に失敗した場合でも、起動シーケンスが中断されないことを保証する。

  -dt [&lt;trace_desc&gt;,...] : stderrでトレースを有効にする。引数なしでは、これはエラーレベルですべてのトレースソースを有効にする。これは特にクライアントまたはサーバーからのプロトコル違反を検出するのに有用である場合がある。オプションの引数を使用して、カンマを区切り文字として使用して様々なトレース設定のリストを指定できる。各要素は1つまたはすべてのトレースソースを有効にする。さらに、レベルと詳細度は、各要素で「:」を内部区切り文字として使用して、トレース名でオプションで指定できる。無効な詳細度またはレベル名を入力すると、利用可能なキーワードのリストが提示される。例えば、最初にリストを確認するために各フィールドに「help」を渡すと便利な場合がある。

  -dv : 「evports」ポーラーの使用を無効にする。これは「global」セクションのキーワード「noevports」と同等である。このポーラーに関連するバグを疑う場合に主に有用である。イベントポートをサポートするシステム（Solaris 10以降から派生したSunOS）では、フォールバックは一般的に「poll」ポーラーになる。

  -m &lt;limit&gt; : 割り当て可能なメモリを制限する。これはプロセスのデータを保持するために使用され、&lt;limit&gt;メガバイトに制限される。これは通常の操作に必要なメモリの量に応じて、一部の接続拒否または一部の速度低下を引き起こす可能性がある。これは主にhaproxyプロセスを制約されたリソース消費シナリオで動作することを強制するために使用される。メモリはhaproxyプロセス間で共有されず、fork()システムコールを介して作成された子プロセスは親のリソース制限を継承することを覚えておくことが重要である。したがって、マスター-ワーカーモードでは、このメモリ制限はマスターとそのフォークされたワーカープロセスに個別に適用される。

  -n &lt;limit&gt; : プロセスあたりの接続制限を&lt;limit&gt;に制限する。これはグローバルセクションのキーワード「maxconn」と同等である。このキーワードよりも優先される。これは、リソース制限が低すぎるシステムでサービス停止を避けるために、すばやく低い制限を強制するために使用できる。

  -p &lt;file&gt; : 起動中にすべてのプロセスのpidを&lt;file&gt;に書き込む。これは「global」セクションのキーワード「pidfile」と同等である。ファイルはchroot jailに入る前に、および「-C」によって暗示されるchdir()を行った後に開かれる。各pidは独自の行に表示される。

  -q : 「quiet」モードを設定する。これにより出力メッセージが無効になる。「-c」と組み合わせて使用して、設定ファイルが有効かどうかのみをチェックできる。

  -S &lt;bind&gt;[,bind_options...]: マスター-ワーカーモードで、マスターCLIをバインドする。これにより、実行中または離脱中のすべてのプロセスにアクセスできる。セキュリティ上の理由から、マスターCLIをローカルUNIXソケットにバインドすることを推奨する。バインドオプションは、設定ファイルの「bind」キーワードと同じである。ただし、単語はスペースの代わりにカンマで区切られる。

    このソケットは、シームレスなリロード中に古いプロセスからリスニングソケットを取得するために使用できないことに注意すること。

  -sf &lt;pid&gt;* : 起動完了後に古いプロセスに「finish」シグナル（SIGUSR1）を送信して、現在行っていることを完了して離脱するよう要求する。&lt;pid&gt;はシグナルを送信するpidのリストである（引数ごとに1つ）。リストは「-」で始まる任意のオプションで終了する。pidのリストが空であることは問題ではないため、「pidof」や「pgrep」などのコマンドの結果に基づいて、その場で構築できる。

  -st &lt;pid&gt;* : 起動完了後に古いプロセスに「terminate」シグナル（SIGTERM）を送信して、現在行っていることを完了せずに即座に終了させる。&lt;pid&gt;はシグナルを送信するpidのリストである（引数ごとに1つ）。リストは「-」で始まる任意のオプションで終了する。pidのリストが空であることは問題ではないため、「pidof」や「pgrep」などのコマンドの結果に基づいて、その場で構築できる。

  -v : バージョンとビルド日を報告する。

  -vv : バージョン、ビルドオプション、ライブラリバージョン、および使用可能なポーラーを表示する。この出力は、バグレポートを提出する際に体系的に要求される。

  -x &lt;unix_socket&gt; : 指定されたソケットに接続し、古いプロセスからリスニングソケットを取得しようとし、新しいものをバインドしようとする代わりにそれらを使用する。これは、Linuxで設定をリロードする際に新しい接続を見逃すことを避けるのに有用である。

    マスター-ワーカーモードなしでは、設定で「expose-fd listeners」を使用してstatsソケットで機能を有効にする必要がある。

    マスター-ワーカーモードでは、「expose-fd listeners」は必要ない。マスターは「sockpair@」構文を使用してリロード時に自動的にこのオプションを使用する。これにより、設定で宣言されたstatsソケットを使用することなく、マスターがワーカーに直接接続できる。これを無効にしたい場合は、-x /dev/nullを渡すことができる。

initファイルからHAProxyを開始する安全な方法は、デーモンモードを強制し、既存のpidをpidファイルに保存し、このpidファイルを使用して古いプロセスに離脱前に完了するよう通知することである：

   haproxy -f /etc/haproxy.cfg \
           -D -p /var/run/haproxy.pid -sf $(cat /var/run/haproxy.pid)

設定がいくつかの特定のファイル（例：tcp vs http）に分割されている場合、「-f」オプションを使用することを推奨する：

   haproxy -f /etc/haproxy/global.cfg -f /etc/haproxy/stats.cfg \
           -f /etc/haproxy/default-tcp.cfg -f /etc/haproxy/tcp.cfg \
           -f /etc/haproxy/default-http.cfg -f /etc/haproxy/http.cfg \
           -D -p /var/run/haproxy.pid -sf $(cat /var/run/haproxy.pid)

顧客固有のファイルなど、未知の数のファイルが期待される場合、固定サイズのシーケンス番号で始まる名前を割り当て、「--」を使用してそれらを読み込むことを推奨する。場合によっては、いくつかのデフォルトを読み込んだ後に読み込む：

   haproxy -f /etc/haproxy/global.cfg -f /etc/haproxy/stats.cfg \
           -f /etc/haproxy/default-tcp.cfg -f /etc/haproxy/tcp.cfg \
           -f /etc/haproxy/default-http.cfg -f /etc/haproxy/http.cfg \
           -D -p /var/run/haproxy.pid -sf $(cat /var/run/haproxy.pid) \
           -f /etc/haproxy/default-customers.cfg -- /etc/haproxy/customers/*

何らかの理由で起動に失敗することがある。その場合、呼び出しているHAProxyのバージョンが期待されるバージョンであり、期待している機能（例：SSL、PCRE、圧縮、Luaなど）をサポートしているかどうかを確認することが重要である。これは「haproxy -vv」を使用して確認できる。特定のビルドオプション、ターゲットシステム、使用されているライブラリのバージョンなどの重要な情報がそこに報告される。また、バグレポートを投稿する際に体系的に要求されるものでもある：

  $ haproxy -vv
  HAProxy version 1.6-dev7-a088d3-4 2015/10/08
  Copyright 2000-2015 Willy Tarreau &lt;willy@haproxy.org&gt;

  Build options :
    TARGET  = linux2628
    CPU     = generic
    CC      = gcc
    CFLAGS  = -pg -O0 -g -fno-strict-aliasing -Wdeclaration-after-statement \
              -DBUFSIZE=8030 -DMAXREWRITE=1030 -DSO_MARK=36 -DTCP_REPAIR=19
    OPTIONS = USE_ZLIB=1 USE_DLMALLOC=1 USE_OPENSSL=1 USE_LUA=1 USE_PCRE=1

  Default settings :
    maxconn = 2000, bufsize = 8030, maxrewrite = 1030, maxpollevents = 200

  Encrypted password support via crypt(3): yes
  Built with zlib version : 1.2.6
  Compression algorithms supported : identity("identity"), deflate("deflate"), \
                                     raw-deflate("deflate"), gzip("gzip")
  Built with OpenSSL version : OpenSSL 1.0.1o 12 Jun 2015
  Running on OpenSSL version : OpenSSL 1.0.1o 12 Jun 2015
  OpenSSL library supports TLS extensions : yes
  OpenSSL library supports SNI : yes
  OpenSSL library supports prefer-server-ciphers : yes
  Built with PCRE version : 8.12 2011-01-15
  PCRE library supports JIT : no (USE_PCRE_JIT not set)
  Built with Lua version : Lua 5.3.1
  Built with transparent proxy support using: IP_TRANSPARENT IP_FREEBIND

  Available polling systems :
        epoll : pref=300,  test result OK
         poll : pref=200,  test result OK
       select : pref=150,  test result OK
  Total: 3 (3 usable), will use epoll.

多くの非開発者ユーザーがここで確認できる関連情報は以下の通りである：
  - バージョン：上記の1.6-dev7-a088d3-4は、コードが現在コミットID「a088d3」にあり、これは公式バージョン「1.6-dev7」の後の4番目のものであることを意味する。バージョン1.6-dev7は「1.6-dev7-8c1ad7」として表示される。ここで重要なのは実際には「1.6-dev7」である。これは将来バージョン1.6になるものの7番目の開発バージョンである。本番環境での使用に適していない開発バージョンである（正確に何をしているかを知っている場合を除く）。安定バージョンは「1.5.14-16f863」などの3つの数字のバージョンとして表示され、バージョン1.5の上に14番目の修正レベルを示す。これは本番環境で使用できるバージョンである。

  - リリース日：2015/10/08。これは普遍的な年/月/日形式で表される。ここでは2015年8月8日を意味する。安定リリースは数ヶ月ごとに発行される（最初は1-2ヶ月、製品が非常に安定すると6ヶ月になることもある）ことを考えると、ここで古い日付を見ている場合、それ以来修正された多数のバグやセキュリティ問題の影響を受けている可能性があり、公式サイトで確認する価値がある可能性がある。

  - ビルドオプション：これらは自分でパッケージをビルドする人に関連し、物事が期待通りに動作しない理由を説明できる。例えば上記の開発バージョンは、Linux 2.6.28以降用にビルドされ、汎用CPUをターゲットとし（CPU固有の最適化なし）、コード最適化（-O0）を欠いているため、パフォーマンスの面で悪いパフォーマンスを示す。

  - ライブラリバージョン：zlibバージョンはライブラリ自体で見つかったものとして報告される。一般的にzlibは非常に安定した製品と見なされ、アップグレードはほとんど必要ない。OpenSSLは2つのバージョンを報告する。ビルド時に使用されたバージョンと、システムで見つかった使用中のバージョンである。これらは最後の文字で異なる場合があるが、数字で異なることはない。ビルド日も報告される。これは、ほとんどのOpenSSLバグがセキュリティ問題であり、真剣に取り組む必要があるためである。このライブラリは絶対に最新の状態に保つ必要がある。ここで4ヶ月古いバージョンを見ることは非常に疑わしく、確かにアップデートが見逃された。PCREは非常に高速な正規表現を提供し、強く推奨される。JITなどの特定の拡張機能はすべてのバージョンに存在するわけではなく、まだ若いため、一部の人はそれらでビルドしないことを好む。これがビルドステータスも報告される理由である。Luaスクリプト言語に関して、HAProxyはバージョン5.3を期待する。これはHAProxy 1.6の少し前にリリースされたため非常に若い。Luaウェブサイトでこのブランチにいくつかの修正が提案されているかどうかを確認することが重要である。

  - 利用可能なポーリングシステムは、約1000以上の同時接続を処理する際にプロセスのスケーラビリティに影響する。これらは、ビルド時にTARGET変数で正しいシステムが示された場合にのみ利用可能である。「epoll」メカニズムはLinuxで強く推奨され、kqueueメカニズムはBSDで強く推奨される。これらがないと、poll()またはselect()が使用され、多数の接続を処理する際に高いCPU使用量を引き起こす。## 4. HAProxyの停止と再起動

HAProxyは、グレースフル停止とハード停止をサポートしている。ハード停止は単純で、haproxyプロセスにSIGTERMシグナルが送信されると、即座に終了し、確立されたすべての接続が閉じられる。グレースフル停止は、haproxyプロセスにSIGUSR1シグナルが送信されたときにトリガーされる。これは、リスニングポートからのバインド解除のみを行い、既存の接続が閉じられるまで処理を継続することを意味する。最後の接続が閉じられると、プロセスは終了する。

ハード停止方式は、サービス管理スクリプトの「stop」または「restart」アクションに使用される。グレースフル停止は、新しいプロセスで新しい設定をシームレスにリロードしようとする「reload」アクションに使用される。

これらのシグナルは両方とも、リロードまたは再起動中に新しいhaproxyプロセス自体によって送信される場合があり、それらは可能な限り最後の瞬間に送信され、絶対に必要な場合のみ送信される。これが「-st」（ハード）と「-sf」（グレースフル）オプションによってそれぞれ実行されることである。

マスター・ワーカーモードでは、設定をリロードするために新しいhaproxyプロセスを開始する必要はない。マスタープロセスは、SIGUSR2シグナルに反応して、-sfパラメータとワーカーのPIDに続いて自分自身を再実行する。マスターはその後設定ファイルを解析し、新しいワーカーをフォークする。

これらのシグナルがどのように使用されるかをよりよく理解するために、全体の再起動メカニズムを理解することが重要である。

まず、既存のhaproxyプロセスが実行されている。管理者は「/etc/init.d/haproxy reload」などのシステム固有のコマンドを使用して、新しい設定ファイルを有効にしたいことを示す。その後、以下のことが起こる。まず、サービススクリプト（/etc/init.d/haproxyまたは同等のもの）は「haproxy -c」を使用して設定ファイルが正しく解析されることを確認する。その後、「-st」または「-sf」を使用して、この設定ファイルでhaproxyを開始しようとする。

その後、HAProxyはすべてのリスニングポートにバインドしようとする。致命的なエラーが発生した場合（例：システム上にアドレスが存在しない、権限が拒否された）、プロセスはエラーで終了する。ソケットのバインドが失敗した場合（ポートが既に使用されているため）、プロセスは最初に「-st」または「-sf」PIDリストで指定されたすべてのPIDにSIGTTOUシグナルを送信する。これが「pause」シグナルと呼ばれるものである。これは、既存のすべてのhaproxyプロセスに、新しいプロセスが再びバインドを試行できるように、一時的にポートのリスニングを停止するよう指示する。この間、古いプロセスは既存の接続の処理を継続する。バインドがまだ失敗する場合（例えば、ポートが別のデーモンと共有されているため）、新しいプロセスは古いプロセスにSIGTTINシグナルを送信して、何も起こらなかったかのように操作を再開するよう指示する。古いプロセスはその後、ポートのリスニングを再開し、接続の受け入れを継続する。このメカニズムはシステムに依存し、一部のオペレーティングシステムではマルチプロセスモードでサポートされない場合があることに注意されたい。

新しいプロセスがすべてのポートに正しくバインドできた場合、すべてのプロセスにSIGTERM（「-st」の場合のハード停止）またはSIGUSR1（「-sf」の場合のグレースフル停止）を送信して、現在操作を担当しており、古いプロセスは即座に、または作業が完了した後に終了しなければならないことを通知する。

この時間枠中に、接続の失敗が数件発生する可能性がある数ミリ秒の2つの小さなウィンドウがあることに注意することが重要である。通常観察される失敗率は、リロード操作中に毎秒10000の新しい接続に対して約1回の失敗であり、これは毎秒30000の新しい接続で動作する高負荷サイトが、リロードごとに約3回の接続失敗を見る可能性があることを意味する。これが発生する2つの状況は以下の通りである：

  - 新しいプロセスが古いプロセスの存在によりバインドに失敗した場合、最初にSIGTTOU+SIGTTINシーケンスを経る必要があり、これは通常、数十のフロントエンドに対して約1ミリ秒続き、この間、一部のポートは古いプロセスにバインドされておらず、まだ新しいプロセスにもバインドされていない。HAProxyは、SO_REUSEPORTソケットオプションをサポートするシステムでこれを回避する。これにより、新しいプロセスは最初に古いプロセスにバインド解除を要求することなくバインドできる。ほとんどのBSDシステムは、これをほぼ永遠にサポートしている。Linuxはバージョン2.0でこれをサポートし、2.2頃に削除したが、その頃にはいくつかのパッチが流れていた。これはカーネル3.9で再導入されたため、上記で言及されたものより高い接続失敗率を観察している場合は、カーネルが3.9以上であること、または関連するパッチがカーネルにバックポートされていることを確認してください（可能性は低い）。

  - 古いプロセスがリスニングポートを閉じる際、カーネルが常にソケットのバックログに残っていた保留中の接続を再配布するとは限らない。高負荷下では、SYNパケットがソケットが閉じられる直前に発生する可能性があり、クライアントにRSTパケットが送信されることになる。1回のドロップさえ許容されない重要な環境では、これらは時々、リロード中にSYNパケットをブロックするファイアウォールルールを使用して処理され、クライアントに再送信を強制する。これは完全にシステムに依存する。一部のシステムは他のリスニングキューを訪問してこのRSTを回避できる場合がある。2番目のケースは、閉じられる直前にSYN_RECV状態にあったローカルソケット上のクライアントからのACKに関するものである。このACKは、haproxyプロセスがまだそれを認識していない間にRSTパケットにつながる。これは取り除くのが難しいが、上記で言及されたファイアウォールフィルタリングルールは、プロセスを再起動する約1秒前に適用された場合、うまく機能する。

大多数のユーザーにとって、このようなドロップは、レース条件をトリガーするのに十分な負荷がないため、決して発生しない。そして、ほとんどの高トラフィックユーザーにとって、少なくともSO_REUSEPORTがシステムで適切にサポートされている限り、失敗率はまだノイズマージン内でかなり適切である。
## 05. ファイル記述子の制限

すべての着信接続が正常に処理されることを確実にするために、HAProxyはロード時にプロセスのライフサイクル中に必要となるファイル記述子の総数を計算する。通常のUnixプロセスはデフォルトで1024個のファイル記述子が許可されており、特権プロセスはこの制限を自ら引き上げることができる。これがHAProxyをrootとして起動し、制限を調整させる理由の一つである。1024個のファイル記述子のデフォルト制限により、約500の同時接続を処理することができる。この計算は、プロセスあたりの総接続数を制限するグローバルmaxconnパラメータ、リスナーの数、ヘルスチェックが有効になっているサーバーの数、エージェントチェック、ピア、ロガー、およびその他の技術的要件に基づいている。この数の簡単な概算は、maxconn値を単純に2倍し、数十を加えることで必要なファイル記述子の概数を得る。

元々HAProxyはこの値を計算する方法を知らず、グローバルセクションで「ulimit-n」設定を使用して値を渡す必要があった。これが今日でも多くの設定でこの設定が存在する理由を説明している。残念ながら、これはしばしば誤計算され、必要なリソースを待機しながら着信接続を調整する代わりに、maxconnに近づいた際に接続失敗が発生した。この理由により、非常に古いバージョンから残っている可能性のある「ulimit-n」設定を削除することが重要である。

適度な負荷を受け入れるためにファイル記述子の数を増やすことは必須であるが、OS固有の調整が必要となる。まず、select()ポーリングシステムは1024個のファイル記述子に制限されている。実際、Linuxでは以前はより多くの処理が可能であったが、特定のOSが1024個を超えるファイル記述子でのselect()の使用を禁止する過度に制限的なSELinuxポリシーを搭載しているため、HAProxyは現在、実行時に問題を避けるためにこの場合の起動を拒否する。サポートされているすべてのオペレーティングシステムで、poll()が利用可能であり、この制限に悩まされることはない。これは自動的に選択されるため、動作する設定を得るために何もする必要はない。しかし、ファイル記述子の数が増加すると、pollは非常に遅くなる。HAProxyはこのパフォーマンスへの影響を最小限に抑えるために最善を尽くしているが（例：内部ファイル記述子キャッシュとバッチ処理の使用）、良い経験則として、1000を超える同時接続でpoll()を使用すると、多くのCPUを使用することになる。

カーネル2.6以上に基づくLinuxシステムでは、epoll()システムコールが使用される。これは、登録された監視対象ファイル記述子の数に関係なく、一定の起動時間を保証するカーネル内のコールバックに依存する、はるかにスケーラブルなメカニズムである。HAProxyがLinuxフレーバーのいずれか用にビルドされている場合、検出されると自動的に使用される。その存在とサポートは「haproxy -vv」を使用して確認できる。

サポートしているBSDシステムでは、kqueue()が代替として利用可能である。これはpoll()よりもはるかに高速で、変更のバッチ処理によりepoll()よりもわずかに高速である。少なくともFreeBSDとOpenBSDがサポートしている。Linuxのepoll()と同様に、そのサポートと可用性は「haproxy -vv」の出力で報告される。

良いポーラーを持つことは一つのことであるが、プロセスが制限に到達できることが必須である。HAProxyが起動すると、新しいプロセスのファイル記述子制限を即座に設定し、成功したかどうかを確認する。失敗した場合、フォークする前に報告するため、管理者は問題を確認できる。プロセスがrootとして起動されている限り、この設定が失敗する理由はないはずである。しかし、プロセスが非特権ユーザーによって起動された場合、失敗する可能性がある。HAProxyをrootとして起動しない説得力のある理由がある場合（例：エンドユーザーによって、またはアプリケーション固有のアカウントによって起動）、システム管理者はこの特定のユーザーのファイル記述子制限を引き上げることができる。設定の有効性は、ユーザーのコマンドラインから「ulimit -n」を発行することで確認できる。新しい制限が反映されるはずである。

警告：非特権ユーザーの制限がこのユーザーのアカウントで変更される場合、これらの値はユーザーがログインする時のみ考慮され、システム起動時に実行される一部のスクリプトやcrontabでは全く考慮されないことが非常に一般的である。これはオペレーティングシステムに完全に依存しており、この方法で実行する際は、haproxyを起動する前に「ulimit -n」をチェックすることを覚えておく。一般的なアドバイスは、本番目的でhaproxyを非特権ユーザーとして起動しないことである。もう一つの良い理由は、haproxyが一部のセキュリティ保護を有効にすることを防ぐことである。

システムがhaproxyプロセスに要求された数のファイル記述子の使用を許可することが確実になったら、2つの新しいシステム固有の制限に遭遇する可能性がある。最初のものは、システム全体のファイル記述子制限であり、これはシステム上で開かれているファイル記述子の総数で、すべてのプロセスをカバーしている。この制限に達すると、accept()またはsocket()は通常ENFILEを返す。2番目のものは、ファイル記述子の数に関するプロセスあたりのハード制限であり、setrlimit()がより高く設定されることを防ぐ。両方ともオペレーティングシステムに非常に依存している。Linuxでは、システム制限は起動時にメモリの量に基づいて設定される。「fs.file-max」sysctlで変更できる。プロセスあたりのハード制限はデフォルトで1048576に設定されているが、「fs.nr_open」sysctlを使用して変更できる。

ファイル記述子の制限は、設定が低すぎる場合に実行中のプロセスで観察される可能性がある。straceユーティリティは、プロセスの制限に達した際にaccept()とsocket()が「-1 EMFILE」を返すことを報告する。この場合、単純に「ulimit-n」値を引き上げる（または削除する）ことで問題が解決される。これらのシステムコールが「-1 ENFILE」を返す場合、カーネルの制限に達したことを意味し、システム全体のパラメータで何かを行う必要がある。これらの問題は絶対に対処する必要があり、高いCPU使用率（accept()が失敗した場合）とユーザーに一般的に表示される失敗した接続が発生するためである。一つの解決策は、シリアライゼーションを強制するためにグローバルmaxconn値を下げ、可能であればHTTP keep-aliveを無効にして接続を強制的に解放し、より速く再利用することも含む。
## 06. メモリ管理

HAProxyはシンプルで高速なプールベースのメモリ管理を使用する。少数の異なるオブジェクトタイプに依存しているため、各サイズごとにmalloc()を呼び出すよりも、適切なサイズのオブジェクトが既に含まれているプールから新しいオブジェクトを選択する方がはるかに効率的である。プールはスタックまたはLIFOとして編成されており、新しく割り当てられたオブジェクトは、CPUキャッシュ内でまだホットな最近解放されたオブジェクトから取得される。類似したサイズのプールは、メモリフラグメンテーションを制限するために統合される。

デフォルトでは、パフォーマンスに焦点が当てられているため、各解放されたオブジェクトは元のプールに戻され、割り当てられたオブジェクトは非常にすぐに再利用されることが期待されるため、決して解放されない。

CLIでは、「show pools」コマンドのおかげで、プール内でメモリがどのように使用されているかを確認することができる：
```txt
  &gt; show pools
  Dumping pools usage. Use SIGQUIT to flush them.
    - Pool cache_st (16 bytes) : 0 allocated (0 bytes), 0 used, 0 failures, 1 users, @0x9ccc40=03 [SHARED]
    - Pool pipe (32 bytes) : 5 allocated (160 bytes), 5 used, 0 failures, 2 users, @0x9ccac0=00 [SHARED]
    - Pool comp_state (48 bytes) : 3 allocated (144 bytes), 3 used, 0 failures, 5 users, @0x9cccc0=04 [SHARED]
    - Pool filter (64 bytes) : 0 allocated (0 bytes), 0 used, 0 failures, 3 users, @0x9ccbc0=02 [SHARED]
    - Pool vars (80 bytes) : 0 allocated (0 bytes), 0 used, 0 failures, 2 users, @0x9ccb40=01 [SHARED]
    - Pool uniqueid (128 bytes) : 0 allocated (0 bytes), 0 used, 0 failures, 2 users, @0x9cd240=15 [SHARED]
    - Pool task (144 bytes) : 55 allocated (7920 bytes), 55 used, 0 failures, 1 users, @0x9cd040=11 [SHARED]
    - Pool session (160 bytes) : 1 allocated (160 bytes), 1 used, 0 failures, 1 users, @0x9cd140=13 [SHARED]
    - Pool h2s (208 bytes) : 0 allocated (0 bytes), 0 used, 0 failures, 2 users, @0x9ccec0=08 [SHARED]
    - Pool h2c (288 bytes) : 0 allocated (0 bytes), 0 used, 0 failures, 1 users, @0x9cce40=07 [SHARED]
    - Pool spoe_ctx (304 bytes) : 0 allocated (0 bytes), 0 used, 0 failures, 2 users, @0x9ccf40=09 [SHARED]
    - Pool connection (400 bytes) : 2 allocated (800 bytes), 2 used, 0 failures, 1 users, @0x9cd1c0=14 [SHARED]
    - Pool hdr_idx (416 bytes) : 0 allocated (0 bytes), 0 used, 0 failures, 1 users, @0x9cd340=17 [SHARED]
    - Pool dns_resolut (480 bytes) : 0 allocated (0 bytes), 0 used, 0 failures, 1 users, @0x9ccdc0=06 [SHARED]
    - Pool dns_answer_ (576 bytes) : 0 allocated (0 bytes), 0 used, 0 failures, 1 users, @0x9ccd40=05 [SHARED]
    - Pool stream (960 bytes) : 1 allocated (960 bytes), 1 used, 0 failures, 1 users, @0x9cd0c0=12 [SHARED]
    - Pool requri (1024 bytes) : 0 allocated (0 bytes), 0 used, 0 failures, 1 users, @0x9cd2c0=16 [SHARED]
    - Pool buffer (8030 bytes) : 3 allocated (24090 bytes), 2 used, 0 failures, 1 users, @0x9cd3c0=18 [SHARED]
    - Pool trash (8062 bytes) : 1 allocated (8062 bytes), 1 used, 0 failures, 1 users, @0x9cd440=19
  Total: 19 pools, 42296 bytes allocated, 34266 used.
```
プール名は指示的なものであり、このプールを使用する最初のオブジェクトタイプの名前である。括弧内のサイズは、このプール内のオブジェクトのオブジェクトサイズである。オブジェクトサイズは常に16バイトの最も近い倍数に切り上げられる。現在割り当てられているオブジェクトの数と同等のバイト数が報告されるため、どのプールが最高のメモリ使用量の原因となっているかを簡単に知ることができる。現在使用中のオブジェクトの数も「used」フィールドで報告される。「allocated」と「used」の違いは、解放されて即座に使用可能になったオブジェクトに対応する。行末のアドレスはプールのアドレスであり、その後の数字は存在する場合のプールインデックス、またはインデックスが割り当てられていない場合は-1として報告される。

「-m」コマンドラインオプションを使用して、プロセスあたりの割り当てメモリ量を制限することができる。これはメガバイト単位の数字が続く。これはプロセスのアドレス可能な空間全体をカバーするため、一部のライブラリが使用するメモリとスタックも含まれるが、リソース制約のあるシステムを構築する際の信頼できる制限である。これは、それを持つシステムでは「ulimit -v」と同じように、他のシステムでは「ulimit -d」と同じように動作する。

メモリ制限に達したか、システムに十分なメモリがないためにメモリ割り当てが失敗した場合、haproxyは最初に、再度メモリを割り当てようとする前に、すべてのプールから利用可能なオブジェクトを解放し始める。この未使用メモリを解放するメカニズムは、haproxyプロセスにSIGQUITシグナルを送信することでトリガーできる。これを行う際、プロセスがフォアグラウンドで実行されている場合、フラッシュ前のプールの状態もstderrに報告される。

リロード操作中、優雅な停止状態に切り替わったプロセスも、接続を解放した後、自動的にいくつかのフラッシュを実行し、新しいプロセスのためにすべての可能なメモリを保存するために解放する。
## 07. CPU使用率

HAProxyは通常、時間の大部分をシステムで過ごし、ユーザーランドではより小さな部分を過ごす。細かく調整された3.5 GHz CPUは、単一コアで100% CPUの状態で、1秒あたり約80000のエンドツーエンド接続セットアップとクローズを維持できる。1つのコアが飽和状態になると、典型的な数値は以下のようになる：
  - 95%システム、5%ユーザー（長いTCP接続または大きなHTTPオブジェクトの場合）
  - 85%システム、15%ユーザー（短いTCP接続またはクローズモードでの小さなHTTPオブジェクトの場合）
  - 70%システム、30%ユーザー（keep-aliveモードでの小さなHTTPオブジェクトの場合）

ルール処理と正規表現の量は、ユーザーランド部分を増加させる。ファイアウォールルール、接続追跡、システム内の複雑なルーティングテーブルの存在は、代わりにシステム部分を増加させる。

ほとんどのシステムで、ネットワーク転送中に観察されるCPU時間は4つの部分に分けることができる：
  - 割り込み部分：これは、ターゲットプロセスが知られる前の、I/O受信時に実行されるすべての処理に関するものである。典型的には、Rxパケットは割り込みでカウントされる。割り込み処理が専用スレッドに延期される可能性があるLinuxなどの一部のシステムでは、softirqとして表示される可能性があり、スレッドはksoftirqd/0（CPU 0用）と呼ばれる。この負荷を処理するCPUは一般的にハードウェア設定によって定義されるが、softirqの場合は、処理を別のCPUに再マッピングすることがしばしば可能である。この割り込み部分は、プロセスに関連付けられていないため、しばしば寄生として認識されるが、実際にはプロセスの作業を準備するために実行される処理である。

  - システム部分：これは、ユーザーランドから呼び出されたカーネルコードを使用して実行されるすべての処理に関するものである。システムコールは例としてシステムとしてカウントされる。同期的に配信されるすべてのTxパケットは、システム時間としてカウントされる。一部のパケットがキューが満杯になるために延期される必要がある場合、それらは後で割り込みコンテキストで処理される可能性がある（例：TCPウィンドウを開くACKを受信した時）。

  - ユーザー部分：これは、ユーザーランドでアプリケーションコードを排他的に実行する。HAProxyは、システムコールを多用するが、この部分で排他的に実行される。ルール処理、正規表現、圧縮、暗号化はすべて、CPU消費のユーザー部分に追加される。

  - アイドル部分：これは、何もすることがない時にCPUが行うことである。例えば、HAProxyは着信接続を待機するか、一部のデータが離れるのを待機する。これは、システムがクライアントからのACKを待機してこれらのデータをプッシュすることを意味する。

HAProxyの活動に関する実際の運用では、割り込み/softirqがカーネルドライバーでのRx処理によって引き起こされ、ユーザーランドがHAProxyでのレイヤー7処理によって引き起こされ、システム時間がTxパスでのネットワーク処理によって引き起こされると考えることは、一般的に合理的に正確である（しかし完全に不正確である）。

HAProxyはイベントループの周りで実行されるため、poll()（または任意の代替）を使用して新しいイベントを待機し、poll()に戻って新しいイベントを待機する前に、これらのイベントをできるだけ速く処理する。poll()で待機に費やした時間と、イベント処理に費やした時間を比較して測定する。ポーリング時間と総時間の比率は「アイドル」時間と呼ばれ、何かが起こるのを待機するために費やされた時間の量である。この比率は、統計ページの「idle」行、またはCLIの「Idle_pct」で報告される。100%に近い場合、負荷が極めて低いことを意味する。0%に近い場合、常に何らかの活動があることを意味する。過負荷システムでは、他のプロセスがhaproxyプロセスからCPUを先取りする可能性があるため、非常に正確ではないが、HAProxyがどのように作業していると考えるかについての良い推定値を提供する：負荷が低く、アイドル比率も低い場合、HAProxyが処理する必要がある非常に高価なルールが原因で、HAProxyが多くの作業を行う必要があることを示す可能性がある。逆に、HAProxyがアイドルが100%に近いことを示しているが、物事が遅い場合、既に入力データの処理を待機しているため、物事を高速化するために何もできないことを意味する。以下の例では、haproxyは完全にアイドル状態である：

  $ echo "show info" | socat - /var/run/haproxy.sock | grep ^Idle
  Idle_pct: 100

アイドル比率が非常に低くなり始めた時、システムを調整し、プロセスと割り込みを正しく配置して、すべてのタスクのために可能な限り多くのCPUリソースを節約することが重要である。ファイアウォールが存在する場合、パフォーマンス制限の大部分の原因となっていないことを確実にするために、それを無効にしたり調整したりする価値がある。ステートフルファイアウォールをアンロードすることは、RxとTxパスの両方で動作するため、一般的に割り込み/softirqの量とシステム使用量の両方を削減することに注意する価値がある。Linuxでは、nf_conntrackとip_conntrackモジュールをアンロードすることで、何かを得ることができるかどうかが示される。そうである場合、モジュールはデフォルト設定で実行され、より良いパフォーマンスのためにそれを調整する方法を理解する必要がある。一般的に、これはハッシュテーブルサイズを大幅に増やすことで構成される。FreeBSDでは、「pfctl -d」は「pf」ファイアウォールとそのステートフルエンジンを同時に無効にする。

割り込み/softirqで多くの時間が費やされていることが観察される場合、それらが同じCPUで実行されていないことを確実にすることが重要である。ほとんどのシステムは、特定のワークロードでは物事を改善するため、ネットワークトラフィックを受信するCPUでタスクを固定する傾向がある。しかし、ネットワークに大きく依存するワークロードでは、haproxyプロセスがそのカーネル対応と戦う必要があるため、逆である。haproxyを1つのCPUコアに固定し、割り込みを別のコアに固定し、すべてが同じL3キャッシュを共有することは、実際にはhaproxyとネットワークスタックの作業量が非常に近いため、それぞれがほぼCPU全体を埋めることができるため、ネットワークパフォーマンスを適切に増加させる傾向がある。Linuxでは、これはtaskset（haproxy用）またはcpu-map（haproxy設定から）を使用して実行され、割り込みは/proc/irqの下で割り当てられる。多くのネットワークインターフェースは、複数のキューと複数の割り込みをサポートしている。一般的に、それらすべてが同じL3キャッシュを共有している場合、少数のCPUコアに分散することは役立つ。このようなワークロードでは、常に最悪の可能なことを行うirq_balanceを常に停止してください。

多くのSSLトラフィックまたは多くの圧縮で構成されるCPUに縛られたワークロードの場合、特定のタスクに専念する複数のプロセスを使用する価値がある可能性があるが、ここでは普遍的なルールはなく、実験を実行する必要がある。

CPU容量を増加させるために、グローバルセクションで「nbproc」ディレクティブを使用して、HAProxyを複数のプロセスとして実行することができる。ただし、いくつかの制限がある：
  - ヘルスチェックはプロセスごとに実行されるため、ターゲットサーバーは実行中のプロセスと同じ数のチェックを受ける；
  - maxconn値とキューはプロセスごとであるため、サーバーを過負荷にしないために正しい値を設定する必要がある；
  - 発信接続は競合を避けるためにポート範囲の使用を避ける必要がある
  - スティックテーブルはプロセスごとであり、プロセス間で共有されない；
  - 各ピアセクションは一度に単一のプロセスでのみ実行される可能性がある；
  - CLI操作は一度に単一のプロセスでのみ動作する。

これを考慮すると、最も簡単なセットアップは、多くの場合、重い処理を担当し、トラフィックを単一プロセスで実行される第2層に渡す、複数のプロセスで実行される第1層を持つことで構成されることが示される。このメカニズムは、2つのCPU重い機能であるSSLと圧縮に適している。インスタンスはUNIXソケット（TCPソケットよりも安価で、ポートを浪費しない）を介して簡単にチェーンでき、次の段階にクライアント情報を渡すのに役立つプロキシプロトコルも使用できる。これを行う際、すべての単一プロセスタスクをプロセス番号1にバインドし、追加のタスクを次のプロセスにバインドすることは、一般的に良いアイデアである。これにより、異なるマシン用の類似した設定を生成することが容易になる。

Linuxバージョン3.9以上では、各プロセスが同じIP:portで異なるリスニングソケットを使用する場合、マルチプロセスモードでHAProxyを実行することははるかに効率的である。これにより、カーネルはすべてのプロセスを起動する代わりに、すべてのプロセスに負荷を均等に分散する。詳細については、設定マニュアルの「bind」キーワード行の「process」オプションを確認してください。
## 8. Logging

ログ記録について、HAProxyはファイルシステムアクセスを一切行わないため、常にsyslogサーバーに依存している。標準的な使用方法は、ログサーバー（デフォルトではポート514）にUDP経由でログを送信することである。非常に一般的に、これはローカルのsyslogデーモンが動作している127.0.0.1に設定されるが、ネットワーク経由で中央サーバーにログを記録するためにも使用される。中央サーバーは、特にログを到着順にマージしておくことが望ましいアクティブ-アクティブシナリオにおいて、追加の利点を提供する。HAProxyはまた、UNIXソケットを使用してローカルのsyslogデーモンにログを送信することもできるが、これは全く推奨されない。なぜなら、haproxyが動作中にsyslogサーバーが再起動された場合、ソケットが置き換えられ、新しいログが失われるからである。HAProxyはchroot jail内に隔離されるため、新しいソケットに再接続する能力を持たない。また、現場では、UNIXソケットで使用されるログバッファが非常に小さく、非常に軽い負荷でもメッセージの損失につながることが観察されている。しかし、これはテストには適している場合がある。

HAProxyをファシリティ「local0」を使用してローカルデーモンにログを記録するために、「global」セクションに以下のディレクティブを追加することを推奨する：

      log 127.0.0.1:514 local0

そして、各「defaults」セクションまたは各frontendとbackendセクションに以下を追加する：

      log global

この方法により、すべてのログはログサーバーがどこにあるかのグローバル定義を通じて集中化される。

一部のsyslogデーモンは、デフォルトではUDPトラフィックをリッスンしないため、使用されているデーモンに応じて、これを有効にする構文は異なる：

  - sysklogdでは、デーモンのコマンドラインで引数「-r」を渡す必要がある。これにより、「リモート」ログ用のUDPソケットをリッスンする。アドレス127.0.0.1に制限する方法はないため、リモートシステムからのログも受信することに注意すること；

  - rsyslogdでは、設定ファイルに以下の行を追加する必要がある：

      $ModLoad imudp
      $UDPServerAddress *
      $UDPServerRun 514

  - syslog-ngでは、新しいソースを以下の方法で作成でき、その後、いずれかの「log」ディレクティブで有効なソースとして追加する必要がある：

      source s_udp {
        udp(ip(127.0.0.1) port(514));
      };

詳細については、syslogデーモンのマニュアルを参照すること。システムのログファイルにログが表示されない場合は、以下のテストを検討すること：

  - haproxyを再起動する。各frontendとbackendは、起動していることを示す1行をログに記録する。これらのログが受信される場合、ログが動作していることを意味する。

  - 「strace -tt -s100 -etrace=sendmsg -p &lt;haproxyのpid&gt;」を実行し、ログに記録されることを期待する何らかのアクティビティを実行する。そこでは、sendmsg()を使用してログメッセージが送信されているのが見えるはずである。それらが表示されない場合は、haproxyの上でstraceを使用して再起動する。それでもログが見えない場合、設定に何か問題があることを確実に意味する。

  - トラフィックがローカルに送信されている場合、ループバックインターフェースでポート514を監視するためにtcpdumpを実行する：「tcpdump -As0 -ni lo port 514」。パケットがそこで見える場合、それらが送信されていることの証明であり、その後syslogdデーモンのトラブルシューティングが必要である。

トラフィックログはfrontend（着信接続が受け入れられる場所）から送信されるが、backendもヘルスチェックに続くサーバー状態変更を報告するためにログを送信できる必要がある。すべての可能なログ設定に関する詳細については、HAProxyの設定マニュアルを参照すること。

他のデーモンで使用されていないファシリティを選択することが便利である。HAProxyの例では、トラフィックログには「local0」、管理ログには「local1」を提案することが多い。これらは現場で見られることがないからである。単一のファシリティでも十分である。ログを分離することはログ分析に便利であるが、ログが時々機密情報を伝達する可能性があり、そのため、偶然に不正な人に渡される可能性のある他のログと混在させてはならないことを覚えておくことも重要である。

サーバーの容量にあまり影響を与えずに現場でのトラブルシューティングを行うために、HAProxyに付属の「halog」ユーティリティを使用することを推奨する。これは、HAProxyログファイルを非常に高速なデータレートで処理するように設計されたgrepライクなユーティリティである。典型的な数値は、1秒間に1〜2 GBのログの範囲である。特定のログのみを抽出し（例：特定のクラスのHTTPステータスコードを検索、接続終了ステータス、応答時間範囲による検索、エラーのみを検索）、行をカウントし、出力を行数に制限し、サーバーを応答時間やエラー数でソートし、URLを時間やカウントでソートし、クライアントアドレスをアクセス数でソートするなど、より高度な統計を実行することができる。サイトでループしているボットなどの異常を素早く発見し、ブロックするのに非常に便利である。
## 9. 統計とモニタリング

HAProxyの状態について問い合わせることが可能である。最も一般的に使用される
メカニズムはHTTP統計ページである。このページはまた、モニタリングツール用の
代替CSV出力形式も公開している。同じ形式がUnixソケットでも提供されている。

統計は、HAProxyの複数のコンポーネントに対応するドメインとしてラベル付けされた
カテゴリに再グループ化される。利用可能なドメインは2つある：プロキシと
リゾルバーである。指定されていない場合、プロキシドメインが選択される。
HTTPページにはプロキシ統計のみが印刷されることに注意すること。
### 9.1 CSV形式

統計は、UnixソケットまたはHTTPページから照会することが可能である。両方の手段が
CSV形式を提供し、そのフィールドが続く。最初の行はシャープ（'#'）で始まり、
カンマ区切りのフィールドごとに1つの単語があり、これは列のタイトルを表す。
2番目から始まる他のすべての行は、カンマを区切り文字として使用し、二重引用符
（'&quot;'）をオプションのテキスト区切り文字として使用する古典的なCSV形式を使用するが、
これは囲まれたテキストが曖昧な場合（引用符やカンマが含まれている場合）のみである。
テキスト内の二重引用符文字（'&quot;'）は二重化される（'&quot;&quot;'）。これはほとんどのツールが
認識する形式である。ツールがハードコードされた列位置を使用することを壊さないように、
これらの前に列を挿入しないでください。

プロキシ統計の場合、各フィールド名の後に、そのフィールドに値を持つ可能性のある
タイプが括弧内で指定される。タイプはL（リスナー）、F（フロントエンド）、B（バックエンド）、
S（サーバー）である。静的フィールドの固定セットがあり、これらは常に同じ順序で
利用可能である。文字'-'を含む列は静的フィールドの終わりを区切り、その後の
フィールドの存在や順序は保証されない。

以下は、プロキシ統計ドメインを使用した静的フィールドのリストである：
  0. pxname [LFBS]: プロキシ名
  1. svname [LFBS]: サービス名（フロントエンドの場合はFRONTEND、バックエンドの場合はBACKEND、
     サーバー/リスナーの場合は任意の名前）
  2. qcur [..BS]: 現在キューに入っているリクエスト。バックエンドの場合、これは
     サーバーが割り当てられていないキューに入っている数を報告する。
  3. qmax [..BS]: qcurの最大値
  4. scur [LFBS]: 現在のセッション
  5. smax [LFBS]: 最大セッション
  6. slim [LFBS]: 設定されたセッション制限
  7. stot [LFBS]: 累積セッション数
  8. bin [LFBS]: 入力バイト
  9. bout [LFBS]: 出力バイト
 10. dreq [LFB.]: セキュリティ上の懸念により拒否されたリクエスト。
     - TCPの場合、これは一致したtcp-request contentルールによるものである。
     - HTTPの場合、これは一致したhttp-requestまたはtarpitルールによるものである。
 11. dresp [LFBS]: セキュリティ上の懸念により拒否されたレスポンス。
     - HTTPの場合、これは一致したhttp-requestルール、または
       "option checkcache"によるものである。
 12. ereq [L..]: リクエストエラー。考えられる原因の一部は：
     - リクエストが送信される前に、クライアントからの早期終了。
     - クライアントからの読み取りエラー
     - クライアントタイムアウト
     - クライアントが接続を閉じた
     - クライアントからの様々な不正なリクエスト。
     - リクエストがtarpitされた。
 13. econ [..BS]: バックエンドサーバーへの接続を試行中にエラーが発生した
     リクエストの数。バックエンド統計は、そのバックエンドのすべてのサーバーの
     統計の合計に、特定のサーバーに関連付けられていない接続エラー（バックエンドに
     アクティブなサーバーがないなど）を加えたものである。
 14. eresp [..BS]: レスポンスエラー。srv_abrtもここでカウントされる。
     その他のエラーは：
     - クライアントソケットでの書き込みエラー（サーバー統計ではカウントされない）
     - レスポンスにフィルターを適用する際の失敗。
 15. wretr [..BS]: サーバーへの接続が再試行された回数。
 16. wredis [..BS]: リクエストが別のサーバーに再ディスパッチされた回数。
     サーバー値は、そのサーバーが切り替えられた回数をカウントする。
 17. status [LFBS]: ステータス（UP/DOWN/NOLB/MAINT/MAINT(via)/MAINT(resolution)...）
 18. weight [..BS]: 総有効重み（バックエンド）、有効重み（サーバー）
 19. act [..BS]: アクティブなサーバーの数（バックエンド）、サーバーがアクティブ（サーバー）
 20. bck [..BS]: バックアップサーバーの数（バックエンド）、サーバーがバックアップ（サーバー）
 21. chkfail [...S]: 失敗したチェックの数。（サーバーがアップしている間の
     失敗したチェックのみをカウントする。）
 22. chkdown [..BS]: UP→DOWN遷移の数。バックエンドカウンターは、
     各サーバーのカウンターの合計ではなく、バックエンド全体がダウンする
     遷移をカウントする。
 23. lastchg [..BS]: 最後のUP←→DOWN遷移からの秒数
 24. downtime [..BS]: 総ダウンタイム（秒）。バックエンドの値は
     バックエンド全体のダウンタイムであり、サーバーダウンタイムの合計ではない。
 25. qlimit [...S]: サーバー用に設定されたmaxqueue、または値が0の場合は
     何もない（デフォルト、制限なしを意味する）
 26. pid [LFBS]: プロセスID（最初のインスタンスは0、2番目は1、...）
 27. iid [LFBS]: 一意のプロキシID
 28. sid [L..S]: サーバーID（プロキシ内で一意）
 29. throttle [...S]: サーバーの現在のスロットルパーセンテージ、slowstartが
     アクティブな場合、またはslowstartでない場合は値なし。
 30. lbtot [..BS]: サーバーが選択された総回数、新規セッション用、または
     再ディスパッチ時。サーバーカウンターは、そのサーバーが選択された回数である。
 31. tracked [...S]: トラッキングが有効な場合のプロキシ/サーバーのID。
 32. type [LFBS]: （0=フロントエンド、1=バックエンド、2=サーバー、3=ソケット/リスナー）
 33. rate [.FBS]: 最後の経過した1秒間の1秒あたりのセッション数
 34. rate_lim [.F..]: 1秒あたりの新規セッションの設定された制限
 35. rate_max [.FBS]: 1秒あたりの新規セッションの最大数
 36. check_status [...S]: 最後のヘルスチェックのステータス、以下のいずれか：
        UNK     -&gt; 不明
        INI     -&gt; 初期化中
        SOCKERR -&gt; ソケットエラー
        L4OK    -&gt; レイヤー4でチェックが通過、上位レイヤーテストは無効
        L4TOUT  -&gt; レイヤー1-4タイムアウト
        L4CON   -&gt; レイヤー1-4接続問題、例えば
                   "Connection refused"（tcp rst）または"No route to host"（icmp）
        L6OK    -&gt; レイヤー6でチェックが通過
        L6TOUT  -&gt; レイヤー6（SSL）タイムアウト
        L6RSP   -&gt; レイヤー6無効レスポンス - プロトコルエラー
        L7OK    -&gt; レイヤー7でチェックが通過
        L7OKC   -&gt; レイヤー7で条件付きチェックが通過、例えばdisable-on-404の404
        L7TOUT  -&gt; レイヤー7（HTTP/SMTP）タイムアウト
        L7RSP   -&gt; レイヤー7無効レスポンス - プロトコルエラー
        L7STS   -&gt; レイヤー7レスポンスエラー、例えばHTTP 5xx
     注意：チェックが現在実行中の場合、最後の既知のステータスが報告され、
     "* "がプレフィックスとして付く。例："* L7OK"。
 37. check_code [...S]: レイヤー5-7コード、利用可能な場合
 38. check_duration [...S]: 最後のヘルスチェックを完了するのに要した時間（ミリ秒）
 39. hrsp_1xx [.FBS]: 1xxコードのHTTPレスポンス
 40. hrsp_2xx [.FBS]: 2xxコードのHTTPレスポンス
 41. hrsp_3xx [.FBS]: 3xxコードのHTTPレスポンス
 42. hrsp_4xx [.FBS]: 4xxコードのHTTPレスポンス
 43. hrsp_5xx [.FBS]: 5xxコードのHTTPレスポンス
 44. hrsp_other [.FBS]: その他のコードのHTTPレスポンス（プロトコルエラー）
 45. hanafail [...S]: 失敗したヘルスチェックの詳細
 46. req_rate [.F..]: 最後の経過した1秒間の1秒あたりのHTTPリクエスト
 47. req_rate_max [.F..]: 観測された1秒あたりのHTTPリクエストの最大数
 48. req_tot [.FB.]: 受信したHTTPリクエストの総数
 49. cli_abrt [..BS]: クライアントによって中止されたデータ転送の数
 50. srv_abrt [..BS]: サーバーによって中止されたデータ転送の数
     （erespに含まれる）
 51. comp_in [.FB.]: コンプレッサーに供給されたHTTPレスポンスバイト数
 52. comp_out [.FB.]: コンプレッサーによって出力されたHTTPレスポンスバイト数
 53. comp_byp [.FB.]: HTTPコンプレッサーをバイパスしたバイト数
     （CPU/BW制限）
 54. comp_rsp [.FB.]: 圧縮されたHTTPレスポンスの数
 55. lastsess [..BS]: サーバー/バックエンドに最後のセッションが割り当てられてからの秒数
 56. last_chk [...S]: 最後のヘルスチェックの内容またはテキストエラー
 57. last_agt [...S]: 最後のエージェントチェックの内容またはテキストエラー
 58. qtime [..BS]: 最後の1024リクエストの平均キュー時間（ミリ秒）
 59. ctime [..BS]: 最後の1024リクエストの平均接続時間（ミリ秒）
 60. rtime [..BS]: 最後の1024リクエストの平均レスポンス時間（ミリ秒）
     （TCPの場合は0）
 61. ttime [..BS]: 最後の1024リクエストの平均総セッション時間（ミリ秒）
 62. agent_status [...S]: 最後のエージェントチェックのステータス、以下のいずれか：
        UNK     -&gt; 不明
        INI     -&gt; 初期化中
        SOCKERR -&gt; ソケットエラー
        L4OK    -&gt; レイヤー4でチェックが通過、上位レイヤーテストは無効
        L4TOUT  -&gt; レイヤー1-4タイムアウト
        L4CON   -&gt; レイヤー1-4接続問題、例えば
                   "Connection refused"（tcp rst）または"No route to host"（icmp）
        L7OK    -&gt; エージェントが"up"を報告
        L7STS   -&gt; エージェントが"fail"、"stop"、または"down"を報告
 63. agent_code [...S]: エージェントによって報告された数値コード（現在は未使用）
 64. agent_duration [...S]: 最後のチェックを完了するのに要した時間（ミリ秒）
 65. check_desc [...S]: check_statusの短い人間が読める説明
 66. agent_desc [...S]: agent_statusの短い人間が読める説明
 67. check_rise [...S]: チェックによって使用されるサーバーの"rise"パラメータ
 68. check_fall [...S]: チェックによって使用されるサーバーの"fall"パラメータ
 69. check_health [...S]: 0とrise+fall-1の間のサーバーのヘルスチェック値
 70. agent_rise [...S]: エージェントの"rise"パラメータ、通常は1
 71. agent_fall [...S]: エージェントの"fall"パラメータ、通常は1
 72. agent_health [...S]: 0とrise+fall-1の間のエージェントのヘルスパラメータ
 73. addr [L..S]: アドレス:ポートまたは"unix"。IPv6はアドレスの周りに括弧がある。
 74: cookie [..BS]: サーバーのクッキー値またはバックエンドのクッキー名
 75: mode [LFBS]: プロキシモード（tcp、http、health、unknown）
 76: algo [..B.]: ロードバランシングアルゴリズム
 77: conn_rate [.F..]: 最後の経過した1秒間の接続数
 78: conn_rate_max [.F..]: 既知の最高conn_rate
 79: conn_tot [.F..]: 累積接続数
 80: intercepted [.FB.]: インターセプトされたリクエストの累積数（monitor、stats）
 81: dcon [LF..]: "tcp-request connection"ルールによって拒否されたリクエスト
 82: dses [LF..]: "tcp-request session"ルールによって拒否されたリクエスト
 83: wrew [LFBS]: 失敗したヘッダー書き換え警告の累積数
 84: connect [..BS]: 接続確立試行の累積数
 85: reuse [..BS]: 接続再利用の累積数
 86: cache_lookups [.FB.]: キャッシュルックアップの累積数
 87: cache_hits [.FB.]: キャッシュヒットの累積数
 88: srv_icur [...S]: 再利用可能な利用可能なアイドル接続の現在の数
 89: src_ilim [...S]: 利用可能なアイドル接続の数の制限
 90. qtime_max [..BS]: 観測された最大キュー時間（ミリ秒）
 91. ctime_max [..BS]: 観測された最大接続時間（ミリ秒）
 92. rtime_max [..BS]: 観測された最大レスポンス時間（ミリ秒）（TCPの場合は0）
 93. ttime_max [..BS]: 観測された最大総セッション時間（ミリ秒）
 94. eint [LFBS]: 内部エラーの累積数
 95. idle_conn_cur [...S]: 安全でないアイドル接続の現在の数
 96. safe_conn_cur [...S]: 安全なアイドル接続の現在の数
 97. used_conn_cur [...S]: 使用中の接続の現在の数
 98. need_conn_est [...S]: 推定される必要な接続数
 99. uweight [..BS]: 総ユーザー重み（バックエンド）、サーバーユーザー重み（サーバー）

他のすべての統計ドメインの場合、フィールドの存在や順序は保証されない。
この場合、ヘッダー行を常に使用してCSVデータを解析する必要がある。
### 9.2 型付き出力形式

"&lt;a href="#show%20info"&gt;show info&lt;/a&gt;"と"&lt;a href="#show%20stat"&gt;show stat&lt;/a&gt;"の両方が、
各出力値がその型と、値がプロセス間でどのように集約されるべきか、および
どのように進化するかを知るのに十分な情報と共に来るモードをサポートしている。

すべての場合において、出力は1行に1つの値で構成され、すべての情報が
コロン（':'）で区切られたフィールドに分割される。

最初の列は、ダンプされているオブジェクトまたはメトリックを指定する。その形式は
この出力を生成するコマンドに固有であり、このセクションでは説明されない。
通常、一連の識別子とフィールド名で構成される。

2番目の列は、報告されている値の起源、性質、スコープをそれぞれ示す
3文字を含む。最初の文字（起源）は、値がどこから抽出されたかを示す。
可能な文字は：

  M   値はメトリックである。ある瞬間に有効であり、その性質に応じて
      変化する可能性がある。

  S   値はステータスである。定義上集約できない離散値を表す。
      サーバーのステータス（"UP"または"DOWN"）、プロセスのPIDなどである。

  K   値はソートキーである。そのクラス内で一意であるため、いくつかの値を
      グループ化するために使用される識別子を表す。すべての内部識別子は
      キーである。一部の名前は一意である場合、キーとしてリストされる
      （例：フロントエンド名は一意である）。一般的に、キーは設定から来るが、
      一部は自動的に割り当てられる場合がある。ほとんどの目的において、
      キーは設定と同等とみなすことができる。

  C   値は設定から来る。特定の設定値は出力で意味がある、例えば
      同時接続制限やクッキー名などである。定義上、これらの値は
      同じ設定ファイルから開始されたすべてのプロセスで同じである。

  P   値は製品自体から来る。そのような値は非常に少なく、最も一般的な
      使用法は製品名、バージョン、リリース日を報告することである。
      これらの要素もまた、すべてのプロセス間で同じである。

2番目の文字（性質）は、フィールドが運ぶ情報の性質を示し、
アグリゲーターが複数の値を集約するためにどの操作を使用するかを
決定できるようにする。可能な文字は：

  A   値は最後のイベントからの年齢を表す。これは期間とは少し異なり、
      年齢は現在の日付に基づいて自動的に計算される。典型的な例は、
      サーバーで最後のセッションがどれくらい前に発生したかである。
      年齢は一般に最小値を取ることによって集約され、保存する必要がない。

  a   値は既に平均化された値を表す。平均レスポンス時間とサーバー重みは
      この性質である。平均は通常、プロセス間で平均化できる。

  C   値は累積カウンターを表す。そのような測定値は、ラップアラウンドするまで
      永続的に増加する。一部のモニタリングプロトコルは、カウンターとゲージの
      違いを伝えて、異なるタイプを報告する必要がある。一般的に、
      カウンターはイベントやボリュームを表すため、単純に合計できる。
      この性質のメトリックの例は、接続数やバイト数である。

  D   値はステータスの期間を表す。これの使用法は少なく、そのほとんどは
      最後のヘルスチェックにかかった時間と、サーバーがダウンしていた時間を含む。
      期間は一般に合計されず、ほとんどの場合、SLAを計算するために
      最大値が保持される。

  G   値はゲージを表す。ある瞬間の測定値である。メモリ使用量や
      現在のアクティブ接続数はこの性質である。このタイプのメトリックは
      集約中に通常合計される。

  L   値は制限（一般に設定されたもの）を表す。性質上、制限は
      取得されたポイントに固有であるため、集約するのが困難である。
      特定の状況では、合計されるか、別々に保持される場合がある。

  M   値は最大値を表す。一般的にゲージに適用され、既知の最高値を保持する。
      そのようなメトリックの例は、製品のライフタイムで遭遇した
      同時接続の最大量である。最大値を正しく集約するには、
      すべての最大値の最大値から始まり、それらのすべての合計に
      至る範囲を出力する必要がある。それらが同時に遭遇したかどうかを
      知る方法は実際にない。

  m   値は最小値を表す。一般的にゲージに適用され、既知の最低値を保持する。
      そのようなメトリックの例は、製品のライフタイムで遭遇した
      空きメモリプールの最小量である。最小値を正しく集約するには、
      すべての最小値の最小値から始まり、それらのすべての合計に
      至る範囲を出力する必要がある。それらが同時に遭遇したかどうかを
      知る方法は実際にない。

  N   値は名前を表すので、文字列である。プロキシ名、サーバー名、
      クッキー名を報告するために使用される。名前は設定またはキーを
      起源として持ち、すべてのプロセス間で同じであることが想定される。

  O   値は自由テキスト出力を表す。様々なコマンドからの出力、
      ヘルスチェックからの戻り値、ノードの説明はそのような性質である。

  R   値はイベントレートを表す。ある瞬間の測定値である。
      受信者がこの測定値がゆっくりと移動し、すべての値を
      保持しないことを決定する場合があることを除いて、ゲージと
      非常に似ている。そのようなメトリックの例は、1秒あたりの
      測定された接続量である。このタイプのメトリックは、
      集約中に通常合計される。

  T   値は日付または時刻を表す。現在の日付を出力するフィールドは
      このタイプである。そのような情報を集約する方法は
      実装の選択として残される。現在、このタイプを使用する
      フィールドはない。

3番目の文字（スコープ）は、値が反映する範囲を示す。一部の要素は
プロセスごとである場合があり、他の要素は設定ごとまたはシステムごと
である場合がある。この区別は、集約中に単一の値を保持するか、
または値を集約する必要があるかを知るために重要である。
現在サポートされている文字は：

  C   値はノードのクラスター全体に有効である。これはピアプロトコルを
      介して通信するノードのセットである。例は、他のピアと
      レプリケートされるスティックテーブルに存在するエントリの量である。
      現在、このスコープを使用するメトリックはない。

  P   値はそれを報告するプロセスのみに有効である。ほとんどのメトリックは
      このスコープを使用する。

  S   値はサービス全体に有効である。これは同じ設定ファイルから
      一緒に開始されたプロセスのセットである。設定から来るすべての
      メトリックはこのスコープを使用する。他のメトリックも、
      一部の共有リソース（例：共有SSLキャッシュ統計）のために
      これを使用する場合がある。

  s   値はシステム全体に有効である。システムのホスト名、現在の日付、
      リソース使用量などである。現在、このスコープは
      どのメトリックによっても使用されていない。

これらの情報の消費者は、一般的にこれらの3文字で十分であり、
複数のプロセスにわたって集約された情報を正確に報告する方法を
決定できる。

この列の後、3番目の列はフィールドのタイプを示す。"s32"（符号付き32ビット整数）、
"s64"（符号付き64ビット整数）、"u32"（符号なし32ビット整数）、
"u64"（符号なし64ビット整数）、"str"（文字列）の間である。
値を適切に読み取るために、値を解析する前にタイプを知ることが重要である。
例えば、数字のみを含む文字列は依然として文字列であり、整数ではない
（例：チェックによって抽出されたエラーコード）。

その後、4番目の列は値自体であり、そのタイプに従ってエンコードされる。
文字列は、先頭のスペースなしでコロンの直後にそのままダンプされる。
文字列にコロンが含まれている場合、通常通り表示される。これは、
出力をコロンの周りで排他的に分割すべきではないか、一部のチェック出力
やサーバーアドレスが切り詰められる可能性があることを意味する。
### 9.3 Unixソケットコマンド

統計ソケットはデフォルトでは有効になっていない。これを有効にするには、
haproxy設定のグローバルセクションに1行を追加する必要がある。
より大きなタイムアウトを設定する2行目が推奨される。これは手動で
コマンドを発行する際に常に感謝される：

    global
        stats socket /var/run/haproxy.sock mode 600 level admin
        stats timeout 2m

行を繰り返すことによって、統計ソケットの複数のインスタンスを追加することも
可能である。そして、UNIXソケットの代わりにTCPポートでリッスンさせることもできる。
これは危険であるため、デフォルトでは決して行われないが、一部の状況では
便利である：

    global
        stats socket /var/run/haproxy.sock mode 600 level admin
        stats socket ipv4@192.168.0.1:9999 level admin
        stats timeout 2m

ソケットにアクセスするには、"socat"などの外部ユーティリティが必要である。
Socatは何でも何でもに接続するためのスイスアーミーナイフである。これを使用して
ターミナルをソケットに接続し、またはスクリプト用にstdin/stdoutパイプのペアを
それに接続する。使用する2つの主要な構文は以下の通りである：

    # socat /var/run/haproxy.sock stdio
    # socat /var/run/haproxy.sock readline

最初のものはスクリプトで使用される。スクリプトの出力をhaproxyに送信し、
haproxyの出力を別のスクリプトに渡すことが可能である。これは例えば
カウンターや攻撃トレースを取得するのに便利である。

2番目のものは、手動でコマンドを発行する場合にのみ便利である。ターミナルが
readlineライブラリによって処理されるという利点があり、これは行編集と
履歴をサポートし、繰り返しコマンドを発行する際に非常に便利である
（例：カウンターを監視する）。

ソケットは3つの操作モードをサポートしている：
  - 非対話的、サイレント
  - 対話的、サイレント
  - プロンプト付き対話的

非対話的モードは、socatがソケットに接続する際のデフォルトである。
このモードでは、1行が送信される可能性がある。それは全体として処理され、
レスポンスが送り返され、レスポンスの終了後に接続が閉じられる。これは
スクリプトとモニタリングツールが使用するモードである。このモードで
複数のコマンドを送信することが可能である。これらはセミコロン（';'）で
区切る必要がある。例えば：

    # echo "show info;show stat;show table" | socat /var/run/haproxy stdio

コマンドがセミコロンやバックスラッシュ（例：値内）を使用する必要がある場合、
バックスラッシュ（'\'）が前に付く必要がある。

対話的モードは、前の行からのコマンドが完了した後に新しいコマンドを
送信することを可能にする。これは2つのバリエーションで存在する。
1つはサイレントで、ソケットが閉じる代わりに新しいコマンドを待つことを
除いて非対話的モードのように動作する。もう1つは行の先頭にプロンプト（'&gt;'）
が表示される。対話的モードは高度なツールに推奨され、プロンプトモードは
人間に推奨される。

モードは"&lt;span class="dropdown"&gt;&lt;a class="dropdown-toggle" data-toggle="dropdown" href="#"&gt;prompt&lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt;&lt;ul class="dropdown-menu"&gt;&lt;li class="dropdown-header"&gt;このキーワードは以下のセクションで利用可能：&lt;/li&gt;&lt;li&gt;&lt;a href="#prompt%20%28Unix%20Socket%20commands%29"&gt;Unix Socket commands&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#prompt%20%28Master%20CLI%20commands%29"&gt;Master CLI commands&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/span&gt;"コマンドを使用して変更できる。デフォルトでは、
対話的+プロンプトモードを切り替える。対話的モードで"&lt;span class="dropdown"&gt;&lt;a class="dropdown-toggle" data-toggle="dropdown" href="#"&gt;prompt&lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt;&lt;ul class="dropdown-menu"&gt;&lt;li class="dropdown-header"&gt;このキーワードは以下のセクションで利用可能：&lt;/li&gt;&lt;li&gt;&lt;a href="#prompt%20%28Unix%20Socket%20commands%29"&gt;Unix Socket commands&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#prompt%20%28Master%20CLI%20commands%29"&gt;Master CLI commands&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/span&gt;"を入力すると、プロンプトモードに切り替わる。
コマンドはオプションで、以下の特定のモードのいずれかを取る：

  - "n" : 非対話的モード（単一コマンドで終了）
  - "i" : 対話的モード（複数コマンド、プロンプトなし）
  - "p" : プロンプトモード（プロンプト付き複数コマンド）

デフォルトモードは非対話的であるため、それに切り替えるには"&lt;span class="dropdown"&gt;&lt;a class="dropdown-toggle" data-toggle="dropdown" href="#"&gt;prompt&lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt;&lt;ul class="dropdown-menu"&gt;&lt;li class="dropdown-header"&gt;このキーワードは以下のセクションで利用可能：&lt;/li&gt;&lt;li&gt;&lt;a href="#prompt%20%28Unix%20Socket%20commands%29"&gt;Unix Socket commands&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#prompt%20%28Master%20CLI%20commands%29"&gt;Master CLI commands&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/span&gt;"を最初のコマンドとして使用する必要がある。
そうしないと、前のコマンドが接続を閉じる原因となる。非対話的モードに
切り替えると、同じ行のすべてのコマンドが完了した後に接続が閉じられる。

この理由により、手動でデバッグする際は、通常"&lt;span class="dropdown"&gt;&lt;a class="dropdown-toggle" data-toggle="dropdown" href="#"&gt;prompt&lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt;&lt;ul class="dropdown-menu"&gt;&lt;li class="dropdown-header"&gt;このキーワードは以下のセクションで利用可能：&lt;/li&gt;&lt;li&gt;&lt;a href="#prompt%20%28Unix%20Socket%20commands%29"&gt;Unix Socket commands&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#prompt%20%28Master%20CLI%20commands%29"&gt;Master CLI commands&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/span&gt;"コマンドで開始するのが一般的である：

   # socat /var/run/haproxy readline
   prompt
   &gt; show info
   ...
   &gt;

対話的ツールは、プロンプトなしで対話的モードに切り替えるために
"prompt i"で開始することを好む場合がある。

オプションで、プロセスの稼働時間がプロンプトに表示される場合がある。
これを有効にするには、"prompt timed"コマンドがプロンプトを有効にし、
時間の表示を切り替える。稼働時間は"d:hh:mm:ss"形式で表示される。
ここで"d"は日数、"hh"、"mm"、"ss"はそれぞれ時間、分、秒の数で、
それぞれ2桁である：

   # socat /var/run/haproxy readline
   prompt timed

   [23:03:34:39]&gt; show version
   2.8-dev9-e5e622-18

   [23:03:34:41]&gt; quit

タイム付きプロンプトがマスターCLIで設定されている場合、プロンプトは
現在選択されているプロセスの稼働時間を表示する。これはマスター、
現在のワーカー、または古いワーカーで動作する：

  master&gt; prompt timed
  [0:00:00:50] master&gt; show proc
  (...)
  [0:00:00:58] master&gt; @!11955     &lt;-- マスター、現在のワーカーに切り替え
  [0:00:01:03] 11955&gt; @!11942      &lt;-- 現在のワーカー、古いワーカーに切り替え
  [0:00:02:17] 11942&gt; @            &lt;-- 古いワーカー、マスターに戻る
  [0:00:01:10] master&gt;

複数のコマンドが一度に発行される可能性があるため、haproxyは空行を
各コマンドの出力の終わりを示す区切り文字として使用し、コマンドが
出力で空行を出力できないように注意する。したがって、スクリプトは
複数のコマンドが単一行でパイプライン化された場合でも、出力を
簡単に解析できる。

一部のコマンドはオプションのペイロードを取る場合がある。コマンドに
ペイロードを追加するには、最初の行は"&lt;&lt;\n"パターンで終わる必要がある。
次の行はペイロードとして扱われ、必要に応じて多くの行を含むことができる。
ペイロード付きのコマンドを検証するには、空行で終わる必要がある。

ペイロードパターンは、ペイロードが終わる方法を変更するために
カスタマイズできる。ペイロードを空行以外のもので終了させるために、
'&lt;&lt;'と'\n'の間にカスタマイズされたパターンを設定できる。
'&lt;&lt;'に加えて7文字のみ使用できる。そうしないと、これは
ペイロードとみなされない。例えば、空行とコメントを含むPEMファイルを
使用するには：
```
  # echo -e "set ssl cert common.pem &lt;&lt;%EOF%\n$(cat common.pem)\n%EOF%\n" | \
  socat /var/run/haproxy.stat -
```
制限が存在する：CLIに渡されるバッファ全体の長さはtune.bfsizeより
大きくてはならず、パターン"&lt;&lt;"は行の最後の単語に接着してはならない。

対話的モードでペイロードを入力する際、プロンプトは"&gt; "から"+ "に
変わる。

複数のhaproxyプロセスが同じソケットで開始されている場合、任意の
プロセスがリクエストを拾い上げ、独自の統計を出力することを
理解することが重要である。

統計ソケットで現在サポートされているコマンドのリストは以下で提供される。
未知のコマンドが送信された場合、haproxyは使用法メッセージを表示し、
これはサポートされているすべてのコマンドを思い出させる。一部のコマンドは
より複雑な構文をサポートしている。一般的に、これが発生した場合、
コマンドのどの部分が無効であるかを説明する。

一部のコマンドは動作するために高いレベルの特権を必要とする。
十分な特権がない場合、"Permission denied"エラーが表示される。
設定マニュアルの"bind"キーワード行の"level"オプションを
確認して、より詳細な情報を得てください。

## 主要なコマンド

### add server
バックエンド&lt;backend&gt;に接続された新しいサーバーをインスタンス化する。

&lt;server&gt;名はバックエンドで既に使用されていない必要がある。特別な制限が
バックエンドに置かれる。これは動的ロードバランシングアルゴリズムを
使用する必要がある。サーバー設定ファイルステートメントからの
キーワードのサブセットを使用して、サーバーの動作を設定できる
（それらをリストするには"&lt;a href="#add%20server%20help"&gt;add server help&lt;/a&gt;"を参照）。
また、同じバックエンドの仮説的な'default-server'ステートメントから
設定が再利用されないことに注意すること。

現在、動的サーバーは"none"init-addrメソッドで静的に初期化される。
これは、アドレスとしてFQDNが指定されている場合、サーバー作成が
検証される場合でも、解決が実行されないことを意味する。

リロード操作をサポートするために、CLIを介して作成されたサーバーも
関連するhaproxy設定ファイルに手動で挿入されることが期待される。
設定に存在しない動的サーバーは、リロード操作後に復元されない。

動的サーバーは"track"キーワードを使用して、設定からの別のサーバーの
チェックステータスを追跡できる。ただし、別の動的サーバーを
追跡することはできない。これは、動的サーバーの削除の場合でも
追跡チェーンが一貫して保たれることを保証するためである。

ヘルスチェックサポートを有効にするには"check"キーワードを使用すること。
ヘルスチェックはデフォルトで無効になっており、サーバーとは独立して
"&lt;a href="#enable%20health"&gt;enable health&lt;/a&gt;"コマンドを使用して有効にする必要がある。
エージェントチェックには、"agent-check"キーワードと"&lt;a href="#enable%20agent"&gt;enable agent&lt;/a&gt;"コマンドを
使用すること。この場合、サーバーは報告されたステータスに応じて
エージェントを介してアクティブ化される可能性があることに注意すること。
明示的な"&lt;a href="#enable%20server"&gt;enable server&lt;/a&gt;"コマンドなしで。
これはまた、エージェントチェック付きの動的サーバーを削除する際に
特別な注意が必要であることを意味する。エージェントは最初に
"&lt;a href="#disable%20agent"&gt;disable agent&lt;/a&gt;"を介して非アクティブ化される必要がある。
削除前にサーバーを必要なメンテナンスモードに置くために。

大量の動的サーバーを使用する場合、fd制限に達する可能性がある。
この場合は"u-limit"グローバルキーワードドキュメントを参照すること。

### clear counters
各プロキシ（フロントエンドとバックエンド）および各サーバーの
統計カウンターの最大値をクリアする。累積カウンターは影響されない。
"&lt;a href="#show%20activity"&gt;show activity&lt;/a&gt;"によって報告される内部アクティビティ
カウンターもリセットされる。これは、インシデント後にクリーンな
カウンターを取得するために使用でき、再起動やトラフィックカウンターを
クリアする必要がない。このコマンドは制限されており、レベル
"&lt;a href="#operator"&gt;operator&lt;/a&gt;"または"admin"用に設定されたソケットでのみ
発行できる。

### clear table
スティックテーブル&lt;table&gt;からエントリを削除する。

これは通常、サービスへのアクセスが不当に拒否されたと
文句を言う一部のユーザーのブロックを解除するために使用されるが、
置き換えられるサーバーに一致するスティッキネスエントリを
クリアするためにも使用できる（詳細は下記の"show table"を参照）。
エントリの削除が拒否される場合があることに注意すること。
これは現在セッションによって追跡されているためである。
セッション終了後の数秒後に再試行するのが通常十分である。

オプション引数が与えられない場合、すべてのエントリが削除される。

"data."形式が使用される場合、&lt;a href="#4.2"&gt;セクション4.2&lt;/a&gt;の"stick-table"で
使用されるフィルターを適用して一致するエントリが使用される。
格納されたデータタイプは&lt;type&gt;で指定する必要があり、このデータタイプは
テーブルに格納される必要がある。そうしないとエラーが報告される。
データは&lt;operator&gt;に従って64ビット整数&lt;value&gt;と比較される。
演算子はACLと同じである：

  - eq : データがこの値に等しいエントリに一致
  - ne : データがこの値に等しくないエントリに一致
  - le : データがこの値以下のエントリに一致
  - ge : データがこの値以上のエントリに一致
  - lt : データがこの値未満のエントリに一致
  - gt : データがこの値より大きいエントリに一致

この形式では、ビルド時に定義された最大値（デフォルトで4）まで、
複数のデータフィルターエントリを使用できる。

key形式が使用される場合、エントリ&lt;key&gt;が表示される。
キーはテーブルと同じタイプである必要があり、現在はIPv4、IPv6、
整数、文字列に制限されている。

ptr形式が使用される場合、エントリ&lt;ptr&gt;が表示される。
&lt;ptr&gt;は0xffffの形式で記述され、前の"&lt;a href="#show%20table"&gt;show table&lt;/a&gt;"コマンドによって
返されたアドレスに対応する必要がある。ポインタを使用してエントリを
一致させることは、空のキーやCLIで互換性のない文字のために
キーを使用してエントリを一致させることができない場合に関連する
可能性がある。

data.&lt;type&gt;が配列タイプの場合、"[]"を使用して配列内の特定の
インデックスにアクセスできる。例：data.gpt[1]

データ基準が時間に依存する動的值（バイトレートなど）に適用される場合、
値はエントリの評価中に動的に計算される。これは、エントリを
ダンプする必要があるかどうかを決定するためである。
これは、そのようなフィルターが一時的に一致し、その後
時間が経つにつれて平均イベントレートが低下するため、
一致しなくなる可能性があることを意味する。

これは、サービスを悪用しているIPアドレスのリストを抽出して、
それらを監視したり、ファイアウォールでブラックリストに
登録したりするために使用できる。
### 9.4 マスターCLI

マスターCLIは、マスター-ワーカーモードでマスタープロセスにバインドされた
ソケットである。このCLIは、実行中または終了中のすべてのプロセスで
Unixソケットコマンドにアクセスでき、それらのプロセスの基本的な
監視を可能にする。

マスターCLIは、haproxyプログラム引数の-Sオプションからのみ設定可能である。
このオプションはまた、カンマで区切られたバインドオプションも取る。

例：
```bash
# haproxy -W -S 127.0.0.1:1234 -f test1.cfg
# haproxy -Ws -S /tmp/master-socket,uid,1000,gid,1000,mode,600 -f test1.cfg
# haproxy -W -S /tmp/master-socket,level,user -f test1.cfg
```

#### 9.4.1 マスターCLIコマンド

**@&lt;[!]pid&gt;**
  マスターCLIは、複数のプロセスにアクセスするために特別なプレフィックス記法を
  使用する。この記法は@で始まるため、簡単に識別できる。

  @プレフィックスの後に相対プロセス番号または感嘆符とPIDが続く
  （例：@1または@!1271）。@だけでもマスターを指定するために
  使用できる。終了中のプロセスはPIDでのみアクセス可能である。
  相対プロセス番号は現在のプロセスでのみ使用可能である。

  このプレフィックスは、コマンドの前のラッパーとして使用でき、
  このコマンドとこれのみが指定されたプロセスに送信されることを示す。
  この場合、完全なコマンドは行の終わりまたはセミコロンで終わる。
  これは他の通常のコマンドと同様である。

例：
```bash
$ socat /var/run/haproxy-master.sock readline
prompt
master&gt; @1 show info; @2 show info
[...]
Process_num: 1
Pid: 1271
[...]
Process_num: 2
Pid: 1272
[...]
master&gt;

$ echo '@!1271 show info; @!1272 show info' | socat /var/run/haproxy-master.sock -
[...]
```

プレフィックスはまた、スタンドアロンコマンドとして使用して、
デフォルトの実行コンテキストを指定されたプロセスに切り替えることもできる。
これは、すべての後続のコマンドがそのプロセスで実行されることを示す。
新しい'@'コマンドが実行コンテキストを再び変更するまで。

例：
```bash
$ socat /var/run/haproxy-master.sock readline
prompt
master&gt; @1
1271&gt; show info
[...]
1271&gt; show stat
[...]
1271&gt; @
master&gt;

$ echo '@1; show info; show stat; @2; show info; show stat' | socat /var/run/haproxy-master.sock -
[...]
```

制限に関する注意：まれなコマンドがCLIセッションの状態を変更する
（例："&lt;a href="#set%20anon"&gt;set anon&lt;/a&gt;"、"&lt;a href="#set%20timeout"&gt;set timeout&lt;/a&gt;"）。
これらは、コマンドが独自のCLIセッションで一度に1つずつ送信されるため、
マスターCLIから実行された場合、正確に同様に動作しない場合がある。
同様に、まれなコマンド（"&lt;a href="#show%20events"&gt;show events&lt;/a&gt;"、"&lt;a href="#wait"&gt;wait&lt;/a&gt;"）は
CLIの入力または終了を積極的に監視し、CLIが閉じられると
すぐに中断される。これらのコマンドは、コマンドの入力が
各コマンドの後に閉じられるため、マスターCLIを介して
期待通りに動作しない。そのようなまれなケースでは、
以下の"@@"バリアントがより適している場合がある。

**@@&lt;[!]pid&gt; [command...]**
  このプレフィックスまたはコマンドは、上記で文書化された"@"プレフィックスと
  非常によく似ている。ただし、ワーカープロセスに入り、コマンドライン全体を
  そのままそれに配信し、コマンドが完了するまでそこに留まる。
  セミコロンも配信されるため、ワーカープロセスで完全なパイプライン化された
  コマンドを実行できる。ワーカーとの接続は、コマンドのリストが
  完了するまで開いたままである。コマンドの後に送信されたデータは
  ワーカープロセスのCLIに転送され、実行中のコマンドによって
  消費される可能性があり、マスタープロセスのCLIでは失われる。
  これにより、ワーカープロセスとの真の双方向接続が提供される。
  そのため、そのようなコマンドのユーザーは、マスターCLIに
  新しいコマンドを送信する前に、コマンドの完了を待つことに
  非常に注意する必要がある。

  単一のコマンドを実行する代わりに、コマンドを指定しないことによって
  ワーカープロセスで完全に対話的セッションを開くことも可能である
  （つまり、単独の行で"@@1"）。このセッションは、接続を閉じるか、
  ワーカープロセスを終了することによって終了できる
  （"&lt;a href="#quit"&gt;quit&lt;/a&gt;"コマンドを使用）。この場合、マスターソケットの
  プロンプトモード（対話的、プロンプト、タイム付き）が
  ワーカープロセスに伝播される。

例：
```bash
# 接続を適切に閉じて、サーバーがアイドルになったら削除（最大10秒待機）
$ socat -t 11 /var/run/haproxy-master.sock - &lt;&lt;&lt; \
   "@@1 disable server app2/srv36; \
   wait 10000 srv-removable app2/srv36; \
   del server app2/srv36"

# 接続を強制的に閉じて、サーバーを素早く削除
$ socat /var/run/haproxy-master.sock - &lt;&lt;&lt; \
   "@@1 disable server app2/srv36; \
   shutdown sessions server app2/srv36; \
   wait 100 srv-removable app2/srv36; \
   del server app2/srv36"

# このリングに到着するメッセージをリアルタイムで表示（"tail -f"と同等）
$ (echo "show events buf0 -w"; read) | socat /var/run/haproxy-master.sock -
```

**expert-mode [on|off]**
  このコマンドは、マスターCLIからアクセスされるすべてのワーカーで
  "&lt;span class="dropdown"&gt;&lt;a class="dropdown-toggle" data-toggle="dropdown" href="#"&gt;expert-mode&lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt;&lt;ul class="dropdown-menu"&gt;&lt;li class="dropdown-header"&gt;このキーワードは以下のセクションで利用可能：&lt;/li&gt;&lt;li&gt;&lt;a href="#expert-mode%20%28Unix%20Socket%20commands%29"&gt;Unix Socket commands&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#expert-mode%20%28Master%20CLI%20commands%29"&gt;Master CLI commands&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/span&gt;"をアクティブにする。
  "&lt;a href="#mcli-debug-mode"&gt;mcli-debug-mode&lt;/a&gt;"と組み合わせると、マスターでも
  コマンドをアクティブにする。マスターCLIプロンプトでフラグ"e"を表示する。

  セクション9.3の"&lt;span class="dropdown"&gt;&lt;a class="dropdown-toggle" data-toggle="dropdown" href="#"&gt;expert-mode&lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt;&lt;ul class="dropdown-menu"&gt;&lt;li class="dropdown-header"&gt;このキーワードは以下のセクションで利用可能：&lt;/li&gt;&lt;li&gt;&lt;a href="#expert-mode%20%28Unix%20Socket%20commands%29"&gt;Unix Socket commands&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#expert-mode%20%28Master%20CLI%20commands%29"&gt;Master CLI commands&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/span&gt;"と9.4.1の"&lt;a href="#mcli-debug-mode"&gt;mcli-debug-mode&lt;/a&gt;"も参照すること。

**experimental-mode [on|off]**
  このコマンドは、マスターCLIからアクセスされるすべてのワーカーで
  "&lt;span class="dropdown"&gt;&lt;a class="dropdown-toggle" data-toggle="dropdown" href="#"&gt;experimental-mode&lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt;&lt;ul class="dropdown-menu"&gt;&lt;li class="dropdown-header"&gt;このキーワードは以下のセクションで利用可能：&lt;/li&gt;&lt;li&gt;&lt;a href="#experimental-mode%20%28Unix%20Socket%20commands%29"&gt;Unix Socket commands&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#experimental-mode%20%28Master%20CLI%20commands%29"&gt;Master CLI commands&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/span&gt;"をアクティブにする。
  "&lt;a href="#mcli-debug-mode"&gt;mcli-debug-mode&lt;/a&gt;"と組み合わせると、マスターでも
  コマンドをアクティブにする。マスターCLIプロンプトでフラグ"x"を表示する。

  セクション9.3の"&lt;span class="dropdown"&gt;&lt;a class="dropdown-toggle" data-toggle="dropdown" href="#"&gt;experimental-mode&lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt;&lt;ul class="dropdown-menu"&gt;&lt;li class="dropdown-header"&gt;このキーワードは以下のセクションで利用可能：&lt;/li&gt;&lt;li&gt;&lt;a href="#experimental-mode%20%28Unix%20Socket%20commands%29"&gt;Unix Socket commands&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#experimental-mode%20%28Master%20CLI%20commands%29"&gt;Master CLI commands&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/span&gt;"と9.4.1の"&lt;a href="#mcli-debug-mode"&gt;mcli-debug-mode&lt;/a&gt;"も参照すること。

**hard-reload**
  このコマンドは、マスターCLIを介して"&lt;a href="#reload"&gt;reload&lt;/a&gt;"コマンドと同じことを行う。
  ただし、前のプロセスをstop-stop（-sf）ではなくhard-stop（-st）で
  行う点が異なる。これは前のプロセスが何かを達成するのを待たずに
  終了することを意味するため、すべての接続が閉じられる。

  "&lt;a href="#reload"&gt;reload&lt;/a&gt;"コマンドも参照すること。

**mcli-debug-mode [on|off]**
  このキーワードは、マスターCLIで特別なモードを可能にする。
  これにより、ワーカーCLI用に意図されたすべてのキーワードが
  マスターCLIで有効になり、マスタープロセスをデバッグできる。
  一度アクティブになると、"&lt;a href="#help"&gt;help&lt;/a&gt;"で新しい利用可能な
  キーワードをリストできる。"&lt;span class="dropdown"&gt;&lt;a class="dropdown-toggle" data-toggle="dropdown" href="#"&gt;experimental-mode&lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt;&lt;ul class="dropdown-menu"&gt;&lt;li class="dropdown-header"&gt;このキーワードは以下のセクションで利用可能：&lt;/li&gt;&lt;li&gt;&lt;a href="#experimental-mode%20%28Unix%20Socket%20commands%29"&gt;Unix Socket commands&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#experimental-mode%20%28Master%20CLI%20commands%29"&gt;Master CLI commands&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/span&gt;"または"&lt;span class="dropdown"&gt;&lt;a class="dropdown-toggle" data-toggle="dropdown" href="#"&gt;expert-mode&lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt;&lt;ul class="dropdown-menu"&gt;&lt;li class="dropdown-header"&gt;このキーワードは以下のセクションで利用可能：&lt;/li&gt;&lt;li&gt;&lt;a href="#expert-mode%20%28Unix%20Socket%20commands%29"&gt;Unix Socket commands&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#expert-mode%20%28Master%20CLI%20commands%29"&gt;Master CLI commands&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/span&gt;"と組み合わせると、
  さらに多くのキーワードが有効になる。マスターCLIプロンプトでフラグ"d"を表示する。

**prompt**
  プロンプトが有効になっている場合（"&lt;span class="dropdown"&gt;&lt;a class="dropdown-toggle" data-toggle="dropdown" href="#"&gt;prompt&lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt;&lt;ul class="dropdown-menu"&gt;&lt;li class="dropdown-header"&gt;このキーワードは以下のセクションで利用可能：&lt;/li&gt;&lt;li&gt;&lt;a href="#prompt%20%28Unix%20Socket%20commands%29"&gt;Unix Socket commands&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="#prompt%20%28Master%20CLI%20commands%29"&gt;Master CLI commands&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/span&gt;"コマンドを介して）、CLIが動作している
  コンテキストがプロンプトに表示される。マスターは"master"文字列で
  識別され、他のプロセスはPIDで識別される。最後のリロードが
  失敗した場合、マスタープロンプトは"master[ReloadFailed]&gt;"に
  変更される。これにより、プロセスが前の設定でまだ実行されており、
  新しい設定が動作していないことが見えるようになる。

  マスターCLIのプロンプトは、有効なモードであるいくつかのフラグを
  表示できる。"d"はmcli-debug-mode、"e"はexpert-mode、
  "x"はexperimental-modeである。

例：
```bash
$ socat /var/run/haproxy-master.sock -
prompt
master&gt; expert-mode on
master(e)&gt; experimental-mode on
master(xe)&gt; mcli-debug-mode on
master(xed)&gt; @1
95191(xed)&gt;
```

**reload**
  マスタープロセスに少なくとも"&lt;a href="#operator"&gt;operator&lt;/a&gt;"または"admin"特権を
  持つユーザーがいる場合、マスターCLIを介してHAProxyマスタープロセスを
  リロードすることもできる。これは、マスタープロセスで`kill -USR2`を
  実行するのと同じことを行う"&lt;a href="#reload"&gt;reload&lt;/a&gt;"コマンドである。

  このコマンドは、同期的なリロードを実行することを可能にする。
  コマンドはリロードステータスを返し、リロードが実行された後に
  一度返される。ツールを使用して解析する場合はタイムアウトに
  注意すること。設定が解析され、新しいワーカーがフォークされた
  後にのみ返される。"socat"コマンドはデフォルトで0.5秒の
  タイムアウトを使用するため、リロードが長すぎる場合は
  メッセージを表示する前に終了する。"ncat"はデフォルトで
  タイムアウトがない。
  USE_SHM_OPEN=1でコンパイルされている場合、reloadコマンドは
  マスターの起動ログもダンプできる。

例：
```bash
$ echo "&lt;a href="#reload"&gt;reload&lt;/a&gt;" | socat -t300 /var/run/haproxy-master.sock stdin
Success=1
--
[NOTICE]   (482713) : haproxy version is 2.7-dev7-4827fb-69
[NOTICE]   (482713) : path to executable is ./haproxy
[WARNING]  (482713) : config : 'http-request' rules ignored for proxy 'frt1' as they require HTTP mode.
[NOTICE]   (482713) : New worker (482720) forked
[NOTICE]   (482713) : Loading success.

$ echo "&lt;a href="#reload"&gt;reload&lt;/a&gt;" | socat -t300 /var/run/haproxy-master.sock stdin
Success=0
--
[NOTICE]   (482886) : haproxy version is 2.7-dev7-4827fb-69
[NOTICE]   (482886) : path to executable is ./haproxy
[ALERT]    (482886) : config : parsing [test3.cfg:1]: unknown keyword 'Aglobal' out of section.
[ALERT]    (482886) : config : Fatal errors found in configuration.
[WARNING]  (482886) : Loading failure!

$
```

reloadコマンドはマスターCLIで最後に実行される。その後の
他のすべてのコマンドは無視される。reloadコマンドがその
ステータスを返した後、CLIへの接続を閉じる。

リロードはマスターCLIへのすべての接続を閉じることに注意すること。
"&lt;a href="#hard-reload"&gt;hard-reload&lt;/a&gt;"コマンドも参照すること。

**show proc [debug]**
  マスターCLIは、プロセスを監視するための'show proc'コマンドを導入する。

例：
```bash
$ echo 'show proc' | socat /var/run/haproxy-master.sock -
#&lt;PID&gt;          &lt;type&gt;          &lt;reloads&gt;       &lt;uptime&gt;        &lt;version&gt;
1162            master          5 [failed: 0]   0d00h02m07s     2.5-dev13
# workers
1271            worker          1               0d00h00m00s     2.5-dev13
# old workers
1233            worker          3               0d00h00m43s     2.0-dev3-6019f6-289
# programs
1244            foo             0               0d00h00m00s     -
1255            bar             0               0d00h00m00s     -
```

この例では、マスターは5回リロードされたが、古いワーカーの1つが
まだ実行中で、3回のリロードを生き延びた。このワーカーのCLIに
アクセスして、何が起こっているかを理解できる。

'debug'パラメータはデバッグの詳細を表示するのに便利である。
現在はIPC通信用のFDを表示する。デバッグ出力はhaproxyバージョン間で
安定していることが保証されていないことに注意すること。

**show startup-logs**
  HAProxyは、マスターCLIで正しく使用されるためにUSE_SHM_OPEN=1で
  コンパイルされる必要がある。そうしないと、すべてのメッセージが
  見えない。

  統計ソケットの対応物と同様に、このコマンドはHAProxyの起動メッセージを
  表示できる。ただし、現在のワーカーの起動メッセージではなく、
  最新の起動またはリロードの起動メッセージをダンプする。
  これは失敗したリロードの解析メッセージをダンプできることを意味する。

  これらのメッセージはまた、"&lt;a href="#reload"&gt;reload&lt;/a&gt;"コマンドでもダンプされる。
### 9.5 統計ファイル

いわゆる統計ファイルは、プロセス起動時に内部haproxyカウンターを
非null値でプリロードするために使用できる。その主な目的は、
リロード間でワーカープロセスの統計を保持することである。
露出されたhaproxy統計のすべての抜粋のみが統計ファイルに存在する。
これはメトリックタイプの値をプリロードすることのみが意味があるためである。

現在、統計ファイルではプロキシカウンターのみがサポートされている。
これにより、フロントエンド、バックエンド、サーバー、リスナーの値を
プリロードできる。ただし、空でないGUIDを持つオブジェクトインスタンスのみが
統計ファイルに格納される。これにより、一致するタイプとGUIDを持つ
オブジェクトの値がプリロードされることが保証される。
他のパラメータが異なる場合でも。

CLIコマンド"&lt;a href="#dump%20stats-file"&gt;dump stats-file&lt;/a&gt;"の目的は統計ファイルを生成することである。
統計ファイルの形式は内部的に定義され、将来の変更と拡張に
自由に従う。これは少なくとも隣接するhaproxy安定ブランチリリース間で
互換性があるように設計されているが、古いバージョンで実行されている
プロセスに統計ファイルをロードする際に、オプションの追加設定が
必要になる場合がある。
## 10. 設定管理を容易にするためのトリック

クラスタを構成する2つのHAProxyノードが、いくつかのアドレスを除いて全く同じ設定を共有することは非常に一般的である。各ノードに対して重複した設定を維持する必要はなく、それは必然的に分岐してしまうが、設定に環境変数を含めることが可能である。このように、複数の設定が、システム全体の環境変数が少し異なるだけで、全く同じファイルを共有できる。これはバージョン1.5で始まり、当初はアドレスのみが環境変数を含むことができたが、1.6では環境変数をどこでもサポートすることでさらに進歩している。構文はUNIXシェルと同じで、変数はドル記号（'$'）で始まり、その後に開き中括弧（'{'）が続き、変数名の後に閉じ中括弧（'}'）が続く。アドレスを除いて、環境変数は二重引用符で囲まれた引数でのみ解釈される（これは、ドル記号を含む正規表現を使用する既存の設定を壊さないために必要であった）。

環境変数はまた、アドレスのみが変更される様々なサイトで動作することが期待される設定を書くのに便利である。また、一部の設定からパスワードを削除することも可能である。以下は、ファイル「site1.env」が起動時にinitスクリプトによってソースされる例である：

  $ cat site1.env
  LISTEN=192.168.1.1
  CACHE_PFX=192.168.11
  SERVER_PFX=192.168.22
  LOGGER=192.168.33.1
  STATSLP=admin:pa$$w0rd
  ABUSERS=/etc/haproxy/abuse.lst
  TIMEOUT=10s

  $ cat haproxy.cfg
  global
      log "${LOGGER}:514" local0

  defaults
      mode http
      timeout client "${TIMEOUT}"
      timeout server "${TIMEOUT}"
      timeout connect 5s

  frontend public
      bind "${LISTEN}:80"
      http-request reject if { src -f "${ABUSERS}" }
      stats uri /stats
      stats auth "${STATSLP}"
      use_backend cache if { path_end .jpg .css .ico }
      default_backend server

  backend cache
      server cache1 "${CACHE_PFX}.1:18080" check
      server cache2 "${CACHE_PFX}.2:18080" check

  backend server
      server cache1 "${SERVER_PFX}.1:8080" check
      server cache2 "${SERVER_PFX}.2:8080" check
## 11. 避けるべきよくある落とし穴

時々、システムの再起動後にhaproxyサービスが起動しなかったという報告があり、手動で起動すると動作するということがある。多くの場合、これらの人々はkeepalivedなどのクラスタ化されたIPアドレスメカニズムを実行しており、サービスIPアドレスをマスターノードのみに割り当てている。そして、haproxyをアドレス0.0.0.0にバインドしていた時は動作していたが、仮想IPアドレスにバインドした後は動作しなくなった。ここで起こることは、サービスが起動する時、仮想IPアドレスはまだローカルノードによって所有されていないため、HAProxyがそれにバインドしようとすると、システムはそれがローカルIPアドレスではないとしてこれを拒否するということである。修正はhaproxyサービスの起動を遅延させることではない（再起動に耐えられないため）。代わりに、システムを適切に設定して非ローカルアドレスへのバインドを許可することである。これはLinuxではnet.ipv4.ip_nonlocal_bind sysctlを1に設定することで簡単に行える。これはまた、特定のターゲットアドレスに対してHAProxyを通過するIPトラフィックを透過的に傍受するために必要である。

ソースポート範囲を含むマルチプロセス設定は、一見動作するように見えるかもしれないが、高負荷下ではランダムな失敗を引き起こす。なぜなら、複数のプロセスが同じサーバーに接続するために同じソースポートを使用しようとする可能性があり、これは不可能であるためである。システムはエラーを報告し、再試行が発生して別のポートが選択される。「retries」パラメータの高い値はある程度まで効果を隠すかもしれないが、これもまたCPU使用量と処理時間の増加を伴う。ログにも一定数の再試行が報告される。この理由により、マルチプロセス設定ではポート範囲を避けるべきである。

HAProxyはSO_REUSEPORTを使用し、同じIP:ポートに複数の独立したプロセスをバインドすることをサポートしているため、トラブルシューティング中に古いプロセスが新しいプロセスが起動される前に停止されていないことが起こり得る。これは、設定への変更が無視されていることを示す傾向がある不合理なテスト結果を提供する。理由は、実際には新しいプロセスが新しい設定で再起動されても、古いプロセスも着信接続を受け取り、それらを処理して予期しない結果を返すということである。疑わしい場合は、新しいプロセスを停止して再試行するだけである。それでも動作する場合、古いプロセスが生き残っており、停止する必要があることを意味する可能性が非常に高い。Linuxの「netstat -lntp」はここで良い助けになる。

コマンドラインからACLにエントリを追加する時（例：ソースアドレスをブラックリストに登録する時）、これらのエントリがファイルに同期されず、誰かが設定をリロードした場合、これらの更新が失われることを覚えておくことが重要である。これはしばしば望ましい効果である（ブラックリスト登録のため）が、変更が問題の修正として行われた場合、必ずしも期待と一致しないかもしれない。「add acl」アクションについてはCLIインターフェースを参照すること。
## 12. デバッグとパフォーマンスの問題

HAProxyが「-d」オプションで起動されると、フォアグラウンドで動作し、着信接続、接続の終了、見られた各リクエストまたはレスポンスヘッダー行などのイベントごとに1行を出力する。このデバッグ出力は内容が処理される前に出力されるため、ローカルな変更は考慮されない。主な用途は、ネットワークスニッファーを実行することなくリクエストとレスポンスを表示することである。複数の接続が並行して処理される場合、出力は読みにくくなるが、examples/ディレクトリにある「debug2ansi」と「debug2html」スクリプトが出力に色を付けることで確実に役立つ。

HTTP/1.xリクエストまたはレスポンスがHAProxyによって不正な形式であると判断されて拒否される場合、最善の方法はCLIに接続して「show errors」を実行することである。これにより、各フロントエンドとバックエンドについて、最後にキャプチャされた不正なHTTP/1.xリクエストとレスポンスが報告され、入力ストリームで拒否された最初の文字を正確に示すために必要なすべての情報が提供される。これは時々、顧客や開発者にコードにバグが存在することを証明するために必要である。この場合、「option accept-unsafe-violations-in-http-request」またはサーバーからのレスポンスに対する同等の「option accept-unsafe-violations-in-http-response」を使用してチェックを緩和することができる（ただし、キャプチャは保持する）。詳細については設定マニュアルを参照してください。

**例：**

```
&gt; show errors
Total events captured on [13/Oct/2015:13:43:47.169] : 1

[13/Oct/2015:13:43:40.918] frontend HAProxyLocalStats (#2): invalid request
  backend &lt;NONE&gt; (#-1), server &lt;NONE&gt; (#-1), event #0
  src 127.0.0.1:51981, session #0, session flags 0x00000080
  HTTP msg state 26, msg flags 0x00000000, tx flags 0x00000000
  HTTP chunk len 0 bytes, HTTP body len 0 bytes
  buffer flags 0x00808002, out 0 bytes, total 31 bytes
  pending 31 bytes, wrapping at 8040, error at position 13:

  00000  GET /invalid request HTTP/1.1\r\n
```

CLIでの「show info」の出力は、これまでに達成された最大接続率、これまでに達成された最大SSLキー率、およびCPUやメモリ使用量に関する一時的な問題を説明するのに役立つ一般的な情報を提供する。例：

```
  &gt; show info
  Name: HAProxy
  Version: 1.6-dev7-e32d18-17
  Release_date: 2015/10/12
  Nbproc: 1
  Process_num: 1
  Pid: 7949
  Uptime: 0d 0h02m39s
  Uptime_sec: 159
  Memmax_MB: 0
  Ulimit-n: 120032
  Maxsock: 120032
  Maxconn: 60000
  Hard_maxconn: 60000
  CurrConns: 0
  CumConns: 3
  CumReq: 3
  MaxSslConns: 0
  CurrSslConns: 0
  CumSslConns: 0
  Maxpipes: 0
  PipesUsed: 0
  PipesFree: 0
  ConnRate: 0
  ConnRateLimit: 0
  MaxConnRate: 1
  SessRate: 0
  SessRateLimit: 0
  MaxSessRate: 1
  SslRate: 0
  SslRateLimit: 0
  MaxSslRate: 0
  SslFrontendKeyRate: 0
  SslFrontendMaxKeyRate: 0
  SslFrontendSessionReuse_pct: 0
  SslBackendKeyRate: 0
  SslBackendMaxKeyRate: 0
  SslCacheLookups: 0
  SslCacheMisses: 0
  CompressBpsIn: 0
  CompressBpsOut: 0
  CompressBpsRateLim: 0
  ZlibMemUsage: 0
  MaxZlibMemUsage: 0
  Tasks: 5
  Run_queue: 1
  Idle_pct: 100
  node: wtap
  description:
```

HAProxyの新しいバージョンで問題がランダムに発生するように見える場合（例：2番目のリクエストが毎回中止される、時々クラッシュするなど）、メモリポイズニングを有効にすることは価値がある。これにより、malloc()の各呼び出しの直後に、設定可能なバイトでメモリ領域が埋められる。デフォルトでは、このバイトは0x50（'P'のASCII）であるが、ゼロを含む他のバイトも使用できる（ゼロはcalloc()と同じ効果を持ち、問題を消失させる可能性がある）。メモリポイズニングはコマンドラインで「-dM」オプションを使用して有効になる。これはパフォーマンスをわずかに損なうため、本番環境での使用は推奨されない。問題が常に発生するか、ポイズニングでゼロバイトを使用した場合に決して発生しない場合、明らかにバグを見つけたことを意味し、確実に報告する必要がある。それ以外の場合、明確な変化がない場合、問題は関連していない。

レイテンシの問題をデバッグする場合、ローカルマシンでstraceとtcpdumpの両方を使用し、リモートシステムで別のtcpdumpを使用することが重要である。その理由は、処理チェーン全体に遅延があり、どの遅延がレイテンシを引き起こしているかを知ることが重要であり、どこで行動すべきかを知る必要があるためである。実際には、ローカルのtcpdumpは入力データがいつ入ってくるかを示す。straceはhaproxyがこれらのデータを受信した時を示す（recv/recvfromを使用）。警告、opensslはrecv()/send()の代わりにread()/write()システムコールを使用する。straceはまたhaproxyがデータを送信した時も示し、tcpdumpはシステムがこれらのデータをインターフェースに送信した時を示す。その後、外部のtcpdumpは送信されたデータが実際に受信された時を示す（ローカルのものはパケットがキューに入れられた時のみを示すため）。ローカルシステムでスニッフィングすることの利点は、straceとtcpdumpが同じ基準クロックを使用することである。straceは「-tts200」で使用して、完全なタイムスタンプを取得し、読み取るのに十分な大きさのデータチャンクを報告する必要がある。tcpdumpは「-nvvttSs0」で使用して、完全なパケット、実際のシーケンス番号、完全なタイムスタンプを報告する必要がある。

実際には、受信されたデータはほとんど常にhaproxyによって即座に受信される（マシンのCPUが飽和しているか、これらのデータが無効で配信されていない場合を除く）。これらのデータが受信されるが送信されない場合、一般的に出力バッファが飽和しているためである（つまり：受信者がデータを十分に速く消費しない）。これは、ポーリングがしばらくの間出力ファイル記述子への書き込み能力を通知しないことを確認することで確認できる（データが最終的に離れる時をstrace出力で見つけ、その後書き込みイベントが通知された時を振り返って確認する方がしばしば簡単である）。これは一般的に受信者から受信されたACKと一致し、tcpdumpによって検出される。データが送信されると、システム内で何もしないでしばらく時間を過ごす可能性がある。ここでも、TCP輻輳ウィンドウが制限され、ACKがウィンドウを開くのを待って、これらのデータが離れることを許可しない可能性がある。トラフィックがアイドルで、データが離れるのに40msまたは200msかかる場合、これは別の問題である（問題ではない）、Nagleアルゴリズムが空のパケットが即座に離れることを防ぎ、後続のデータとマージされることを期待しているという事実である。HAProxyは純粋なTCPモードとトンネルでNagleを自動的に無効にする。しかし、HTTPボディを転送する際には確実に有効のままである（これによりパケット数が減少し、パフォーマンスが向上する）。一部のHTTP非準拠アプリケーションは、不完全なHTTPレスポンスメッセージを配信する際のレイテンシに敏感である可能性がある。この場合、「option http-no-delay」を有効にしてNagleを無効にし、設計を回避する必要がある。チェーン内の他のプロキシも同様に影響を受ける可能性があることを覚えておく必要がある。tcpdumpがデータが即座に離れることを報告するが、もう一方の端がそれらを素早く見ない場合、輻輳したWANリンク、フロー制御が有効でデータの離脱を防ぐ輻輳したLAN、またはより一般的にはHAProxyが実際に仮想マシンで実行されており、何らかの理由でハイパーバイザーがデータを即座に送信する必要がないと判断したことを意味する可能性がある。仮想化環境では、レイテンシの問題はほとんど常に仮想化レイヤーによって引き起こされるため、時間を節約するために、VMと外部コンポーネントでtcpdumpを比較することは価値がある。違いがあれば、ハイパーバイザーとその付随するドライバーに帰因する必要がある。

tcpdumpトレースで一部のTCP SACKセグメントが見られる場合（-vvを使用）、それらを送信している側が失われたパケットの証拠を得たことを常に意味する。それらが見えないことは損失がないことを意味しないが、それらが見えることは確実にネットワークが損失が多いことを意味する。ネットワークでの損失は正常であるが、SACKが肉眼で目立たないレートである。トレースで大量に現れる場合、何が起こり、どこでパケットが失われたかを正確に調査する価値がある。HTTPはTCP損失に対処できず、これにより巨大なレイテンシが導入される。

「netstat -i」コマンドはインターフェースごとの統計を報告する。Rx-Ovrカウンターが増加するインターフェースは、システムがすべての着信パケットを受信するのに十分なリソースを持たず、ネットワークドライバーによって処理される前に失われることを示す。Rx-Drpは、アプリケーションがそれらを十分に速く処理しないため、ネットワークスタックで一部の受信パケットが失われたことを示す。これは一部の攻撃中にも発生する可能性がある。Tx-Drpは、出力キューが満杯でパケットをドロップする必要があったことを意味する。TCPを使用する場合、これは非常にまれであるべきだが、輻輳した発信リンクを示す可能性がある。
## 13. セキュリティに関する考慮事項

HAProxyは、非常に限定的な権限で実行するように設計されている。標準的な使用方法は、chroot jail内に隔離し、その権限をこのjail内に何の権限も持たない非rootユーザーに下げることである。これにより、将来的に脆弱性が発見された場合でも、その侵害はシステムの残りの部分に影響を与えない。

chrootを実行するために、最初にrootユーザーとして起動する必要がある。プロセスを開始するために手作りのchrootを構築することは無意味である。これらは構築が苦痛であり、適切に維持されることはなく、常にメインファイルシステムよりも多くのバグを含んでいる。そして侵害の場合、侵入者は意図的に構築されたファイルシステムを使用できる。残念ながら、多くの管理者が「rootとして起動」と「rootとして実行」を混同しており、uidの変更がhaproxyを開始する前に行われ、効果的なセキュリティ制限が減少している。

HAProxyは以下の理由でrootとして起動する必要がある：
  - ファイル記述子の制限を調整する
  - 特権ポート番号にバインドする
  - 特定のネットワークインターフェースにバインドする
  - 外部アドレスを透過的にリッスンする
  - chroot jail内で自身を隔離する
  - 別の非特権UIDに下げる

HAProxyは以下の理由でrootとして実行する必要がある場合がある：
  - 発信接続用のインターフェースにバインドする
  - 発信接続用の特権ソースポートにバインドする
  - 発信接続用の外部アドレスに透過的にバインドする

ほとんどのユーザーは「rootとして実行」のケースを必要としない。しかし「rootとして起動」はほとんどの使用法をカバーしている。

安全な設定には以下が含まれる：

  - アクセス権限のない空の場所を指すchroot文。これはUNIXコマンドラインで以下のように準備できる：

      # mkdir /var/empty && chmod 0 /var/empty || echo "Failed"

    そして、HAProxy設定のglobalセクションで以下のように参照される：

      chroot /var/empty

  - globalセクションのuid/userとgid/group文の両方：

      user haproxy
      group haproxy

  - モード、uid、gidがCLIにアクセスを許可されたユーザーやグループに一致するように設定されたstats socket。これにより誰もアクセスできない：

      stats socket /var/run/haproxy.stat uid hatop gid hatop mode 600
### 13.1 Linux capabilities support

バージョンv2.9以降、haproxyはLinux capabilitiesをサポートしている。バイナリがUSE_LINUX_CAP=1でコンパイルされている場合、rootユーザーから非rootユーザーへの切り替え時に'setcap'キーワードで指定されたcapabilitiesを保持できる。

バージョンv3.1以降、haproxyは'setcap'キーワードで指定されたcapabilitiesが管理者によってバイナリファイルのPermitted setに設定されているかもチェックする（capget syscall）。これが該当する場合、非rootユーザーとして実行中に、これらのcapabilitiesをプロセスのEffective set（capset syscall）に移行する。

これは、haproxyがrootとして起動し実行されるすべての潜在的なユースケースを避けるために行われた：透過プロキシモード、特権ポートへのバインド。

'setcap'キーワードは以下のネットワークcapabilitiesをサポートしている：
- cap_net_admin: 透過プロキシ、特定のネットワークインターフェースへのソケットバインド、set-markアクションの使用；
- cap_net_raw（cap_net_adminのサブセット）: 透過プロキシ；
- cap_net_bind_service: 特定のネットワークインターフェースへのソケットバインド；
- cap_sys_admin: 特定のネットワーク名前空間でのソケット作成。

Haproxyは、これらのcapabilitiesが'setcap'引数としてリストされていない場合、それらをPermitted setからEffective setに移行することはない。'setcap'キーワードとサポートされているcapabilitiesについての詳細は、設定ガイドの第3.1章プロセス管理とセキュリティを参照のこと。

管理者は以下のコマンドでhaproxyバイナリファイルのPermitted setに必要なcapabilitiesを追加できる：

**例：**
```bash
# setcap cap_net_admin,cap_net_bind_service=p /usr/local/sbin/haproxy
```

追加されたcapabilitiesは、プロセス開始後にそのPermitted setで確認できる。同じcapabilitiesが'setcap'キーワードの引数である場合、それらはプロセスのEffective setでも確認できる。これは以下のコマンドでチェックできる：

**例：**
```bash
# grep Cap /proc/&lt;haproxy PID&gt;/status
CapInh:        0000000000000000
CapPrm:        0000000000001400
CapEff:        0000000000001400
CapBnd:        000001ffffffffff
CapAmb:        0000000000000000
```

setcapとcapabilities setsについての詳細は、Linux manページ（capabilities(7)）を参照のこと。

透過プロキシや特定のネットワーク名前空間でのソケット作成などの一部のユースケースでは、設定ファイルパーサーがcap_net_rawやcap_sys_admin、またはその他のサポートされているcapabilitiesが必要であることを検出する。その後、初期化段階中に、haproxyプロセスはこれらのcapabilitiesをそのEffective setに配置できるかチェックする。capgetやcapset syscallの失敗（SELinux、Seccompなどの一部のセキュリティモジュールによってsyscallに設定された制限）により不可能な場合、プロセスは診断警告を発する（-dDで開始）。

多くの異なるプラットフォームと異なるシステム設定のサポートにより、パーサーが設定ファイルから特権ポートへのバインドが行われるかを推論することは不可能である。そのため、不十分な権限（非rootとして実行）の場合、プロセスは以下のような警告メッセージでのみ終了する。ユーザーが設定とhaproxyバイナリcapabilities setを再チェックする必要がある。

**例：**
```bash
$ haproxy -dD -f haproxy.cfg
...
[ALERT]    (96797) : Binding [haproxy.cfg:36] for frontend fe: cannot bind socket (Permission denied) for [0.0.0.0:80]
[ALERT]    (96797) : [haproxy.main()] Some protocols failed to start their listeners! Exiting.
```
